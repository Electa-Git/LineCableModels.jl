<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Validation module · LineCableModels.jl</title><meta name="title" content="Validation module · LineCableModels.jl"/><meta property="og:title" content="Validation module · LineCableModels.jl"/><meta property="twitter:title" content="Validation module · LineCableModels.jl"/><meta name="description" content="Documentation for LineCableModels.jl."/><meta property="og:description" content="Documentation for LineCableModels.jl."/><meta property="twitter:description" content="Documentation for LineCableModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/custom.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="LineCableModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LineCableModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/">Contents</a></li><li><a class="tocitem" href="../tutorials/tutorial1/">Tutorial 1 - Using the  materials library</a></li><li><a class="tocitem" href="../tutorials/tutorial2/">Tutorial 2 - Building a cable design</a></li><li><a class="tocitem" href="../tutorials/tutorial3/">Tutorial 3 - Computing line parameters</a></li></ul></li><li><a class="tocitem" href="../reference/">API reference</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Validation module</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Architecture"><span>Architecture</span></a></li><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Example-implementation-—-DataModel.Tubular"><span>Example implementation — <code>DataModel.Tubular</code></span></a></li><li><a class="tocitem" href="#Template-for-a-new-component"><span>Template for a new component</span></a></li><li><a class="tocitem" href="#Extending-traits"><span>Extending traits</span></a></li><li><a class="tocitem" href="#Testing-guidelines"><span>Testing guidelines</span></a></li><li><a class="tocitem" href="#Usage-notes"><span>Usage notes</span></a></li><li><a class="tocitem" href="#API-reference"><span>API reference</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../docstrings/">Docstrings</a></li><li><a class="tocitem" href="../TODO/">TODO</a></li><li><a class="tocitem" href="../CHANGELOG/">Changelog</a></li></ul></li><li><a class="tocitem" href="../bib/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Development</a></li><li class="is-active"><a href>Validation module</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Validation module</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Electa-Git/LineCableModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Electa-Git/LineCableModels.jl/blob/main/docs/src/validation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Validation-module"><a class="docs-heading-anchor" href="#Validation-module">Validation module</a><a id="Validation-module-1"></a><a class="docs-heading-anchor-permalink" href="#Validation-module" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Validation-module">Validation module</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Architecture">Architecture</a></li><li class="no-marker"><ul><li><a href="#Pipeline">Pipeline</a></li><li><a href="#Traits-(configuration-surface)">Traits (configuration surface)</a></li></ul></li><li><a href="#Rules">Rules</a></li><li class="no-marker"><ul><li><a href="#Standard-rules">Standard rules</a></li><li><a href="#Custom-rule-pattern">Custom rule pattern</a></li></ul></li><li><a href="#Example-implementation-—-DataModel.Tubular">Example implementation — <code>DataModel.Tubular</code></a></li><li><a href="#Template-for-a-new-component">Template for a new component</a></li><li><a href="#Extending-traits">Extending traits</a></li><li class="no-marker"><ul><li><a href="#New-feature-flags">New feature flags</a></li><li><a href="#Field‑specific-admissibility">Field‑specific admissibility</a></li></ul></li><li><a href="#Testing-guidelines">Testing guidelines</a></li><li><a href="#Usage-notes">Usage notes</a></li><li><a href="#API-reference">API reference</a></li><li><a href="#Index">Index</a></li></ul></li></ul><hr/><p>This section documents the validation framework used by component constructors. The design is deterministic, non‑magical, and trait‑driven. The flow is:</p><pre><code class="language-julia hljs">sanitize(Type, args, kwargs)  →  parse(Type, nt)  →  apply rules  →  construct</code></pre><p>The <strong>typed cores</strong> accept <strong>numbers only</strong>. All proxy handling happens in the <strong>convenience constructors</strong> via <code>validate!</code>.</p><hr/><h2 id="Architecture"><a class="docs-heading-anchor" href="#Architecture">Architecture</a><a id="Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Architecture" title="Permalink"></a></h2><h3 id="Pipeline"><a class="docs-heading-anchor" href="#Pipeline">Pipeline</a><a id="Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Pipeline" title="Permalink"></a></h3><ul><li><p><strong><code>sanitize(::Type{T}, args::Tuple, kwargs::NamedTuple)</code></strong></p><ul><li>Rejects wrong arities: exactly <code>length(required_fields(T))</code> positionals are expected; optionals must be passed as keywords listed in <code>keyword_fields(T)</code>.</li><li>Maps positionals to names using <code>required_fields(T)</code>; merges keyword arguments; rejects unknown keywords.</li><li>If <code>has_radii(T) == true</code>, checks admissibility of raw radius inputs with <code>is_radius_input(T, Val(:radius_in), x)</code> and <code>is_radius_input(T, Val(:radius_ext), x)</code>. The default accepts only real, non‑complex numbers; types may extend to allow proxies.</li><li>Returns a <strong>raw</strong> <code>NamedTuple</code>.</li></ul></li><li><p><strong><code>parse(::Type{T}, nt)</code></strong></p><ul><li>Normalizes raw inputs to canonical representation (e.g., radius proxies → numeric radii) while preserving domain semantics (e.g., uncertainty reset rules).</li><li>Returns a <strong>normalized</strong> <code>NamedTuple</code>.</li></ul></li><li><p><strong>Rule application</strong></p><ul><li><code>_rules(T)</code> is generated from traits; evaluates over the normalized <code>NamedTuple</code>.</li><li>Standard bundles are injected when traits are <code>true</code> (e.g., for radii: <code>Normalized</code>, <code>Finite</code>, <code>Nonneg</code>, <code>Less</code>).</li><li>Per‑type extras come from <code>extra_rules(T)</code>.</li></ul></li><li><p><strong><code>validate!(::Type{T}, args...; kwargs...)</code></strong></p><ul><li>Orchestrates the pipeline. Use this in all convenience constructors.</li></ul></li></ul><h3 id="Traits-(configuration-surface)"><a class="docs-heading-anchor" href="#Traits-(configuration-surface)">Traits (configuration surface)</a><a id="Traits-(configuration-surface)-1"></a><a class="docs-heading-anchor-permalink" href="#Traits-(configuration-surface)" title="Permalink"></a></h3><ul><li><code>has_radii(::Type{T})::Bool</code> — enables the radii rule bundle and raw acceptance checks.</li><li><code>has_temperature(::Type{T})::Bool</code> — enables finiteness check on <code>:temperature</code>.</li><li><code>required_fields(::Type{T})::NTuple</code> — positional keys.</li><li><code>keyword_fields(::Type{T})::NTuple</code> — keyword argument keys.</li><li><code>coercive_fields(::Type{T})::NTuple</code> — values that participate in type promotion and will be coerced (default: <code>required_fields ∪ keyword_fields</code>).</li><li><code>is_radius_input(::Type{T}, Val(:field), x)::Bool</code> — raw admissibility predicate for radii inputs; extend to allow proxies by field.</li><li><code>extra_rules(::Type{T})::NTuple{K,Rule}</code> — additional constraints appended to the generated bundle.</li></ul><p><strong>Import before extending</strong>:</p><pre><code class="language-julia hljs">import ..Validation: has_radii, has_temperature, required_fields, keyword_fields,
                     coercive_fields, is_radius_input, parse, extra_rules</code></pre><p>Failing to import will create shadow functions in your module; the engine will not see your methods.</p><hr/><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><p>Rules are small value types <code>struct &lt;: Rule</code> with an <code>_apply(::Rule, nt, ::Type{T})</code> method. All rule methods must:</p><ul><li>Read data from the <strong>normalized</strong> <code>NamedTuple</code> <code>nt</code>.</li><li>Throw <code>ArgumentError</code> for logical violations; <code>DomainError</code> for numerical domain violations (non‑finite).</li><li>Avoid allocations; use <code>@inline</code> where appropriate.</li></ul><h3 id="Standard-rules"><a class="docs-heading-anchor" href="#Standard-rules">Standard rules</a><a id="Standard-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-rules" title="Permalink"></a></h3><ul><li><code>Normalized(:field)</code> — field must be numeric post‑parse.</li><li><code>Finite(:field)</code> — <code>isfinite</code> must hold.</li><li><code>Nonneg(:field)</code> — value <code>≥ 0</code>.</li><li><code>Positive(:field)</code> — value <code>&gt; 0</code>.</li><li><code>IntegerField(:field)</code> — value <code>isa Integer</code>.</li><li><code>Less(:a,:b)</code> — strict ordering <code>a &lt; b</code>.</li><li><code>LessEq(:a,:b)</code> — non‑strict ordering <code>a ≤ b</code>.</li><li><code>IsA{M}(:field)</code> — type membership check.</li><li><code>OneOf(:field, set)</code> — membership in a finite set.</li></ul><h3 id="Custom-rule-pattern"><a class="docs-heading-anchor" href="#Custom-rule-pattern">Custom rule pattern</a><a id="Custom-rule-pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-rule-pattern" title="Permalink"></a></h3><pre><code class="language-julia hljs">struct InRange{T} &lt;: Validation.Rule
    name::Symbol; lo::T; hi::T
end

@inline function Validation._apply(r::InRange, nt, ::Type{T}) where {T}
    x = getfield(nt, r.name)
    (x isa Number &amp;&amp; !(x isa Complex)) || throw(ArgumentError(&quot;[$(String(nameof(T)))] $(r.name) must be real&quot;))
    (r.lo ≤ x ≤ r.hi) || throw(ArgumentError(&quot;[$(String(nameof(T)))] $(r.name) out of range $(r.lo):$(r.hi), got $(x)&quot;))
end</code></pre><p>Attach via <code>extra_rules(::Type{X}) = (InRange(:alpha, 0.0, 1.0), ...)</code>.</p><hr/><h2 id="Example-implementation-—-DataModel.Tubular"><a class="docs-heading-anchor" href="#Example-implementation-—-DataModel.Tubular">Example implementation — <code>DataModel.Tubular</code></a><a id="Example-implementation-—-DataModel.Tubular-1"></a><a class="docs-heading-anchor-permalink" href="#Example-implementation-—-DataModel.Tubular" title="Permalink"></a></h2><p><strong>Typed core</strong> (numbers only):</p><pre><code class="language-julia hljs">function Tubular(radius_in::T, radius_ext::T, material_props::Material{T}, temperature::T) where {T&lt;:REALSCALAR}</code></pre><p>Rationale: all proxy resolution must happen before reaching the typed core to avoid duplicate parsing and to keep type promotion deterministic.</p><p><strong>Trait configuration</strong>:</p><pre><code class="language-julia hljs">const _REQ_TUBULAR = (:radius_in, :radius_ext, :material_props,)
const _OPT_TUBULAR = (:temperature,)
const _DEFS_TUBULAR = (T₀,)

Validation.has_radii(::Type{Tubular}) = true
Validation.has_temperature(::Type{Tubular}) = true
Validation.required_fields(::Type{Tubular}) = _REQ_TUBULAR
Validation.keyword_fields(::Type{Tubular}) = _OPT_TUBULAR</code></pre><ul><li><code>has_radii = true</code> enables the radii bundle: <code>Normalized(:radius_in)</code>, <code>Normalized(:radius_ext)</code>, <code>Finite</code>, <code>Nonneg</code>, <code>Less(:radius_in,:radius_ext)</code>.</li><li><code>has_temperature = true</code> adds <code>Finite(:temperature)</code>.</li><li><code>required_fields</code> defines the mandatory positional fields.</li><li><code>keyword_fields</code> defines the optional fields that will receive default values.</li></ul><p><strong>Raw proxy acceptance</strong>:</p><pre><code class="language-julia hljs">Validation.is_radius_input(::Type{Tubular}, ::Val{:radius_in}, x::AbstractCablePart) = true
Validation.is_radius_input(::Type{Tubular}, ::Val{:radius_ext}, x::Thickness) = true
Validation.is_radius_input(::Type{Tubular}, ::Val{:radius_ext}, x::Diameter) = true</code></pre><p>The inner radius may take an existing cable part (its <code>radius_ext</code>); the outer radius may take a <code>Thickness</code> or <code>Diameter</code> wrapper.</p><p><strong>Extra rules</strong>:</p><pre><code class="language-julia hljs">Validation.extra_rules(::Type{Tubular}) = (IsA{Material}(:material_props),)</code></pre><p><strong>Parsing</strong>:</p><pre><code class="language-julia hljs">Validation.parse(::Type{Tubular}, nt) = begin
    rin, rex = _normalize_radii(Tubular, nt.radius_in, nt.radius_ext)
    (; nt..., radius_in=rin, radius_ext=rex)
end</code></pre><p><strong>Convenience constructor</strong>:</p><pre><code class="language-julia hljs">@construct Tubular _REQ_TUBULAR _OPT_TUBULAR _DEFS_TUBULAR</code></pre><p>This expands to a weakly‑typed method that calls <code>validate!</code>, promotes using <code>_promotion_T</code>, coerces via <code>_coerced_args</code>, and delegates to the numeric core.</p><p><strong>Failure modes intentionally trapped</strong>:</p><ul><li>Wrong arity, missing keys → <code>sanitize</code> via <code>required_fields</code>.</li><li>String/complex radii → <code>sanitize</code> via default <code>is_radius_input</code> (unless explicitly allowed).</li><li>Forgotten parsing after allowing proxies → caught by <code>Normalized</code> rules.</li><li>Geometry violations (<code>radius_in ≥ radius_ext</code>) → <code>Less(:radius_in,:radius_ext)</code>.</li></ul><hr/><h2 id="Template-for-a-new-component"><a class="docs-heading-anchor" href="#Template-for-a-new-component">Template for a new component</a><a id="Template-for-a-new-component-1"></a><a class="docs-heading-anchor-permalink" href="#Template-for-a-new-component" title="Permalink"></a></h2><pre><code class="language-julia hljs"># 1) Numeric core (numbers only)
function NewPart(a::T, b::T, material::Material{T}, temperature::T) where {T&lt;:REALSCALAR}
    # compute derived, then construct
end

# 2) Trait config
Validation.has_radii(::Type{NewPart}) = true
Validation.has_temperature(::Type{NewPart}) = true
Validation.required_fields(::Type{NewPart}) = (:a, :b, :material)
Validation.keyword_fields(::Type{NewPart})  = (:temperature,)

# 3) Raw acceptance (extend only what you intend to parse)
Validation.is_radius_input(::Type{NewPart}, ::Val{:radius_in},  x::AbstractCablePart) = true
Validation.is_radius_input(::Type{NewPart}, ::Val{:radius_ext}, x::Thickness)        = true

# 4) Extra rules
Validation.extra_rules(::Type{NewPart}) = (
    IsA{Material}(:material),
)

# 5) Parsing (proxy → numeric)
Validation.parse(::Type{NewPart}, nt) = begin
    a′, b′ = _normalize_radii(NewPart, nt.a, nt.b)
    (; nt..., a=a′, b=b′)
end

# 6) Convenience constructor — generated
@construct NewPart (:a, :b, :material) (:temperature,) (T₀,)</code></pre><hr/><h2 id="Extending-traits"><a class="docs-heading-anchor" href="#Extending-traits">Extending traits</a><a id="Extending-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-traits" title="Permalink"></a></h2><p>Traits are just methods. Add traits only when behavior toggles; avoid proliferation.</p><h3 id="New-feature-flags"><a class="docs-heading-anchor" href="#New-feature-flags">New feature flags</a><a id="New-feature-flags-1"></a><a class="docs-heading-anchor-permalink" href="#New-feature-flags" title="Permalink"></a></h3><p>Example: a shielding flag with its own bundle.</p><pre><code class="language-julia hljs">Validation.has_shield(::Type) = false
Validation.has_shield(::Type{SomeType}) = true</code></pre><p>Extend <code>_rules</code> inside <code>Validation</code> to splice the corresponding checks when <code>has_shield(T)</code> is true.</p><h3 id="Field‑specific-admissibility"><a class="docs-heading-anchor" href="#Field‑specific-admissibility">Field‑specific admissibility</a><a id="Field‑specific-admissibility-1"></a><a class="docs-heading-anchor-permalink" href="#Field‑specific-admissibility" title="Permalink"></a></h3><p>If only <code>:radius_in</code> should accept proxies, extend the field‑tagged predicate:</p><pre><code class="language-julia hljs">Validation.is_radius_input(::Type{X}, ::Val{:radius_in},  p::AbstractCablePart) = true
Validation.is_radius_input(::Type{X}, ::Val{:radius_ext}, ::AbstractCablePart)  = false</code></pre><hr/><h2 id="Testing-guidelines"><a class="docs-heading-anchor" href="#Testing-guidelines">Testing guidelines</a><a id="Testing-guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-guidelines" title="Permalink"></a></h2><ul><li>Test arity: <code>()</code>, <code>(1)</code>, <code>(1,2)</code> → <code>ArgumentError</code>.</li><li>Test raw type rejections: strings, complex numbers.</li><li>Test proxy acceptance: prior layer objects, <code>Thickness</code>, <code>Diameter</code> when allowed.</li><li>Test parse correctness: outputs numeric and respect uncertainty rules.</li><li>Test rule violations: negative radii, inverted radii, non‑finite values, invalid sets.</li><li>Test constructor round‑trip: convenience path and numeric core produce equivalent instances after coercion.</li></ul><h2 id="Usage-notes"><a class="docs-heading-anchor" href="#Usage-notes">Usage notes</a><a id="Usage-notes-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-notes" title="Permalink"></a></h2><ul><li>Keep all proxy handling in <code>parse</code>. Do not call normalizers in constructors.</li><li>Error messages must be terse and contextualized with the component type name.</li><li>Prefer tuple returns and <code>NamedTuple</code> updates to avoid allocations.</li><li>When adding rules, benchmark <code>_apply</code> implementations.</li></ul><hr/><h2 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation" href="#LineCableModels.Validation"><code>LineCableModels.Validation</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LineCableModels.Validation</code></pre><p>The <a href="#LineCableModels.Validation"><code>Validation</code></a> module implements a trait-driven, three-phase input checking pipeline for component constructors in <code>LineCableModels</code>. Inputs are first <em>sanitized</em> (arity and shape checks on raw arguments), then <em>parsed</em> (proxy values normalized to numeric radii), and finally validated by a generated set of rules.</p><p><strong>Overview</strong></p><ul><li>Centralized constructor input handling: <code>sanitize</code> → <code>parse</code> → rule application.</li><li>Trait hooks configure per‑type behavior (<code>has_radii</code>, <code>has_temperature</code>, <code>required_fields</code>, <code>keyword_fields</code>, <code>coercive_fields</code>, etc.).</li><li>Rules are small value objects (<code>Rule</code> subtypes) applied to a normalized <code>NamedTuple</code>.</li></ul><p><strong>Dependencies</strong></p><ul><li><code>Base</code></li><li><code>Core</code></li><li><code>LineCableModels.Commons</code></li></ul><p><strong>Exports</strong></p><ul><li><a href="#LineCableModels.Validation.Finite"><code>Finite</code></a></li><li><a href="#LineCableModels.Validation.IntegerField"><code>IntegerField</code></a></li><li><a href="#LineCableModels.Validation.IsA"><code>IsA</code></a></li><li><a href="#LineCableModels.Validation.Less"><code>Less</code></a></li><li><a href="#LineCableModels.Validation.LessEq"><code>LessEq</code></a></li><li><a href="#LineCableModels.Validation.Nonneg"><code>Nonneg</code></a></li><li><a href="#LineCableModels.Validation.Normalized"><code>Normalized</code></a></li><li><a href="#LineCableModels.Validation.OneOf"><code>OneOf</code></a></li><li><a href="#LineCableModels.Validation.Positive"><code>Positive</code></a></li><li><a href="#LineCableModels.Validation.coercive_fields-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>coercive_fields</code></a></li><li><a href="#LineCableModels.Validation.extra_rules-Tuple{Type}"><code>extra_rules</code></a></li><li><a href="#LineCableModels.Validation.has_radii-Tuple{Type}"><code>has_radii</code></a></li><li><a href="#LineCableModels.Validation.has_temperature-Tuple{Type}"><code>has_temperature</code></a></li><li><a href="../reference/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, LineCableModels.DataModel.AbstractCablePart}} where T"><code>is_radius_input</code></a></li><li><a href="#LineCableModels.Validation.keyword_defaults-Tuple{Type}"><code>keyword_defaults</code></a></li><li><a href="#LineCableModels.Validation.keyword_fields-Tuple{Type}"><code>keyword_fields</code></a></li><li><a href="#LineCableModels.Validation.parse-Tuple{Type, Any}"><code>parse</code></a></li><li><a href="#LineCableModels.Validation.required_fields-Tuple{Type}"><code>required_fields</code></a></li><li><a href="#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T"><code>sanitize</code></a></li><li><a href="#LineCableModels.Validation.validate!-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T"><code>validate!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.Finite" href="#LineCableModels.Validation.Finite"><code>LineCableModels.Validation.Finite</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Finite &lt;: LineCableModels.Validation.Rule</code></pre><p>Rule that enforces finiteness of a numeric field.</p><ul><li><code>name::Symbol</code>: Name of the field to check.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.IntegerField" href="#LineCableModels.Validation.IntegerField"><code>LineCableModels.Validation.IntegerField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IntegerField &lt;: LineCableModels.Validation.Rule</code></pre><p>Rule that enforces a field to be of an integer type.</p><ul><li><code>name::Symbol</code>: Name of the field to check.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.IsA" href="#LineCableModels.Validation.IsA"><code>LineCableModels.Validation.IsA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IsA{M} &lt;: LineCableModels.Validation.Rule</code></pre><p>Rule that enforces a field to be <code>isa M</code> for a specified type parameter <code>M</code>.</p><ul><li><code>name::Symbol</code>: Name of the field to check.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.Less" href="#LineCableModels.Validation.Less"><code>LineCableModels.Validation.Less</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Less &lt;: LineCableModels.Validation.Rule</code></pre><p>Rule that enforces a strict ordering constraint <code>a &lt; b</code> between two fields.</p><ul><li><p><code>a::Symbol</code>: Left‑hand field name.</p></li><li><p><code>b::Symbol</code>: Right‑hand field name.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.LessEq" href="#LineCableModels.Validation.LessEq"><code>LineCableModels.Validation.LessEq</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LessEq &lt;: LineCableModels.Validation.Rule</code></pre><p>Rule that enforces a non‑strict ordering constraint <code>a ≤ b</code> between two fields.</p><ul><li><p><code>a::Symbol</code>: Left‑hand field name.</p></li><li><p><code>b::Symbol</code>: Right‑hand field name.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.Nonneg" href="#LineCableModels.Validation.Nonneg"><code>LineCableModels.Validation.Nonneg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Nonneg &lt;: LineCableModels.Validation.Rule</code></pre><p>Rule that enforces a field to be non‑negative (<code>≥ 0</code>).</p><ul><li><code>name::Symbol</code>: Name of the field to check.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.Normalized" href="#LineCableModels.Validation.Normalized"><code>LineCableModels.Validation.Normalized</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Normalized &lt;: LineCableModels.Validation.Rule</code></pre><p>Rule that enforces that a field has already been normalized to a numeric value during parsing. Intended to guard that <code>parse</code> has executed and removed proxies.</p><ul><li><code>name::Symbol</code>: Name of the field to check.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.OneOf" href="#LineCableModels.Validation.OneOf"><code>LineCableModels.Validation.OneOf</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct OneOf{S} &lt;: LineCableModels.Validation.Rule</code></pre><p>Rule that enforces a field to be <code>in</code> the set <code>S</code>.</p><ul><li><p><code>name::Symbol</code></p></li><li><p><code>set::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.Positive" href="#LineCableModels.Validation.Positive"><code>LineCableModels.Validation.Positive</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Positive &lt;: LineCableModels.Validation.Rule</code></pre><p>Rule that enforces a field to be strictly positive (<code>&gt; 0</code>).</p><ul><li><code>name::Symbol</code>: Name of the field to check.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.Rule" href="#LineCableModels.Validation.Rule"><code>LineCableModels.Validation.Rule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Rule</code></pre><p>Base abstract type for validation rules. All concrete rule types must subtype <a href="#LineCableModels.Validation.Rule"><code>Rule</code></a> and provide an <code>_apply(::Rule, nt, ::Type{T})</code> method that checks a field in the normalized <code>NamedTuple</code> <code>nt</code> for the component type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._apply-Union{Tuple{M}, Tuple{T}, Tuple{LineCableModels.Validation.IsA{M}, Any, Type{T}}} where {T, M}" href="#LineCableModels.Validation._apply-Union{Tuple{M}, Tuple{T}, Tuple{LineCableModels.Validation.IsA{M}, Any, Type{T}}} where {T, M}"><code>LineCableModels.Validation._apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_apply(
    r::LineCableModels.Validation.IsA{M},
    nt,
    _::Type{T}
) -&gt; Bool
</code></pre><p>Applies <a href="#LineCableModels.Validation.IsA"><code>IsA{M}</code></a> to ensure a field is of type <code>M</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: Rule instance parameterized by <code>M</code> [dimensionless].</li><li><code>nt</code>: Normalized <code>NamedTuple</code> [dimensionless].</li><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Finite, Any, Type{T}}} where T" href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Finite, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_apply(
    r::LineCableModels.Validation.Finite,
    nt,
    _::Type{T}
) -&gt; Any
</code></pre><p>Applies <a href="#LineCableModels.Validation.Finite"><code>Finite</code></a> to ensure the target field is a finite real number.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: Rule instance [dimensionless].</li><li><code>nt</code>: Normalized <code>NamedTuple</code> of inputs [dimensionless].</li><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.IntegerField, Any, Type{T}}} where T" href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.IntegerField, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_apply(
    r::LineCableModels.Validation.IntegerField,
    nt,
    _::Type{T}
) -&gt; Bool
</code></pre><p>Applies <a href="#LineCableModels.Validation.IntegerField"><code>IntegerField</code></a> to ensure the target field is an <code>Integer</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: Rule instance [dimensionless].</li><li><code>nt</code>: Normalized <code>NamedTuple</code> of inputs [dimensionless].</li><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Less, Any, Type{T}}} where T" href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Less, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_apply(
    r::LineCableModels.Validation.Less,
    nt,
    _::Type{T}
) -&gt; Any
</code></pre><p>Applies <a href="#LineCableModels.Validation.Less"><code>Less</code></a> to ensure <code>nt[a] &lt; nt[b]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: Rule instance with fields <code>a</code> and <code>b</code> [dimensionless].</li><li><code>nt</code>: Normalized <code>NamedTuple</code> [dimensionless].</li><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.LessEq, Any, Type{T}}} where T" href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.LessEq, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_apply(
    r::LineCableModels.Validation.LessEq,
    nt,
    _::Type{T}
) -&gt; Any
</code></pre><p>Applies <a href="#LineCableModels.Validation.LessEq"><code>LessEq</code></a> to ensure <code>nt[a] ≤ nt[b]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: Rule instance with fields <code>a</code> and <code>b</code> [dimensionless].</li><li><code>nt</code>: Normalized <code>NamedTuple</code> [dimensionless].</li><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Nonneg, Any, Type{T}}} where T" href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Nonneg, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_apply(
    r::LineCableModels.Validation.Nonneg,
    nt,
    _::Type{T}
) -&gt; Any
</code></pre><p>Applies <a href="#LineCableModels.Validation.Nonneg"><code>Nonneg</code></a> to ensure the target field is <code>≥ 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: Rule instance [dimensionless].</li><li><code>nt</code>: Normalized <code>NamedTuple</code> of inputs [dimensionless].</li><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Normalized, Any, Type{T}}} where T" href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Normalized, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_apply(
    r::LineCableModels.Validation.Normalized,
    nt,
    _::Type{T}
) -&gt; Bool
</code></pre><p>Applies <a href="#LineCableModels.Validation.Normalized"><code>Normalized</code></a> to ensure the field has been converted to a numeric value during parsing.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: Rule instance [dimensionless].</li><li><code>nt</code>: Normalized <code>NamedTuple</code> [dimensionless].</li><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Positive, Any, Type{T}}} where T" href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Positive, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_apply(
    r::LineCableModels.Validation.Positive,
    nt,
    _::Type{T}
) -&gt; Any
</code></pre><p>Applies <a href="#LineCableModels.Validation.Positive"><code>Positive</code></a> to ensure the target field is <code>&gt; 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: Rule instance [dimensionless].</li><li><code>nt</code>: Normalized <code>NamedTuple</code> of inputs [dimensionless].</li><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{S}, Tuple{LineCableModels.Validation.OneOf{S}, Any, Type{T}}} where {S, T}" href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{S}, Tuple{LineCableModels.Validation.OneOf{S}, Any, Type{T}}} where {S, T}"><code>LineCableModels.Validation._apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_apply(
    r::LineCableModels.Validation.OneOf{S},
    nt,
    _::Type{T}
) -&gt; Any
</code></pre><p>Applies <a href="#LineCableModels.Validation.OneOf"><code>OneOf</code></a> to ensure the target field is contained in a specified set.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: Rule instance with fields <code>name</code> and <code>set</code> [dimensionless].</li><li><code>nt</code>: Normalized <code>NamedTuple</code> of inputs [dimensionless].</li><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._ensure_real-Union{Tuple{T}, Tuple{Symbol, Any, Type{T}}} where T" href="#LineCableModels.Validation._ensure_real-Union{Tuple{T}, Tuple{Symbol, Any, Type{T}}} where T"><code>LineCableModels.Validation._ensure_real</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_ensure_real(field::Symbol, x, _::Type{T})
</code></pre><p>Asserts that <code>x</code> is a real (non‑complex) number. Used by rule implementations before performing numeric comparisons.</p><p><strong>Arguments</strong></p><ul><li><code>field</code>: Field name used in diagnostics [dimensionless].</li><li><code>x</code>: Value to check [dimensionless].</li><li><code>::Type{T}</code>: Component type for contextualized messages [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. Throws on failure.</li></ul><p><strong>Errors</strong></p><ul><li><code>ArgumentError</code> if <code>x</code> is not <code>isa Number</code> or is a <code>Complex</code> value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">_ensure_real(:radius_in, 0.01, SomeType)  # ok</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._kwdefaults_nt-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#LineCableModels.Validation._kwdefaults_nt-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>LineCableModels.Validation._kwdefaults_nt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_kwdefaults_nt(_::Type{T}) -&gt; NamedTuple
</code></pre><p>Internal helper that canonicalizes <code>keyword_defaults(T)</code> into a <code>NamedTuple</code> keyed by <code>keyword_fields(T)</code>. Accepts:</p><ul><li><code>()</code> → returns an empty <code>NamedTuple()</code>.</li><li><code>NamedTuple</code> → returned unchanged.</li><li><code>Tuple</code> → zipped <strong>by position</strong> with <code>keyword_fields(T)</code>; lengths must match.</li></ul><p>This function does <strong>not</strong> merge user-provided keywords; callers should perform <code>merge(_kwdefaults_nt(T), kwargs)</code> so that user values take precedence.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code> mapping optional keyword field names to their default values.</li></ul><p><strong>Errors</strong></p><ul><li>If <code>keyword_defaults(T)</code> returns a <code>Tuple</code> whose length differs from <code>length(keyword_fields(T))</code>.</li><li>If <code>keyword_defaults(T)</code> returns a value that is neither <code>()</code> nor a <code>NamedTuple</code> nor a <code>Tuple</code>.</li></ul><p><strong>Examples</strong></p><p>```julia</p><p><strong>Suppose:</strong></p><p><strong>keyword<em>fields(::Type{X})   = (:temperature, :lay</em>direction)</strong></p><p><strong>keyword_defaults(::Type{X}) = (T₀, 1)</strong></p><p><em>kwdefaults</em>nt(X)  # =&gt; (temperature = T₀, lay_direction = 1)</p><p><strong>If defaults are already a NamedTuple:</strong></p><p><strong>keyword_defaults(::Type{Y}) = (temperature = 25.0,)</strong></p><p><em>kwdefaults</em>nt(Y)  # =&gt; (temperature = 25.0,) ````</p><p><strong>See also</strong></p><ul><li><a href="#LineCableModels.Validation.keyword_fields-Tuple{Type}"><code>keyword_fields</code></a></li><li><a href="#LineCableModels.Validation.keyword_defaults-Tuple{Type}"><code>keyword_defaults</code></a></li><li><a href="#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T"><code>sanitize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L637">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._repr-Tuple{Any}" href="#LineCableModels.Validation._repr-Tuple{Any}"><code>LineCableModels.Validation._repr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_repr(x) -&gt; String
</code></pre><p>Returns a compact textual representation of <code>x</code> for error messages.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to represent [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code> with a compact <code>repr</code> [dimensionless].</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">s = _repr(:field)  # &quot;:field&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._rules-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#LineCableModels.Validation._rules-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>LineCableModels.Validation._rules</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_rules(_::Type{T}) -&gt; Tuple
</code></pre><p>Generates (at compile time, via a <code>@generated</code> function) the tuple of rules to apply for component type <code>T</code>. The result concatenates standard bundles driven by traits and any rules returned by <code>extra_rules(T)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of <a href="#LineCableModels.Validation.Rule"><code>Rule</code></a> instances to apply in order.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation._typename-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#LineCableModels.Validation._typename-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>LineCableModels.Validation._typename</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_typename(_::Type{T}) -&gt; String
</code></pre><p>Returns the simple (unqualified) name of type <code>T</code> as a <code>String</code>. Utility for constructing diagnostic messages.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Type whose name is requested [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code> with the type name [dimensionless].</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">name = _typename(Float64)  # &quot;Float64&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.coercive_fields-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#LineCableModels.Validation.coercive_fields-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>LineCableModels.Validation.coercive_fields</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coercive_fields(_::Type{T}) -&gt; NTuple{6, Symbol}
</code></pre><p>Trait hook listing <strong>coercive</strong> fields: values that participate in numeric promotion and will be converted to the promoted type by the convenience constructor. Defaults to all fields (<code>required_fields ∪ keyword_fields</code>). Types may override to exclude integers or categorical fields.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of field names that are coerced.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L517">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.extra_rules-Tuple{Type}" href="#LineCableModels.Validation.extra_rules-Tuple{Type}"><code>LineCableModels.Validation.extra_rules</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extra_rules(
    _::Type
) -&gt; Tuple{LineCableModels.Validation.IsA{Material}}
</code></pre><p>Trait hook providing additional rule instances for a component type. Used to append per‑type constraints after the standard bundles.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of <a href="#LineCableModels.Validation.Rule"><code>Rule</code></a> instances.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.has_radii-Tuple{Type}" href="#LineCableModels.Validation.has_radii-Tuple{Type}"><code>LineCableModels.Validation.has_radii</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_radii(_::Type) -&gt; Bool
</code></pre><p>Trait hook enabling the annular radii rule bundle on fields <code>:radius_in</code> and <code>:radius_ext</code> (normalized numbers required, finiteness, non‑negativity, and the ordering constraint <code>:radius_in</code> &lt; <code>:radius_ext</code>). It does <strong>not</strong> indicate the mere existence of radii; it opts in to the annular/coaxial shell geometry checks.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code> flag.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Validation.has_radii(Tubular)  # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L414">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.has_temperature-Tuple{Type}" href="#LineCableModels.Validation.has_temperature-Tuple{Type}"><code>LineCableModels.Validation.has_temperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_temperature(_::Type) -&gt; Bool
</code></pre><p>Trait hook indicating whether a component type uses a <code>:temperature</code> field subject to finiteness checks.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code> flag.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.is_radius_input-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Val{F}, Any}} where {T, F}" href="#LineCableModels.Validation.is_radius_input-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Val{F}, Any}} where {T, F}"><code>LineCableModels.Validation.is_radius_input</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_radius_input(_::Type{T}, _::Val{F}, x) -&gt; Bool
</code></pre><p>Field‑aware acceptance predicate used by <code>sanitize</code> to distinguish inner vs. outer radius policies. The default forwards to <a href="@ref"><code>is_radius_input(::Type{T}, x)</code></a> when no field‑specific method is defined.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li><li><code>::Val{F}</code>: Field tag; typically <code>Val(:radius_in)</code> or <code>Val(:radius_ext)</code> [dimensionless].</li><li><code>x</code>: Candidate value [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code> indicating acceptance.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Validation.is_radius_input(Tubular, Val(:radius_in), 0.01)   # true
Validation.is_radius_input(Tubular, Val(:radius_ext), 0.01)  # true</code></pre><p><strong>See also</strong></p><ul><li><a href="#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T"><code>sanitize</code></a></li><li><a href="@ref"><code>is_radius_input(::Type{T}, x)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L559">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>LineCableModels.Validation.is_radius_input</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_radius_input(_::Type{T}, x) -&gt; Bool
</code></pre><p>Trait predicate that defines admissible <em>raw</em> radius inputs for a component type during <code>sanitize</code>. The default accepts real, non‑complex numbers only. Component code may extend this to allow proxies (e.g., <code>AbstractCablePart</code>, <code>Thickness</code>, <code>Diameter</code>).</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li><li><code>x</code>: Candidate value [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code> indicating acceptance.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Validation.is_radius_input(Tubular, 0.01)  # true by default
Validation.is_radius_input(Tubular, 1 + 0im)  # false (complex)</code></pre><p><strong>See also</strong></p><ul><li><a href="#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T"><code>sanitize</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, Number}} where T" href="#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, Number}} where T"><code>LineCableModels.Validation.is_radius_input</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_radius_input(
    _::Type{T},
    _::Val{:radius_ext},
    x::Number
) -&gt; Bool
</code></pre><p>Default policy for <strong>outer</strong> radius raw inputs (annular shells): accept real numbers. Proxies are rejected at this stage to prevent zero‑thickness stacking.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li><li><code>::Val{:radius_ext}</code>: Field tag for the outer radius [dimensionless].</li><li><code>x::Number</code>: Candidate value [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code> indicating acceptance (<code>true</code> for real, non‑complex numbers).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Validation.is_radius_input(Tubular, Val(:radius_ext), 0.02)  # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L613">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_in}, Number}} where T" href="#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_in}, Number}} where T"><code>LineCableModels.Validation.is_radius_input</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_radius_input(
    _::Type{T},
    _::Val{:radius_in},
    x::Number
) -&gt; Bool
</code></pre><p>Default policy for <strong>inner</strong> radius raw inputs: accept real numbers.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li><li><code>::Val{:radius_in}</code>: Field tag for the inner radius [dimensionless].</li><li><code>x::Number</code>: Candidate value [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code> indicating acceptance (<code>true</code> for real, non‑complex numbers).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Validation.is_radius_input(Tubular, Val(:radius_in), 0.0)   # true
Validation.is_radius_input(Tubular, Val(:radius_in), 1+0im) # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L588">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.keyword_defaults-Tuple{Type}" href="#LineCableModels.Validation.keyword_defaults-Tuple{Type}"><code>LineCableModels.Validation.keyword_defaults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">keyword_defaults(_::Type) -&gt; Tuple{Float64}
</code></pre><p>Trait hook supplying <strong>default values</strong> for optional keyword fields.</p><p>Return either:</p><ul><li>a <code>NamedTuple</code> mapping defaults by name (e.g., <code>(temperature = T₀,)</code>), or</li><li>a plain <code>Tuple</code> of defaults aligned with <code>keyword_fields(T)</code> (same order + length).</li></ul><p>Defaults are applied in <code>sanitize</code> <strong>after</strong> positional→named merge and before rule application. User-provided keywords always override these defaults.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code> or <code>Tuple</code> with default keyword values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.keyword_fields-Tuple{Type}" href="#LineCableModels.Validation.keyword_fields-Tuple{Type}"><code>LineCableModels.Validation.keyword_fields</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">keyword_fields(_::Type) -&gt; Tuple{Symbol}
</code></pre><p>Trait hook listing optional keyword fields considered by <code>sanitize</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of optional keyword field names.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.parse-Tuple{Type, Any}" href="#LineCableModels.Validation.parse-Tuple{Type, Any}"><code>LineCableModels.Validation.parse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parse(_::Type, nt) -&gt; NamedTuple
</code></pre><p>Parses and normalizes raw inputs produced by <a href="#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T"><code>sanitize</code></a> into the canonical form expected by rules. Default is identity; component code overrides this to resolve proxy radii to numeric values while preserving uncertainty semantics.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li><li><code>nt::NamedTuple</code>: Raw inputs from <code>sanitize</code> [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code> with normalized fields (e.g., numeric <code>:radius_in</code>, <code>:radius_ext</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L769">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.required_fields-Tuple{Type}" href="#LineCableModels.Validation.required_fields-Tuple{Type}"><code>LineCableModels.Validation.required_fields</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">required_fields(_::Type) -&gt; Tuple{Symbol, Symbol, Symbol}
</code></pre><p>Trait hook listing required fields that must be present after positional→named merge in <code>sanitize</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of required field names.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L465">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T" href="#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T"><code>LineCableModels.Validation.sanitize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sanitize(
    _::Type{T},
    args::Tuple,
    kwargs::NamedTuple
) -&gt; NamedTuple
</code></pre><p>Performs raw input checks and shapes the input into a <code>NamedTuple</code> without parsing proxies. Responsibilities: arity validation, positional→named mapping, required field presence, and raw acceptance of radius inputs via <code>is_radius_input</code> when <code>has_radii(T)</code> is true.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li><li><code>args::Tuple</code>: Positional arguments as received by the convenience constructor [dimensionless].</li><li><code>kwargs::NamedTuple</code>: Keyword arguments [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code> with raw (unparsed) fields.</li></ul><p><strong>Errors</strong></p><ul><li><code>ArgumentError</code> on invalid arity, excess positional arguments, missing required fields, or rejected raw radius inputs.</li></ul><p><strong>Notes</strong></p><p>Required arguments must be positional; optional arguments must be passed as keywords. Positional arity must equal <code>length(required_fields(T))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">nt = sanitize(Tubular, (0.01, 0.02, material), (; temperature = 20.0,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LineCableModels.Validation.validate!-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T" href="#LineCableModels.Validation.validate!-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T"><code>LineCableModels.Validation.validate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">validate!(::Type{T}, args...; kwargs...) -&gt; Any
</code></pre><p>Runs the full validation pipeline for a component type: <code>sanitize</code> (arity and raw checks), <code>parse</code> (proxy normalization), then application of the generated rule set. Intended to be called from convenience constructors.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Component type [dimensionless].</li><li><code>args...</code>: Positional arguments [dimensionless].</li><li><code>kwargs...</code>: Keyword arguments [dimensionless].</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code> containing normalized fields ready for construction.</li></ul><p><strong>Errors</strong></p><ul><li><code>ArgumentError</code> from <code>sanitize</code> or rule checks; <code>DomainError</code> for finiteness violations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">nt = validate!(Tubular, 0.01, 0.02, material; temperature = 20.0)
# use nt.radius_in, nt.radius_ext, nt.temperature thereafter</code></pre><p><strong>See also</strong></p><ul><li><a href="#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T"><code>sanitize</code></a></li><li><a href="#LineCableModels.Validation.parse-Tuple{Type, Any}"><code>parse</code></a></li><li><a href="#LineCableModels.Validation.coercive_fields-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>coercive_fields</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/LineCableModels.jl/blob/3fa2c01c41bbbdb41200f54cadecbca03422b36a/src/Validation.jl#L809">source</a></section></article><hr/><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LineCableModels.Validation"><code>LineCableModels.Validation</code></a></li><li><a href="#LineCableModels.Validation.Finite"><code>LineCableModels.Validation.Finite</code></a></li><li><a href="#LineCableModels.Validation.IntegerField"><code>LineCableModels.Validation.IntegerField</code></a></li><li><a href="#LineCableModels.Validation.IsA"><code>LineCableModels.Validation.IsA</code></a></li><li><a href="#LineCableModels.Validation.Less"><code>LineCableModels.Validation.Less</code></a></li><li><a href="#LineCableModels.Validation.LessEq"><code>LineCableModels.Validation.LessEq</code></a></li><li><a href="#LineCableModels.Validation.Nonneg"><code>LineCableModels.Validation.Nonneg</code></a></li><li><a href="#LineCableModels.Validation.Normalized"><code>LineCableModels.Validation.Normalized</code></a></li><li><a href="#LineCableModels.Validation.OneOf"><code>LineCableModels.Validation.OneOf</code></a></li><li><a href="#LineCableModels.Validation.Positive"><code>LineCableModels.Validation.Positive</code></a></li><li><a href="#LineCableModels.Validation.Rule"><code>LineCableModels.Validation.Rule</code></a></li><li><a href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.IntegerField, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a></li><li><a href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Finite, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a></li><li><a href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Positive, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a></li><li><a href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Nonneg, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a></li><li><a href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Normalized, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a></li><li><a href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.LessEq, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a></li><li><a href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{S}, Tuple{LineCableModels.Validation.OneOf{S}, Any, Type{T}}} where {S, T}"><code>LineCableModels.Validation._apply</code></a></li><li><a href="#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Less, Any, Type{T}}} where T"><code>LineCableModels.Validation._apply</code></a></li><li><a href="#LineCableModels.Validation._apply-Union{Tuple{M}, Tuple{T}, Tuple{LineCableModels.Validation.IsA{M}, Any, Type{T}}} where {T, M}"><code>LineCableModels.Validation._apply</code></a></li><li><a href="#LineCableModels.Validation._ensure_real-Union{Tuple{T}, Tuple{Symbol, Any, Type{T}}} where T"><code>LineCableModels.Validation._ensure_real</code></a></li><li><a href="#LineCableModels.Validation._kwdefaults_nt-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>LineCableModels.Validation._kwdefaults_nt</code></a></li><li><a href="#LineCableModels.Validation._repr-Tuple{Any}"><code>LineCableModels.Validation._repr</code></a></li><li><a href="#LineCableModels.Validation._rules-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>LineCableModels.Validation._rules</code></a></li><li><a href="#LineCableModels.Validation._typename-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>LineCableModels.Validation._typename</code></a></li><li><a href="#LineCableModels.Validation.coercive_fields-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>LineCableModels.Validation.coercive_fields</code></a></li><li><a href="#LineCableModels.Validation.extra_rules-Tuple{Type}"><code>LineCableModels.Validation.extra_rules</code></a></li><li><a href="#LineCableModels.Validation.has_radii-Tuple{Type}"><code>LineCableModels.Validation.has_radii</code></a></li><li><a href="#LineCableModels.Validation.has_temperature-Tuple{Type}"><code>LineCableModels.Validation.has_temperature</code></a></li><li><a href="#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, Number}} where T"><code>LineCableModels.Validation.is_radius_input</code></a></li><li><a href="#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>LineCableModels.Validation.is_radius_input</code></a></li><li><a href="#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_in}, Number}} where T"><code>LineCableModels.Validation.is_radius_input</code></a></li><li><a href="#LineCableModels.Validation.is_radius_input-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Val{F}, Any}} where {T, F}"><code>LineCableModels.Validation.is_radius_input</code></a></li><li><a href="#LineCableModels.Validation.keyword_defaults-Tuple{Type}"><code>LineCableModels.Validation.keyword_defaults</code></a></li><li><a href="#LineCableModels.Validation.keyword_fields-Tuple{Type}"><code>LineCableModels.Validation.keyword_fields</code></a></li><li><a href="#LineCableModels.Validation.parse-Tuple{Type, Any}"><code>LineCableModels.Validation.parse</code></a></li><li><a href="#LineCableModels.Validation.required_fields-Tuple{Type}"><code>LineCableModels.Validation.required_fields</code></a></li><li><a href="#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T"><code>LineCableModels.Validation.sanitize</code></a></li><li><a href="#LineCableModels.Validation.validate!-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T"><code>LineCableModels.Validation.validate!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference/">« API reference</a><a class="docs-footer-nextpage" href="../docstrings/">Docstrings »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/Electa-Git/LineCableModels.jl">LineCableModels.jl</a> v0.1.1-DEV supported by the Etch Competence Hub of EnergyVille, financed by the Flemish Government.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 4 September 2025 19:21">Thursday 4 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
