var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Contents","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Contents","title":"Contents","text":"In this section you will find step-by-step guides to help you get started with the LineCableModels.jl package. These guides are designed to be straightforward and practical, covering the most common use cases and features. ","category":"page"},{"location":"tutorials/","page":"Contents","title":"Contents","text":"Pages = Main.tutorial_pages\nDepth = 1","category":"page"},{"location":"TODO/#TODO-for-LineCableModels.jl","page":"TODO","title":"TODO for LineCableModels.jl","text":"","category":"section"},{"location":"TODO/","page":"TODO","title":"TODO","text":"This is a living document intended to track scientific development priorities and research directions for new features, methods and solutions to be included in the package.","category":"page"},{"location":"TODO/","page":"TODO","title":"TODO","text":"For bugs, features and implementation taks, the Issues page is used.","category":"page"},{"location":"TODO/#Wishlist","page":"TODO","title":"Wishlist","text":"","category":"section"},{"location":"TODO/","page":"TODO","title":"TODO","text":"[ ] Pipe-type cables and MoM-SO implementation.","category":"page"},{"location":"TODO/#In-progress","page":"TODO","title":"In progress","text":"","category":"section"},{"location":"TODO/","page":"TODO","title":"TODO","text":"[ ] Implementation of frequency-dependent soil properties.\n[ ] Development of novel formulations for cables composed of N concentrical layers, allowing for accurate representations of semiconductor materials.\n[ ] Implementation of an interface to run finite element simulations using Onelab.","category":"page"},{"location":"TODO/#Done","page":"TODO","title":"Done ✓","text":"","category":"section"},{"location":"TODO/","page":"TODO","title":"TODO","text":"[x] Object-oriented data model for cables, conductors, insulations and materials.","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"The following docstring standards are generally adopted across the codebase.","category":"page"},{"location":"docstrings/#General-principles","page":"Docstrings","title":"General principles","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Placement: Docstrings must immediately precede the code entity (struct, function, module, constant) they describe.\nDelimiter: Use triple double quotes (\"\"\"Docstring content\"\"\") for all docstrings, except for individual struct field documentation.\nConciseness: Avoid redundancy. Information should be presented clearly and concisely in the appropriate section.\nTone: Use formal, precise scientific language suitable for technical documentation. Avoid contractions, colloquialisms, and ambiguous phrasing.","category":"page"},{"location":"docstrings/#Physical-unit-formatting","page":"Docstrings","title":"Physical unit formatting","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"All variables corresponding to physical quantities must be annotated with their SI units and according to the following rules:","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Mandatory units: ALL arguments, return values, struct fields, and constants representing physical quantities MUST have their SI units specified.\nDimensionless quantities: Physical quantities that are dimensionless MUST be explicitly marked as \\\\[dimensionless\\\\].\nNon-physical quantities: Do not add unit annotations to arguments, variables, or fields that do not represent physical quantities (e.g., counters, flags, indices).\nStandard format: Units MUST be enclosed in double-backslash escaped square brackets: \\\\[unit\\\\].\nCorrect: \\\\[m\\\\], \\\\[Hz\\\\], \\\\[Ω\\\\], \\\\[H/m\\\\], \\\\[dimensionless\\\\]\nIncorrect: [m], \\[m], m (as a standalone unit identifier)\nException for example comments: Inside `julia code blocks within the # Examples section, use regular (non-escaped) square brackets for units within comments.\nCorrect: julia result = calculation(10.0) # Output in [m]\nIncorrect: julia result = calculation(10.0) # Output in \\\\[m\\\\]\nCommon units: Use standard SI abbreviations (e.g., m, s, kg, A, K, mol, cd, Hz, N, Pa, J, W, C, V, F, Ω, S, T, H, lm, lx, Bq, Gy, Sv, °C). Use the Unicode middle dot · for multiplication where appropriate (e.g., \\\\[Ω·m\\\\]).","category":"page"},{"location":"docstrings/#Mathematical-formulation-formatting","page":"Docstrings","title":"Mathematical formulation formatting","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Requirement: Mathematical formulas rendered using LaTeX are MANDATORY only for functions/methods whose names start with the prefix calc_.\nLocation: For calc_ functions, the LaTeX formula MUST be placed within a math ... block inside the # Notes section.\nForbidden: Do NOT include math blocks or LaTeX formulations for any functions or methods not prefixed with calc_.\nLaTeX escaping: Within documentation text AND inside math blocks, all LaTeX commands (like \\frac, \\mu) MUST have their backslashes escaped (\\\\).\nCorrect: \\\\mu_r, math \\\\frac{a}{b}\nIncorrect: \\mu_r, math \\frac{a}{b}","category":"page"},{"location":"docstrings/#Documentation-templates","page":"Docstrings","title":"Documentation templates","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"The subsections below contain templates for different types of code elements.","category":"page"},{"location":"docstrings/#Structs","page":"Docstrings","title":"Structs","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Main docstring: Use $(TYPEDEF) for the signature and $(TYPEDFIELDS) to list the fields automatically. Provide a concise description of the struct purpose.\n  ```julia\n  \"\"\"\n  $(TYPEDEF)\n\n  Represents a physical entity with specific properties...\n\n  $(TYPEDFIELDS)\n  \"\"\"\n  struct StructName\n      # Field definitions follow\n  end\n  ```\nField documentation:\nPlace directly above each field definition.\nUse single-line double quotes: \"Description with units \\\\[unit\\\\] or \\\\[dimensionless\\\\] if applicable.\"\nDo NOT use \"\"\" \"\"\" block quotes or inline comments (#) for documenting struct fields.","category":"page"},{"location":"docstrings/#Constructors-(inside-or-outside-structs)","page":"Docstrings","title":"Constructors (inside or outside structs)","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"ALL constructors MUST be documented using the @doc macro placed immediately before the function keyword or the compact assignment form (TypeName(...) = ...). This applies even to default constructors if explicitly defined.\nFormat: Use $(TYPEDSIGNATURES). Include standard sections (Arguments, Returns, Examples).\n  ````julia\n  @doc \"\"\"\n  $(TYPEDSIGNATURES)\n\n  Constructs a [`StructName`](@ref) instance.\n\n  # Arguments\n\n  - `arg_name`: Description including units `\\\\[unit\\\\]` if physical.\n\n  # Returns\n\n  - A [`StructName`](@ref) object. [Optionally add details about initialization].\n\n  # Examples\n\n  ```julia\n  instance = $(FUNCTIONNAME)(...) # Provide meaningful example values\n  ```\n\n  \"\"\"\n  function StructName(...)\n      # Implementation\n  end\n  ````","category":"page"},{"location":"docstrings/#Functions-/-methods","page":"Docstrings","title":"Functions / methods","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Format: Start with $(TYPEDSIGNATURES). Follow the section order described.\n  ````julia\n  \"\"\"\n  $(TYPEDSIGNATURES)\n\n  Concise description of the function's purpose.\n\n  # Arguments\n\n  - `arg1`: Description, units `\\\\[unit\\\\]` if physical. Specify `Default: value` if applicable.\n  - `arg2`: Description, `\\\\[dimensionless\\\\]` if physical and dimensionless.\n\n  # Returns\n\n  - Description of the return value, including units `\\\\[unit\\\\]` if physical. Document multiple return values individually if using tuples.\n\n  # Notes  (OPTIONAL - MANDATORY ONLY for `calc_` functions for the formula)\n\n  [For `calc_` functions: Explanation and formula]\n  ```math\n  \\\\LaTeX... \\\\escaped... \\\\formula...\n  ```\n\n  # Errors \n\n  - Describes potential errors or exceptions thrown.\n\n  # Examples\n\n  ```julia\n  result = $(FUNCTIONNAME)(...) # Use representative values. Add expected output comment.\n  # Example: result = $(FUNCTIONNAME)(0.02, 0.01, 1.0) # Expected output: ~0.0135 [m]\n  ```\n\n  # See also \n\n  - [`related_package_function`](@ref)\n  \"\"\"\n  function function_name(...)\n      # Implementation\n  end\n  ````\nSection order:\nDescription (no heading)\n# Arguments\n# Returns\n# Notes (Only if needed; mandatory for calc_ functions)\n# Errors (Only if needed)\n# Examples\n# See also (Only if needed)\nSpacing: Ensure exactly one blank line separates the description from # Arguments and precedes every subsequent section heading.\nExamples: Use the $(FUNCTIONNAME) macro instead of hardcoding the function name. Use meaningful, realistic input values. Include expected output or behavior in a comment, using non-escaped brackets for units ([unit]).\nSee also: Only link to other functions within this package using [function_name](@ref). Do not link to Base Julia functions or functions from external packages unless absolutely necessary for context. Only include if the linked function provides relevant context or alternatives.","category":"page"},{"location":"docstrings/#Modules","page":"Docstrings","title":"Modules","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Format: The first line must be the module name indented by four spaces. Use $(IMPORTS) and $(EXPORTS) literals.\n  ````julia\n  \"\"\"\n      ModuleName\n\n  Brief description of the module purpose within the broader package (e.g., for [`Package.jl`](index.md)).\n\n  # Overview\n\n  - Bullet points describing key capabilities or features provided by the module.\n\n  # Dependencies\n\n  $(IMPORTS)\n\n  # Exports\n\n  $(EXPORTS)\n  \"\"\"\n  module ModuleName\n      # Contents\n  end\n  ````","category":"page"},{"location":"docstrings/#Constants","page":"Docstrings","title":"Constants","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Format: Use a single-line docstring with double quotes (\"...\"). Include a brief description, the symbol of the constant if standard (e.g., μ₀), its value, and its units using the \\\\[unit\\\\] format.\n  ```julia\n  \"Magnetic constant (vacuum permeability), μ₀ = 4π * 1e-7 \\\\[H/m\\\\]].\"\n  const μ₀ = 4π * 1e-7\n  ```","category":"page"},{"location":"docstrings/#Common-mistakes-to-avoid","page":"Docstrings","title":"Common mistakes to avoid","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Double-check the docstrings to avoid these common errors:","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Missing @doc for constructors: ALL constructors require the @doc macro before their definition.\nIncorrect struct field docstrings: Use single-line \"...\" above the field, not block \"\"\"...\"\"\" quotes or inline # comments.\nIncorrect section order: Follow the specified order for function docstring sections precisely.\nHard-coding function names in examples: Always use $(FUNCTIONNAME).\nIncorrect unit formatting: Ensure \\\\[unit\\\\] syntax is used everywhere except comments within Examples blocks ([unit]). Double-check escaping (\\\\) for LaTeX.\nAdding math formulas to non-calc_ functions: Math blocks are only for functions prefixed with calc_.","category":"page"},{"location":"tutorials/tutorial3/#Tutorial-3-Computing-line-parameters","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"This case file demonstrates how to model an armored high-voltage single-core power cable using the LineCableModels.jl package. The objective is to build a complete representation of a single-core 525 kV cable with a 1600 mm² copper conductor, 1.2 mm tubular lead sheath and 68 x 6 mm galvanized steel armor, based on the design described in [13].","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Tutorial outline","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Pages = [\n\t\"tutorial3.md\",\n]\nDepth = 2:3","category":"page"},{"location":"tutorials/tutorial3/#Introduction","page":"Tutorial 3 - Computing line parameters","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"HVDC cables are constructed around a central conductor enclosed by a triple-extruded insulation system (inner/outer semi-conductive layers and main insulation). A metallic screen and protective outer sheath are then applied for land cables. Subsea designs add galvanized steel wire armor over this structure to provide mechanical strength against water pressure. A reference design for a 525 kV HVDC cable is shown here.","category":"page"},{"location":"tutorials/tutorial3/#Getting-started","page":"Tutorial 3 - Computing line parameters","title":"Getting started","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Load the package and set up the environment:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"using DataFrames\nusing LineCableModels\nusing Printf\nfullfile(filename) = joinpath(@__DIR__, filename); #hide\nsetup_logging!(0); #hide\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Initialize library and the required materials for this design:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"materials = MaterialsLibrary(add_defaults=true)\nlead = Material(21.4e-8, 1.0, 0.999983, 20.0, 0.00400) # Lead or lead alloy\nadd!(materials, \"lead\", lead)\nsteel = Material(13.8e-8, 1.0, 300.0, 20.0, 0.00450) # Steel\nadd!(materials, \"steel\", steel)\npp = Material(1e15, 2.8, 1.0, 20.0, 0.0) # Laminated paper propylene\nadd!(materials, \"pp\", pp)","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Inspect the contents of the materials library:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"materials_df = DataFrame(materials)","category":"page"},{"location":"tutorials/tutorial3/#Cable-dimensions","page":"Tutorial 3 - Computing line parameters","title":"Cable dimensions","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"The cable under consideration is a high-voltage, stranded copper conductor cable with XLPE insulation, water-blocking tape, lead tubular screens, PE inner sheath, PP bedding, steel armor and PP jacket, rated for 525 kV HVDC systems. This information is typically found in the cable datasheet and is based on the design studied in [13].","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"The cable is found to have the following configuration:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"num_co_wires = 127 # number of core wires\nnum_ar_wires = 68  # number of armor wires\nd_core = 0.0463    # nominal core overall diameter\nd_w = 3.6649e-3    # nominal strand diameter of the core (minimum value to match datasheet)\nt_sc_in = 2e-3     # nominal internal semicon thickness\nt_ins = 26e-3      # nominal main insulation thickness\nt_sc_out = 1.8e-3  # nominal external semicon thickness\nt_wbt = .3e-3      # nominal thickness of the water blocking tape\nt_sc = 3.3e-3      # nominal lead screen thickness\nt_pe = 3e-3        # nominal PE inner sheath thickness\nt_bed = 3e-3       # nominal thickness of the PP bedding\nd_wa = 5.827e-3    # nominal armor wire diameter\nt_jac = 10e-3      # nominal PP jacket thickness\n\nd_overall = d_core #hide\nlayers = [] #hide\npush!(layers, (\"Conductor\", missing, d_overall * 1000)) #hide\nd_overall += 2 * t_sc_in #hide\npush!(layers, (\"Inner semiconductor\", t_sc_in * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_ins #hide\npush!(layers, (\"Main insulation\", t_ins * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sc_out #hide\npush!(layers, (\"Outer semiconductor\", t_sc_out * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_wbt #hide\npush!(layers, (\"Swellable tape\", t_wbt * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sc #hide\npush!(layers, (\"Lead screen\", t_sc * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_pe #hide\npush!(layers, (\"PE inner sheath\", t_pe * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_bed #hide\npush!(layers, (\"PP bedding\", t_bed * 1000, d_overall * 1000)) #hide\nd_overall += 2 * d_wa #hide\npush!(layers, (\"Stranded wire armor\", d_wa * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_jac #hide\npush!(layers, (\"PP jacket\", t_jac * 1000, d_overall * 1000)); #hide\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"The cable structure is summarized in a table for better visualization, with dimensions in milimiters:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"df = DataFrame( #hide\n    layer=first.(layers), #hide\n    thickness=[ #hide\n        ismissing(t) ? \"-\" : round(t, sigdigits=2) for t in getindex.(layers, 2) #hide\n    ], #hide\n    diameter=[round(d, digits=2) for d in getindex.(layers, 3)], #hide\n) #hide","category":"page"},{"location":"tutorials/tutorial3/#Core-and-main-insulation","page":"Tutorial 3 - Computing line parameters","title":"Core and main insulation","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Initialize the conductor object and assign the central wire:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"material = get(materials, \"copper\")\ncore = ConductorGroup(WireArray(0.0, Diameter(d_w), 1, 0.0, material))","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Add the subsequent layers of wires and inspect the object:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"n_strands = 6 # Strands per layer\nn_layers = 6 # Layers of strands\nfor i in 1:n_layers\n    add!(core, WireArray, Diameter(d_w), i * n_strands, 11.0, material)\nend\ncore","category":"page"},{"location":"tutorials/tutorial3/#Inner-semiconductor","page":"Tutorial 3 - Computing line parameters","title":"Inner semiconductor","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Inner semiconductor (1000 Ω.m as per IEC 840):","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"material = get(materials, \"semicon1\")\nmain_insu = InsulatorGroup(Semicon(core, Thickness(t_sc_in), material))","category":"page"},{"location":"tutorials/tutorial3/#Main-insulation","page":"Tutorial 3 - Computing line parameters","title":"Main insulation","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Add the insulation layer:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"material = get(materials, \"pe\")\nadd!(main_insu, Insulator, Thickness(t_ins), material)","category":"page"},{"location":"tutorials/tutorial3/#Outer-semiconductor","page":"Tutorial 3 - Computing line parameters","title":"Outer semiconductor","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Outer semiconductor (500 Ω.m as per IEC 840):","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"material = get(materials, \"semicon2\")\nadd!(main_insu, Semicon, Thickness(t_sc_out), material)","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Water blocking (swellable) tape:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"material = get(materials, \"polyacrylate\")\nadd!(main_insu, Semicon, Thickness(t_wbt), material)","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Group core-related components:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"core_cc = CableComponent(\"core\", core, main_insu)\n\ncable_id = \"525kV_1600mm2\"\ndatasheet_info = NominalData(\n    designation_code=\"(N)2XH(F)RK2Y\",\n    U0=500.0,                        # Phase (pole)-to-ground voltage [kV]\n    U=525.0,                         # Phase (pole)-to-phase (pole) voltage [kV]\n    conductor_cross_section=1600.0,  # [mm²]\n    screen_cross_section=1000.0,     # [mm²]\n    resistance=nothing,              # DC resistance [Ω/km]\n    capacitance=nothing,             # Capacitance [μF/km]\n    inductance=nothing,              # Inductance in trifoil [mH/km]\n)\ncable_design = CableDesign(cable_id, core_cc, nominal_data=datasheet_info)","category":"page"},{"location":"tutorials/tutorial3/#Lead-screen/sheath","page":"Tutorial 3 - Computing line parameters","title":"Lead screen/sheath","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Build the wire screens on top of the previous layer:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"material = get(materials, \"lead\")\nscreen_con = ConductorGroup(Tubular(main_insu, Thickness(t_sc), material))","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"PE inner sheath:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"material = get(materials, \"pe\")\nscreen_insu = InsulatorGroup(Insulator(screen_con, Thickness(t_pe), material))","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"PP bedding:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"material = get(materials, \"pp\")\nadd!(screen_insu, Insulator, Thickness(t_bed), material)","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Group sheath components and assign to design:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"sheath_cc = CableComponent(\"sheath\", screen_con, screen_insu)\nadd!(cable_design, sheath_cc)","category":"page"},{"location":"tutorials/tutorial3/#Armor-and-outer-jacket-components","page":"Tutorial 3 - Computing line parameters","title":"Armor and outer jacket components","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Add the armor wires on top of the previous layer:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"lay_ratio = 10.0 # typical value for wire screens\nmaterial = get(materials, \"steel\")\narmor_con = ConductorGroup(\n    WireArray(screen_insu, Diameter(d_wa), num_ar_wires, lay_ratio, material))","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"PP layer after armor:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"material = get(materials, \"pp\")\narmor_insu = InsulatorGroup(Insulator(armor_con, Thickness(t_jac), material))","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Assign the armor parts directly to the design:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"add!(cable_design, \"armor\", armor_con, armor_insu)","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Inspect the finished cable design:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"plt3 = preview(cable_design)","category":"page"},{"location":"tutorials/tutorial3/#Examining-the-cable-parameters-(RLC)","page":"Tutorial 3 - Computing line parameters","title":"Examining the cable parameters (RLC)","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Summarize DC lumped parameters (R, L, C):","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"core_df = DataFrame(cable_design, :baseparams)","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Obtain the equivalent electromagnetic properties of the cable:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"components_df = DataFrame(cable_design, :components)","category":"page"},{"location":"tutorials/tutorial3/#Saving-the-cable-design","page":"Tutorial 3 - Computing line parameters","title":"Saving the cable design","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Load an existing CablesLibrary file or create a new one:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"library = CablesLibrary()\nlibrary_file = fullfile(\"cables_library.json\")\nload!(library, file_name=library_file)\nadd!(library, cable_design)\nlibrary_df = DataFrame(library)","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Save to file for later use:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"save(library, file_name=library_file);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/#Defining-a-cable-system","page":"Tutorial 3 - Computing line parameters","title":"Defining a cable system","text":"","category":"section"},{"location":"tutorials/tutorial3/#Earth-model","page":"Tutorial 3 - Computing line parameters","title":"Earth model","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Define a constant frequency earth model:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"f = 1e-3 # Near DC frequency for the analysis\nearth_params = EarthModel([f], 100.0, 10.0, 1.0)  # 100 Ω·m resistivity, εr=10, μr=1","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Earth model base (DC) properties:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"earthmodel_df = DataFrame(earth_params)","category":"page"},{"location":"tutorials/tutorial3/#Underground-bipole-configuration","page":"Tutorial 3 - Computing line parameters","title":"Underground bipole configuration","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Define the coordinates for both cables:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"xp, xn, y0 = -0.5, 0.5, -1.0;\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Initialize the LineCableSystem with positive pole:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"cablepos = CablePosition(cable_design, xp, y0,\n    Dict(\"core\" => 1, \"sheath\" => 0, \"armor\" => 0))\ncable_system = LineCableSystem(\"525kV_1600mm2_bipole\", 1000.0, cablepos)","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Add the other pole (negative) to the system:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"add!(cable_system, cable_design, xn, y0,\n    Dict(\"core\" => 2, \"sheath\" => 0, \"armor\" => 0))","category":"page"},{"location":"tutorials/tutorial3/#Cable-system-preview","page":"Tutorial 3 - Computing line parameters","title":"Cable system preview","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"In this section the complete bipole cable system is examined.","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Display system details:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"system_df = DataFrame(cable_system)","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Visualize the cross-section of the three-phase system:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"plt4 = preview(cable_system, zoom_factor=0.15)","category":"page"},{"location":"tutorials/tutorial3/#PSCAD-export","page":"Tutorial 3 - Computing line parameters","title":"PSCAD export","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"This step showcases how to export the model for electromagnetic transient simulations in PSCAD.","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Export to PSCAD input file:","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"output_file = fullfile(\"$(cable_system.system_id)_export.pscx\")\nexport_file = export_data(:pscad, cable_system, earth_params, file_name=output_file);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/#FEM-calculations","page":"Tutorial 3 - Computing line parameters","title":"FEM calculations","text":"","category":"section"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Define a LineParametersProblem with the cable system and earth model","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"problem = LineParametersProblem(\n    cable_system,\n    temperature=20.0,  # Operating temperature\n    earth_props=earth_params,\n    frequencies=[f],   # Frequency for the analysis\n);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Estimate domain size based on skin depth in the earth","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"domain_radius = calc_domain_size(earth_params, [f]);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Define custom mesh transitions around each cable","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"mesh_transition1 = MeshTransition(\n    cable_system,\n    [1],\n    r_min=0.08,\n    r_length=0.25,\n    mesh_factor_min=0.01 / (domain_radius / 5),\n    mesh_factor_max=0.25 / (domain_radius / 5),\n    n_regions=5)\n\nmesh_transition2 = MeshTransition(\n    cable_system,\n    [2],\n    r_min=0.08,\n    r_length=0.25,\n    mesh_factor_min=0.01 / (domain_radius / 5),\n    mesh_factor_max=0.25 / (domain_radius / 5),\n    n_regions=5);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Define runtime options","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"opts = (\n    force_remesh=true,                # Force remeshing\n    force_overwrite=true,             # Overwrite existing files\n    plot_field_maps=false,            # Do not compute/ plot field maps\n    mesh_only=false,                  # Preview the mesh\n    save_path=fullfile(\"fem_output\"), # Results directory\n    keep_run_files=true,              # Archive files after each run\n    verbosity=0,                      # Verbosity\n);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Define the FEM formulation with the specified parameters","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"formulation = FormulationSet(:FEM,\n    impedance=Darwin(),\n    admittance=Electrodynamics(),\n    domain_radius=domain_radius,\n    domain_radius_inf=domain_radius * 1.25,\n    elements_per_length_conductor=1,\n    elements_per_length_insulator=2,\n    elements_per_length_semicon=1,\n    elements_per_length_interfaces=5,\n    points_per_circumference=16,\n    mesh_size_min=1e-6,\n    mesh_size_max=domain_radius / 5,\n    mesh_transitions=[mesh_transition1,\n        mesh_transition2],\n    mesh_size_default=domain_radius / 10,\n    mesh_algorithm=5,\n    mesh_max_retries=20,\n    materials=materials,\n    options=opts\n);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Run the FEM model","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"@time workspace, line_params = compute!(problem, formulation);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"Display primary core results","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"if !opts.mesh_only\n    Z = line_params.Z[1, 1, 1]\n    Y = line_params.Y[1, 1, 1]\n    R = real(Z) * 1000\n    L = imag(Z) / (2π * f) * 1e6\n    C = imag(Y) / (2π * f) * 1e9\n    println(\"R = $(@sprintf(\"%.6g\", R)) Ω/km\")\n    println(\"L = $(@sprintf(\"%.6g\", L)) mH/km\")\n    println(\"C = $(@sprintf(\"%.6g\", C)) μF/km\")\nend","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"","category":"page"},{"location":"tutorials/tutorial3/","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"🏠 Back to Tutorials","category":"page"},{"location":"bib/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bib/","page":"Bibliography","title":"Bibliography","text":"J.-R. Riba. The Role of AC Resistance of Bare Stranded Conductors for Developing Dynamic Line Rating Approaches. Applied Sciences 14 (2024).\n\n\n\nV. T. Morgan. The Current Distribution, Resistance and Internal Inductance of Linear Power System Conductors—A Review of Explicit Equations. IEEE Transactions on Power Delivery 28, 1252–1262 (2013).\n\n\n\nY. Yang, S. Fortin, J. Ma and F. P. Dawalibi. GMR of Stranded Multizone Conductors. In: The 4th IASTED Asian Conference on Power and Energy Systems (AsiaPES) (2008). Link.\n\n\n\nB. Gustavsen. Panel session on data for modeling system transients insulated cables. In: 2001 IEEE Power Engineering Society Winter Meeting. Conference Proceedings (Cat. No.01CH37194), Vol. 2 (2001); p. 718-723 vol.2.\n\n\n\nU. S. Gudmundsdottir, B. Gustavsen, C. L. Bak and W. Wiechowski. Field Test and Simulation of a 400-kV Cross-Bonded Cable System. IEEE Transactions on Power Delivery 26, 1403–1410 (2011).\n\n\n\nA. Ametani. A General Formulation of Impedance and Admittance of Cables. IEEE Transactions on Power Apparatus and Systems PAS-99, 902–910 (1980).\n\n\n\nT. A. Papadopoulos, D. A. Tsiamitros and G. K. Papagiannis. Impedances and Admittances of Underground Cables for the Homogeneous Earth Case. IEEE Transactions on Power Delivery 25, 961–969 (2010).\n\n\n\nCIGRE Working Group B1.30. Cable Systems Electrical Characteristics. Technical Brochure 531 (CIGRE, Apr 2013). Link.\n\n\n\nIEC technical committee 20: Electric cables. IEC 60287 - Electric cables – Calculation of the current rating (International Electrotechnical Commission, 2023). Link.\n\n\n\nT. C. 20. Distribution cables with extruded insulation for rated voltages from 3.6/6 (7.2) kV up to and including 20.8/36 (42) kV (European Committee for Electrotechnical Standardization, 2023); pp. 1–150. Link.\n\n\n\nT. C. VDE. Distribution cables with extruded insulation for rated voltages from 3.6/6 (7.2) kV up to and including 20.8/36 (42) kV (VDE, 2024); pp. 1–120. Link.\n\n\n\nT. C. 7. Conductors for Overhead Lines—Round Wire Concentric Lay Stranded Conductors (European Committee for Electrotechnical Standardization, 2001); pp. 1–73. Link.\n\n\n\nT. Karmokar and M. Popov. Enhanced Modelling and Parameter Determination of HVDC Cables Using Practice-Oriented Methodology. CIGRE Science and Engineering 2025-February (2025).\n\n\n\nB. Gustavsen, J. Martinez and D. Durbak. Parameter determination for modeling system transients-Part II: Insulated cables. IEEE Transactions on Power Delivery 20, 2045–2050 (2005).\n\n\n\nF. Grover and I. S. America. Inductance Calculations: Working Formulas and Tables. Dover books on engineering and engineering physics (Instrument Society of America, 1981).\n\n\n\nCIGRE Working Group B2.12. Alternating Current (AC) Resistance of Helically Stranded Conductors. Technical Brochure 345 (CIGRE, Apr 2008). Link.\n\n\n\nN. Oussalah, Y. Zebboudj and S. A. Boggs. Partial Discharge Pulse Propagation in Shielded Power Cable and Implications for Detection Sensitivity. IEEE Electrical Insulation Magazine 23, 5–10 (2007).\n\n\n\nE. B. Rosa. The self and mutual-inductances of linear conductors. Vol. 4 no. 2 (National Bureau of Standards, 1908).\n\n\n\n","category":"page"},{"location":"CHANGELOG/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"CHANGELOG/#[Unreleased]","page":"Changelog","title":"[Unreleased]","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"/","category":"page"},{"location":"CHANGELOG/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"Refactored CodeComponent structure and constructors.","category":"page"},{"location":"CHANGELOG/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"Included interface to run finite element simulations using Onelab.\nIncluded basic coverage tests.\nIncluded import/export of CableDesigns to JSON files.","category":"page"},{"location":"CHANGELOG/#[v0.1.0](https://github.com/Electa-Git/LineCableModels.jl/releases/tag/v0.1.0)-2025-03-29","page":"Changelog","title":"v0.1.0 - 2025-03-29","text":"","category":"section"},{"location":"CHANGELOG/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"First release. See README.md for more details.","category":"page"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"[Unreleased]: https://github.com/Electa-Git/LineCableModels.jl/compare/v0.1.0...HEAD v0.1.0: https://github.com/Electa-Git/LineCableModels.jl/releases/tag/v0.1.0","category":"page"},{"location":"tutorials/tutorial1/#Tutorial-1-Using-the-materials-library","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"","category":"section"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"This tutorial demonstrates how to manage material properties for power cable modeling using the package LineCableModels.jl. Accurate knowledge of electromagnetic properties is essential for reliable cable design and analysis.","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Beyond showcasing the API, this guide serves as a practical reference by providing standard property values from recognized industry sources like CIGRE TB-531 [8] and IEC 60287 [9] that can be stored and consistently applied across multiple design iterations and simulation studies.","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Tutorial outline","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Pages = [\n\t\"tutorial1.md\",\n]\nDepth = 2:3","category":"page"},{"location":"tutorials/tutorial1/#Getting-started","page":"Tutorial 1 - Using the  materials library","title":"Getting started","text":"","category":"section"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Load the package:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"using DataFrames\nusing LineCableModels\nfullfile(filename) = joinpath(@__DIR__, filename); #hide\nsetup_logging!(0); #hide\nnothing #hide","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"The MaterialsLibrary is a container for storing electromagnetic properties of different materials used in power cables. By default, it initializes with several common materials with their standard properties.","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Initialize a MaterialsLibrary with default values:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"materials = MaterialsLibrary()","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Inspect the contents of the materials library:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"materials_df = DataFrame(materials)","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"The function DataFrame returns a DataFrame with all materials and their properties, namely: electrical resistivity, relative permittivity, relative permeability, reference temperature, and temperature coefficient.","category":"page"},{"location":"tutorials/tutorial1/#Adding-new-materials","page":"Tutorial 1 - Using the  materials library","title":"Adding new materials","text":"","category":"section"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"note: Note\nNew materials can be added to the library using the Material constructor followed by add!.","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"It might be useful to add other conductor materials with corrected properties based on recognized standards [8] [9].","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"copper_corrected = Material(1.835e-8, 1.0, 0.999994, 20.0, 0.00393) # Copper with corrected resistivity from IEC 60287-3-2\nadd!(materials, \"copper_corrected\", copper_corrected)\naluminum_corrected = Material(3.03e-8, 1.0, 0.999994, 20.0, 0.00403) # Aluminum with corrected resistivity from IEC 60287-3-2\nadd!(materials, \"aluminum_corrected\", aluminum_corrected)\nlead = Material(21.4e-8, 1.0, 0.999983, 20.0, 0.00400) # Lead or lead alloy\nadd!(materials, \"lead\", lead)\nsteel = Material(13.8e-8, 1.0, 300.0, 20.0, 0.00450) # Steel\nadd!(materials, \"steel\", steel)\nbronze = Material(3.5e-8, 1.0, 1.0, 20.0, 0.00300) # Bronze\nadd!(materials, \"bronze\", bronze)\nstainless_steel = Material(70.0e-8, 1.0, 500.0, 20.0, 0.0) # Stainless steel\nadd!(materials, \"stainless_steel\", stainless_steel)","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"When modeling cables for EMT analysis, one might be concerned with the impact of insulators and semiconductive layers on cable constants. Common insulation materials and semicons with different dielectric properties are reported in Table 6 of [8]. Let us include some of these materials in the MaterialsLibrary to help our future selves.","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"epr = Material(1e15, 3.0, 1.0, 20.0, 0.005) # EPR (ethylene propylene rubber)\nadd!(materials, \"epr\", epr)\npvc = Material(1e15, 8.0, 1.0, 20.0, 0.1) # PVC (polyvinyl chloride)\nadd!(materials, \"pvc\", pvc)\nlaminated_paper = Material(1e15, 2.8, 1.0, 20.0, 0.0) # Laminated paper propylene\nadd!(materials, \"laminated_paper\", laminated_paper)\ncarbon_pe = Material(0.06, 1e3, 1.0, 20.0, 0.0) # Carbon-polyethylene compound (semicon)\nadd!(materials, \"carbon_pe\", carbon_pe)\nconductive_paper = Material(18.5, 8.6, 1.0, 20.0, 0.0) # Conductive paper layer (semicon)\nadd!(materials, \"conductive_paper\", conductive_paper)","category":"page"},{"location":"tutorials/tutorial1/#Removing-materials","page":"Tutorial 1 - Using the  materials library","title":"Removing materials","text":"","category":"section"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"note: Note\nMaterials can be removed from the library with the delete! function.","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Add a duplicate material by accident:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"add!(materials, \"epr_dupe\", epr)","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"And now remove it using the delete! function:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"delete!(materials, \"epr_dupe\")","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Examine the updated library after removing the duplicate:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"println(\"Material properties compiled from CIGRE TB-531 and IEC 60287:\")\nmaterials_df = DataFrame(materials)","category":"page"},{"location":"tutorials/tutorial1/#Saving-the-materials-library-to-JSON","page":"Tutorial 1 - Using the  materials library","title":"Saving the materials library to JSON","text":"","category":"section"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"output_file = fullfile(\"materials_library.json\")\nsave(materials, file_name=output_file);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial1/#Retrieving-materials-for-use","page":"Tutorial 1 - Using the  materials library","title":"Retrieving materials for use","text":"","category":"section"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"note: Note\nTo load from an existing JSON file, instantiate a new MaterialsLibrary followed by a call to the load! method. Materials can be retrieved from the library using the get function.","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Initialize a new MaterialsLibrary and load from the JSON file:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"materials_from_json = MaterialsLibrary()\nload!(materials_from_json, file_name=output_file)","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Retrieve a material and display the object:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"copper = get(materials_from_json, \"copper_corrected\")","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Access the material properties:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"println(\"Retrieved copper_corrected material properties:\")\nprintln(\"Resistivity: $(copper.rho) Ω·m\")\nprintln(\"Relative permittivity: $(copper.eps_r)\")\nprintln(\"Relative permeability: $(copper.mu_r)\")\nprintln(\"Reference temperature: $(copper.T0) °C\")\nprintln(\"Temperature coefficient: $(copper.alpha) 1/°C\")","category":"page"},{"location":"tutorials/tutorial1/#Conclusion","page":"Tutorial 1 - Using the  materials library","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"This tutorial has demonstrated how to:","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"Initialize a MaterialsLibrary with default Material objects.\nAdd new materials with specific properties.\nRemove duplicate materials.\nSave the library to a file for future use.\nRetrieve materials for use in cable modeling.","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"The MaterialsLibrary provides a flexible and traceable framework to manage material properties for accurate power cable modeling. Custom Material objects can be defined and used to match specific manufacturer data or standards requirements.","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"","category":"page"},{"location":"tutorials/tutorial1/","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"🏠 Back to Tutorials","category":"page"},{"location":"reference/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"This page provides a comprehensive API reference for the LineCableModels.jl package. It documents all public modules, types, functions, and constants, organized by functional area. Each section corresponds to a major module in the package, with detailed information about parameters, return values, and usage examples.","category":"page"},{"location":"reference/#Contents","page":"API reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages = [\"reference.md\"]\nDepth = 3","category":"page"},{"location":"reference/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"reference/#Data-model","page":"API reference","title":"Data model","text":"","category":"section"},{"location":"reference/#LineCableModels.DataModel","page":"API reference","title":"LineCableModels.DataModel","text":"LineCableModels.DataModel\n\nThe DataModel module provides data structures, constructors and utilities for modeling power cables within the LineCableModels.jl package. This module includes definitions for various cable components, and visualization tools for cable designs.\n\nOverview\n\nProvides objects for detailed cable modeling with the CableDesign and supporting types: WireArray, Strip, Tubular, Semicon, and Insulator.\nIncludes objects for cable system modeling with the LineCableSystem type, and multiple formation patterns like trifoil and flat arrangements.\nContains functions for calculating the base electric properties of all elements within a CableDesign, namely: resistance, inductance (via GMR), shunt capacitance, and shunt conductance (via loss factor).\nOffers visualization tools for previewing cable cross-sections and system layouts.\nProvides a library system for storing and retrieving cable designs.\n\nDependencies\n\nBase\nColors\nCore\nDataFrames\nDocStringExtensions\nForceImport\nLineCableModels\nLineCableModels.DataModel.BaseParams\nLineCableModels.EarthProps\nLineCableModels.Materials\nLineCableModels.Utils\nLineCableModels.Validation\nMeasurements\nPlots\nReexport\n\nExports\n\nBaseParams\nCableComponent\nCableDesign\nCablePosition\nCablesLibrary\nConductorGroup\nDiameter\nInsulator\nInsulatorGroup\nLineCableSystem\nNominalData\nSemicon\nStrip\nThickness\nTubular\nWireArray\ncalc_equivalent_alpha\ncalc_equivalent_eps\ncalc_equivalent_gmr\ncalc_equivalent_lossfact\ncalc_equivalent_mu\ncalc_equivalent_rho\ncalc_gmd\ncalc_helical_params\ncalc_inductance_trifoil\ncalc_parallel_equivalent\ncalc_shunt_capacitance\ncalc_shunt_conductance\ncalc_sigma_lossfact\ncalc_solenoid_correction\ncalc_strip_resistance\ncalc_temperature_correction\ncalc_tubular_gmr\ncalc_tubular_inductance\ncalc_tubular_resistance\ncalc_wirearray_coords\ncalc_wirearray_gmr\nflat_formation\ntrifoil_formation\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.DataModel.CableComponent","page":"API reference","title":"LineCableModels.DataModel.CableComponent","text":"mutable struct CableComponent{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a CableComponent, i.e. a group of AbstractCablePart objects, with the equivalent geometric and material properties:\n\nid::String: Cable component identification (e.g. core/sheath/armor).\nconductor_group::ConductorGroup: The conductor group containing all conductive parts.\nconductor_props::Material: Effective properties of the equivalent coaxial conductor.\ninsulator_group::InsulatorGroup: The insulator group containing all insulating parts.\ninsulator_props::Material: Effective properties of the equivalent coaxial insulator.\n\ninfo: Definition & application\nCable components operate as containers for multiple cable parts, allowing the calculation of effective electromagnetic (EM) properties (sigma varepsilon mu). This is performed by transforming the physical objects within the CableComponent into one equivalent coaxial homogeneous structure comprised of one conductor and one insulator, each one represented by effective Material types stored in conductor_props and insulator_props fields.The effective properties approach is widely adopted in EMT-type simulations, and involves locking the internal and external radii of the conductor and insulator parts, respectively, and calculating the equivalent EM properties in order to match the previously determined values of R, L, C and G [4] [14].In applications, the CableComponent type is mapped to the main cable structures described in manufacturer datasheets, e.g., core, sheath, armor and jacket.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CableComponent-Tuple{String, ConductorGroup, InsulatorGroup}","page":"API reference","title":"LineCableModels.DataModel.CableComponent","text":"CableComponent(\n    id::String,\n    conductor_group::ConductorGroup,\n    insulator_group::InsulatorGroup\n) -> CableComponent\n\n\nWeakly-typed constructor that infers the scalar type T from the two groups, coerces them if necessary, and calls the strict kernel.\n\nArguments\n\nid: Cable component identification.\nconductor_group: The conductor group (any ConductorGroup{S}).\ninsulator_group: The insulator group (any InsulatorGroup{R}).\n\nReturns\n\nA CableComponent{T} where T is the resolved scalar type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CableComponent-Union{Tuple{T}, Tuple{String, ConductorGroup{T}, InsulatorGroup{T}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.CableComponent","text":"Initializes a CableComponent object based on its constituent conductor and insulator groups. The constructor performs the following sequence of steps:\n\nValidate that the conductor and insulator groups have matching radii at their interface.\nObtain the lumped-parameter values (R, L, C, G) from the conductor and insulator groups, which are computed within their respective constructors.\nCalculate the correction factors and equivalent electromagnetic properties of the conductor and insulator groups:\n\nQuantity Symbol Function\nResistivity (conductor) rho_con calc_equivalent_rho\nPermeability (conductor) mu_con calc_equivalent_mu\nResistivity (insulator) rho_ins calc_sigma_lossfact\nPermittivity (insulation) varepsilon_ins calc_equivalent_eps\nPermeability (insulation) mu_ins calc_solenoid_correction\n\nArguments\n\nid: Cable component identification (e.g. core/sheath/armor).\nconductor_group: The conductor group containing all conductive parts.\ninsulator_group: The insulator group containing all insulating parts.\n\nReturns\n\nA CableComponent instance with calculated equivalent properties.\n\nExamples\n\nconductor_group = ConductorGroup(...)\ninsulator_group = InsulatorGroup(...)\ncable = CableComponent(\"component_id\", conductor_group, insulator_group)  # Create cable component with base parameters @ 50 Hz\n\nSee also\n\ncalc_equivalent_rho\ncalc_equivalent_mu\ncalc_equivalent_eps\ncalc_sigma_lossfact\ncalc_solenoid_correction\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CableDesign","page":"API reference","title":"LineCableModels.DataModel.CableDesign","text":"mutable struct CableDesign{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents the design of a cable, including its unique identifier, nominal data, and components.\n\ncable_id::String: Unique identifier for the cable design.\nnominal_data::Union{Nothing, NominalData{T}} where T<:Union{Float64, Measurements.Measurement{Float64}}: Informative reference data.\ncomponents::Array{CableComponent{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Vector of cable components.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CableDesign-Tuple{String, CableComponent}","page":"API reference","title":"LineCableModels.DataModel.CableDesign","text":"CableDesign(\n    cable_id::String,\n    component::CableComponent;\n    nominal_data\n) -> CableDesign\n\n\nWeakly-typed constructor that infers the scalar type from the component (and nominal data if present), coerces values to that type, and calls the typed kernel.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CableDesign-Tuple{String, ConductorGroup, InsulatorGroup}","page":"API reference","title":"LineCableModels.DataModel.CableDesign","text":"CableDesign(\n    cable_id::String,\n    conductor_group::ConductorGroup,\n    insulator_group::InsulatorGroup;\n    component_id,\n    nominal_data\n) -> CableDesign\n\n\nConstructs a CableDesign instance from conductor and insulator groups. Convenience wrapper that builds the component with reduced boilerplate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CableDesign-Union{Tuple{T}, Tuple{String, CableComponent{T}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.CableDesign","text":"CableDesign(\n    cable_id::String,\n    component::CableComponent{T<:Union{Float64, Measurements.Measurement{Float64}}};\n    nominal_data\n) -> CableDesign\n\n\nStrict numeric kernel: constructs a CableDesign{T} from one component (typed) and optional nominal data (typed or nothing). Assumes all inputs are already at scalar type T.\n\nArguments\n\ncable_id: Unique identifier for the cable design.\ncomponent: Initial CableComponent for the design.\nnominal_data: Reference data for the cable design. Default: NominalData().\n\nReturns\n\nA CableDesign object with the specified properties.\n\nExamples\n\nconductor_group = ConductorGroup(central_conductor)\ninsulator_group = InsulatorGroup(main_insulator)\ncomponent = CableComponent(conductor_group, insulator_group)\ndesign = CableDesign(\"example\", component)\n\nSee also\n\nCableComponent\nConductorGroup\nInsulatorGroup\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CablePosition","page":"API reference","title":"LineCableModels.DataModel.CablePosition","text":"struct CablePosition{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a physically defined cable with position and phase mapping within a system.\n\ndesign_data::CableDesign: The CableDesign object assigned to this cable position.\nhorz::Union{Float64, Measurements.Measurement{Float64}}: Horizontal coordinate [m].\nvert::Union{Float64, Measurements.Measurement{Float64}}: Vertical coordinate [m].\nconn::Vector{Int64}: Phase mapping vector (aligned with design_data.components).\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CablePosition-2","page":"API reference","title":"LineCableModels.DataModel.CablePosition","text":"CablePosition(\n    cable::Union{Nothing, CableDesign},\n    horz::Number,\n    vert::Number\n) -> CablePosition\nCablePosition(\n    cable::Union{Nothing, CableDesign},\n    horz::Number,\n    vert::Number,\n    conn::Union{Nothing, Dict{String, Int64}}\n) -> CablePosition\n\n\nWeakly-typed constructor that infers T from the cable and coordinates, builds/validates the phase mapping, coerces inputs to T, and calls the typed kernel.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CablePosition-Union{Tuple{T}, Tuple{CableDesign{T}, T, T, Vector{Int64}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.CablePosition","text":"Constructs a CablePosition instance with specified cable design, coordinates, and phase mapping.\n\nArguments\n\ncable: A CableDesign object defining the cable structure.\nhorz: Horizontal coordinate [m].\nvert: Vertical coordinate [m].\nconn: A dictionary mapping component names to phase indices, or nothing for default mapping.\n\nReturns\n\nA CablePosition object with the assigned cable design, coordinates, and phase mapping.\n\n#=\n\nnote: Phase mapping\nThe conn argument is a Dict that maps the cable components to their respective phases. The values (1, 2, 3) represent the phase numbers (A, B, C) in a three-phase system. Components mapped to phase 0 will be Kron-eliminated (grounded). Components set to the same phase will be bundled into an equivalent phase.\n\n=#\n\nExamples\n\ncable_design = CableDesign(\"example\", nominal_data, components_dict)\nxa, ya = 0.0, -1.0  # Coordinates in meters\n\n# With explicit phase mapping\ncablepos1 = CablePosition(cable_design, xa, ya, Dict(\"core\" => 1))\n\n# With default phase mapping (first component to phase 1, others to 0)\ndefault_cablepos = CablePosition(cable_design, xa, ya)\n\nSee also\n\nCableDesign\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CablesLibrary","page":"API reference","title":"LineCableModels.DataModel.CablesLibrary","text":"mutable struct CablesLibrary\n\nRepresents a library of cable designs stored as a dictionary.\n\ndata::Dict{String, CableDesign}: Dictionary mapping cable IDs to the respective CableDesign objects.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CablesLibrary-Tuple{}","page":"API reference","title":"LineCableModels.DataModel.CablesLibrary","text":"CablesLibrary() -> CablesLibrary\n\n\nConstructs an empty CablesLibrary instance.\n\nArguments\n\nNone.\n\nReturns\n\nA CablesLibrary object with an empty dictionary of cable designs.\n\nExamples\n\n# Create a new, empty library\nlibrary = CablesLibrary()\n\nSee also\n\nCableDesign\nadd!\ndelete!\nLineCableModels.ImportExport.save\nDataFrame\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.ConductorGroup","page":"API reference","title":"LineCableModels.DataModel.ConductorGroup","text":"mutable struct ConductorGroup{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractConductorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a composite conductor group assembled from multiple conductive layers or stranded wires.\n\nThis structure serves as a container for different AbstractConductorPart elements  (such as wire arrays, strips, and tubular conductors) arranged in concentric layers.  The ConductorGroup aggregates these individual parts and provides equivalent electrical  properties that represent the composite behavior of the entire assembly.\n\nAttributes\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Inner radius of the conductor group [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: Outer radius of the conductor group [m].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the entire conductor group [m²].\nnum_wires::Int64: Number of individual wires in the conductor group [dimensionless].\nnum_turns::Union{Float64, Measurements.Measurement{Float64}}: Number of turns per meter of each wire strand [1/m].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: DC resistance of the conductor group [Ω].\nalpha::Union{Float64, Measurements.Measurement{Float64}}: Temperature coefficient of resistance [1/°C].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the conductor group [m].\nlayers::Array{LineCableModels.DataModel.AbstractConductorPart{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Vector of conductor layer components.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.ConductorGroup-Union{Tuple{T}, Tuple{T, T, T, Int64, T, T, T, T, Array{LineCableModels.DataModel.AbstractConductorPart{T}, 1}}} where T","page":"API reference","title":"LineCableModels.DataModel.ConductorGroup","text":"Constructs a ConductorGroup instance initializing with the central conductor part.\n\nArguments\n\ncentral_conductor: An AbstractConductorPart object located at the center of the conductor group.\n\nReturns\n\nA ConductorGroup object initialized with geometric and electrical properties derived from the central conductor.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Diameter","page":"API reference","title":"LineCableModels.DataModel.Diameter","text":"struct Diameter{T<:Real} <: LineCableModels.DataModel.AbstractRadius\n\nRepresents the diameter of a cable component.\n\nvalue::Real: Numerical value of the diameter [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Insulator","page":"API reference","title":"LineCableModels.DataModel.Insulator","text":"struct Insulator{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractInsulatorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents an insulating layer with defined geometric, material, and electrical properties given by the attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the insulating layer [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the insulating layer [m].\nmaterial_props::Material: Material properties of the insulator.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Operating temperature of the insulator [°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the insulating layer [m²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance of the insulating layer [Ω/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the insulator [m].\nshunt_capacitance::Union{Float64, Measurements.Measurement{Float64}}: Shunt capacitance per unit length of the insulating layer [F/m].\nshunt_conductance::Union{Float64, Measurements.Measurement{Float64}}: Shunt conductance per unit length of the insulating layer [S·m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Insulator-Union{Tuple{T}, Tuple{T, T, Material{T}, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Insulator","text":"Insulator(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}}\n) -> Insulator\n\n\nConstructs an Insulator object with specified geometric and material parameters.\n\nArguments\n\nradius_in: Internal radius of the insulating layer [m].\nradius_ext: External radius or thickness of the layer [m].\nmaterial_props: Material properties of the insulating material.\ntemperature: Operating temperature of the insulator [°C].\n\nReturns\n\nAn Insulator object with calculated electrical properties.\n\nExamples\n\nmaterial_props = Material(1e10, 3.0, 1.0, 20.0, 0.0)\ninsulator_layer = Insulator(0.01, 0.015, material_props, temperature=25)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.InsulatorGroup","page":"API reference","title":"LineCableModels.DataModel.InsulatorGroup","text":"mutable struct InsulatorGroup{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractInsulatorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a composite coaxial insulator group assembled from multiple insulating layers.\n\nThis structure serves as a container for different AbstractInsulatorPart elements (such as insulators and semiconductors) arranged in concentric layers. The InsulatorGroup aggregates these individual parts and provides equivalent electrical properties that represent the composite behavior of the entire assembly, stored in the attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Inner radius of the insulator group [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: Outer radius of the insulator group [m].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the entire insulator group [m²].\nshunt_capacitance::Union{Float64, Measurements.Measurement{Float64}}: Shunt capacitance per unit length of the insulator group [F/m].\nshunt_conductance::Union{Float64, Measurements.Measurement{Float64}}: Shunt conductance per unit length of the insulator group [S·m].\nlayers::Array{LineCableModels.DataModel.AbstractInsulatorPart{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Vector of insulator layer components.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.InsulatorGroup-Union{Tuple{T}, Tuple{T, T, T, T, T, Array{LineCableModels.DataModel.AbstractInsulatorPart{T}, 1}}} where T","page":"API reference","title":"LineCableModels.DataModel.InsulatorGroup","text":"Constructs an InsulatorGroup instance initializing with the initial insulator part.\n\nArguments\n\ninitial_insulator: An AbstractInsulatorPart object located at the innermost position of the insulator group.\n\nReturns\n\nAn InsulatorGroup object initialized with geometric and electrical properties derived from the initial insulator.\n\nExamples\n\nmaterial_props = Material(1e10, 3.0, 1.0, 20.0, 0.0)\ninitial_insulator = Insulator(0.01, 0.015, material_props)\ninsulator_group = InsulatorGroup(initial_insulator)\nprintln(insulator_group.layers)           # Output: [initial_insulator]\nprintln(insulator_group.shunt_capacitance) # Output: Capacitance in [F/m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"LineCableSystem(\n    system_id::String,\n    line_length::Number,\n    cable::CableDesign,\n    horz::Number,\n    vert::Number\n) -> LineCableSystem\nLineCableSystem(\n    system_id::String,\n    line_length::Number,\n    cable::CableDesign,\n    horz::Number,\n    vert::Number,\n    conn::Union{Nothing, Dict{String, Int64}}\n) -> LineCableSystem\n\n\nWeakly-typed convenience constructor. Builds a CablePosition from a CableDesign and coordinates, then constructs the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem-2","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"mutable struct LineCableSystem{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a cable system configuration, defining the physical structure, cables, and their positions.\n\nsystem_id::String: Unique identifier for the system.\nline_length::Union{Float64, Measurements.Measurement{Float64}}: Length of the cable system [m].\nnum_cables::Int64: Number of cables in the system.\nnum_phases::Int64: Number of actual phases in the system.\ncables::Array{CablePosition{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Cross-section cable positions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem-Tuple{String, Number, CablePosition}","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"LineCableSystem(\n    system_id::String,\n    line_length::Number,\n    cable::CablePosition\n) -> LineCableSystem\n\n\nWeakly-typed constructor. Infers scalar type T from line_length and the cable (or its design), coerces as needed, and calls the strict kernel.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem-Union{Tuple{T}, Tuple{String, T, Array{CablePosition{T}, 1}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"Strict numeric kernel. Builds a typed LineCableSystem{T} from a vector of CablePosition{T}.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem-Union{Tuple{T}, Tuple{String, T, CablePosition{T}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"Constructs a LineCableSystem with an initial cable position and system parameters.\n\nArguments\n\nsystem_id: Identifier for the cable system.\nline_length: Length of the cable system [m].\ncable: Initial CablePosition object defining a cable position and phase mapping.\n\nReturns\n\nA LineCableSystem object initialized with a single cable position.\n\nExamples\n\ncable_design = CableDesign(\"example\", nominal_data, components_dict)\ncablepos1 = CablePosition(cable_design, 0.0, 0.0, Dict(\"core\" => 1))\n\ncable_system = LineCableSystem(\"test_case_1\", 1000.0, cablepos1)\nprintln(cable_system.num_phases)  # Prints number of unique phase assignments\n\nSee also\n\nCablePosition\nCableDesign\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.NominalData","page":"API reference","title":"LineCableModels.DataModel.NominalData","text":"struct NominalData{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nStores nominal electrical and geometric parameters for a cable design.\n\ndesignation_code::Union{Nothing, String}: Cable designation as per DIN VDE 0271/0276.\nU0::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Rated phase-to-earth voltage [kV].\nU::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Rated phase-to-phase voltage [kV].\nconductor_cross_section::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the conductor [mm²].\nscreen_cross_section::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the screen [mm²].\narmor_cross_section::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the armor [mm²].\nresistance::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Base (DC) resistance of the cable core [Ω/km].\ncapacitance::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Capacitance of the main insulation [μF/km].\ninductance::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Inductance of the cable (trifoil formation) [mH/km].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.NominalData-Tuple{}","page":"API reference","title":"LineCableModels.DataModel.NominalData","text":"NominalData(\n;\n    designation_code,\n    U0,\n    U,\n    conductor_cross_section,\n    screen_cross_section,\n    armor_cross_section,\n    resistance,\n    capacitance,\n    inductance\n) -> NominalData{Float64}\n\n\nWeakly-typed constructor that infers the target scalar type T from the provided numeric kwargs (ignoring nothing and the string designation), coerces numerics to T, and calls the strict kernel.\n\nIf no numeric kwargs are provided, it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Semicon","page":"API reference","title":"LineCableModels.DataModel.Semicon","text":"struct Semicon{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractInsulatorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a semiconducting layer with defined geometric, material, and electrical properties given by the attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the semiconducting layer [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the semiconducting layer [m].\nmaterial_props::Material: Material properties of the semiconductor.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Operating temperature of the semiconductor [°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the semiconducting layer [m²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance of the semiconducting layer [Ω/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the semiconducting layer [m].\nshunt_capacitance::Union{Float64, Measurements.Measurement{Float64}}: Shunt capacitance per unit length of the semiconducting layer [F/m].\nshunt_conductance::Union{Float64, Measurements.Measurement{Float64}}: Shunt conductance per unit length of the semiconducting layer [S·m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Semicon-Union{Tuple{T}, Tuple{T, T, Material{T}, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Semicon","text":"Semicon(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}}\n) -> Semicon\n\n\nConstructs a Semicon instance with calculated electrical and geometric properties.\n\nArguments\n\nradius_in: Internal radius of the semiconducting layer [m].\nradius_ext: External radius or thickness of the layer [m].\nmaterial_props: Material properties of the semiconducting material.\ntemperature: Operating temperature of the layer [°C] (default: T₀).\n\nReturns\n\nA Semicon object with initialized properties.\n\nExamples\n\nmaterial_props = Material(1e6, 2.3, 1.0, 20.0, 0.00393)\nsemicon_layer = Semicon(0.01, Thickness(0.002), material_props, temperature=25)\nprintln(semicon_layer.cross_section)      # Expected output: ~6.28e-5 [m²]\nprintln(semicon_layer.resistance)         # Expected output: Resistance in [Ω/m]\nprintln(semicon_layer.gmr)                # Expected output: GMR in [m]\nprintln(semicon_layer.shunt_capacitance)  # Expected output: Capacitance in [F/m]\nprintln(semicon_layer.shunt_conductance)  # Expected output: Conductance in [S·m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Strip","page":"API reference","title":"LineCableModels.DataModel.Strip","text":"struct Strip{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractConductorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a flat conductive strip with defined geometric and material properties given by the attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the strip [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the strip [m].\nthickness::Union{Float64, Measurements.Measurement{Float64}}: Thickness of the strip [m].\nwidth::Union{Float64, Measurements.Measurement{Float64}}: Width of the strip [m].\nlay_ratio::Union{Float64, Measurements.Measurement{Float64}}: Ratio defining the lay length of the strip (twisting factor) [dimensionless].\nmean_diameter::Union{Float64, Measurements.Measurement{Float64}}: Mean diameter of the strip's helical path [m].\npitch_length::Union{Float64, Measurements.Measurement{Float64}}: Pitch length of the strip's helical path [m].\nlay_direction::Int64: Twisting direction of the strip (1 = unilay, -1 = contralay) [dimensionless].\nmaterial_props::Material: Material properties of the strip.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Temperature at which the properties are evaluated [°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the strip [m²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance of the strip [Ω/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the strip [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Strip-Union{Tuple{T}, Tuple{T, T, T, T, Material{T}, T, Int64}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Strip","text":"Strip(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    width::Union{Float64, Measurements.Measurement{Float64}},\n    lay_ratio::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}},\n    lay_direction::Int64\n) -> Strip\n\n\nConstructs a Strip object with specified geometric and material parameters.\n\nArguments\n\nradius_in: Internal radius of the strip [m].\nradius_ext: External radius or thickness of the strip [m].\nwidth: Width of the strip [m].\nlay_ratio: Ratio defining the lay length of the strip [dimensionless].\nmaterial_props: Material properties of the strip.\ntemperature: Temperature at which the properties are evaluated [°C]. Defaults to T₀.\nlay_direction: Twisting direction of the strip (1 = unilay, -1 = contralay) [dimensionless]. Defaults to 1.\n\nReturns\n\nA Strip object with calculated geometric and electrical properties.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nstrip = Strip(0.01, Thickness(0.002), 0.05, 10, material_props, temperature=25)\nprintln(strip.cross_section) # Output: 0.0001 [m²]\nprintln(strip.resistance)    # Output: Resistance value [Ω/m]\n\nSee also\n\nMaterial\nConductorGroup\ncalc_strip_resistance\ncalc_tubular_gmr\ncalc_helical_params\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Thickness","page":"API reference","title":"LineCableModels.DataModel.Thickness","text":"struct Thickness{T<:Real} <: LineCableModels.DataModel.AbstractRadius\n\nRepresents the thickness of a cable component.\n\nvalue::Real: Numerical value of the thickness [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Tubular","page":"API reference","title":"LineCableModels.DataModel.Tubular","text":"struct Tubular{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractConductorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a tubular or solid (radius_in=0) conductor with geometric and material properties defined as:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the tubular conductor [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the tubular conductor [m].\nmaterial_props::Material: A Material object representing the physical properties of the conductor material.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Temperature at which the properties are evaluated [°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the tubular conductor [m²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance (DC) of the tubular conductor [Ω/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the tubular conductor [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Tubular-Union{Tuple{T}, Tuple{T, T, Material{T}, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Tubular","text":"Tubular(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}}\n) -> Tubular\n\n\nInitializes a Tubular object with specified geometric and material parameters.\n\nArguments\n\nradius_in: Internal radius of the tubular conductor [m].\nradius_ext: External radius of the tubular conductor [m].\nmaterial_props: A Material object representing the physical properties of the conductor material.\ntemperature: Temperature at which the properties are evaluated [°C]. Defaults to T₀.\n\nReturns\n\nAn instance of Tubular initialized with calculated geometric and electrical properties.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\ntubular = Tubular(0.01, 0.02, material_props, temperature=25)\nprintln(tubular.cross_section) # Output: 0.000942 [m²]\nprintln(tubular.resistance)    # Output: Resistance value [Ω/m]\n\nSee also\n\nMaterial\ncalc_tubular_resistance\ncalc_tubular_gmr\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.WireArray","page":"API reference","title":"LineCableModels.DataModel.WireArray","text":"struct WireArray{T<:Union{Float64, Measurements.Measurement{Float64}}, U<:Int64} <: LineCableModels.DataModel.AbstractWireArray{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents an array of wires equally spaced around a circumference of arbitrary radius, with attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the wire array [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the wire array [m].\nradius_wire::Union{Float64, Measurements.Measurement{Float64}}: Radius of each individual wire [m].\nnum_wires::Int64: Number of wires in the array [dimensionless].\nlay_ratio::Union{Float64, Measurements.Measurement{Float64}}: Ratio defining the lay length of the wires (twisting factor) [dimensionless].\nmean_diameter::Union{Float64, Measurements.Measurement{Float64}}: Mean diameter of the wire array [m].\npitch_length::Union{Float64, Measurements.Measurement{Float64}}: Pitch length of the wire array [m].\nlay_direction::Int64: Twisting direction of the strands (1 = unilay, -1 = contralay) [dimensionless].\nmaterial_props::Material: Material object representing the physical properties of the wire material.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Temperature at which the properties are evaluated [°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of all wires in the array [m²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance per wire in the array [Ω/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the wire array [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.WireArray-Union{Tuple{U}, Tuple{T}, Tuple{T, T, U, T, Material{T}, T, U}} where {T<:Union{Float64, Measurements.Measurement{Float64}}, U<:Int64}","page":"API reference","title":"LineCableModels.DataModel.WireArray","text":"WireArray(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_wire::Union{Float64, Measurements.Measurement{Float64}},\n    num_wires::Int64,\n    lay_ratio::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}},\n    lay_direction::Int64\n) -> WireArray{T, Int64} where T<:Union{Float64, Measurements.Measurement{Float64}}\n\n\nConstructs a WireArray instance based on specified geometric and material parameters.\n\nArguments\n\nradius_in: Internal radius of the wire array [m].\nradius_wire: Radius of each individual wire [m].\nnum_wires: Number of wires in the array [dimensionless].\nlay_ratio: Ratio defining the lay length of the wires (twisting factor) [dimensionless].\nmaterial_props: A Material object representing the material properties.\ntemperature: Temperature at which the properties are evaluated [°C].\nlay_direction: Twisting direction of the strands (1 = unilay, -1 = contralay) [dimensionless].\n\nReturns\n\nA WireArray object with calculated geometric and electrical properties.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nwire_array = WireArray(0.01, Diameter(0.002), 7, 10, material_props, temperature=25)\nprintln(wire_array.mean_diameter)  # Outputs mean diameter in m\nprintln(wire_array.resistance)     # Outputs resistance in Ω/m\n\nSee also\n\nMaterial\nConductorGroup\ncalc_tubular_resistance\ncalc_wirearray_gmr\ncalc_helical_params\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.flat_formation-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.flat_formation","text":"flat_formation(\n    xc::Union{Float64, Measurements.Measurement{Float64}},\n    yc::Union{Float64, Measurements.Measurement{Float64}},\n    s::Union{Float64, Measurements.Measurement{Float64}};\n    vertical\n) -> NTuple{6, Union{Float64, Measurements.Measurement{Float64}}}\n\n\nCalculates the coordinates of three conductors arranged in a flat (horizontal or vertical) formation.\n\nArguments\n\nxc: X-coordinate of the reference point [m].\nyc: Y-coordinate of the reference point [m].\ns: Spacing between adjacent conductors [m].\nvertical: Boolean flag indicating whether the formation is vertical.\n\nReturns\n\nA tuple containing:\nxa, ya: Coordinates of the first conductor [m].\nxb, yb: Coordinates of the second conductor [m].\nxc, yc: Coordinates of the third conductor [m].\n\nExamples\n\n# Horizontal formation\nxa, ya, xb, yb, xc, yc = flat_formation(0.0, 0.0, 0.1)\nprintln((xa, ya))  # First conductor coordinates\nprintln((xb, yb))  # Second conductor coordinates\nprintln((xc, yc))  # Third conductor coordinates\n\n# Vertical formation\nxa, ya, xb, yb, xc, yc = flat_formation(0.0, 0.0, 0.1, vertical=true)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.trifoil_formation-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.trifoil_formation","text":"trifoil_formation(\n    x0::Union{Float64, Measurements.Measurement{Float64}},\n    y0::Union{Float64, Measurements.Measurement{Float64}},\n    r_ext::Union{Float64, Measurements.Measurement{Float64}}\n) -> NTuple{6, Union{Float64, Measurements.Measurement{Float64}}}\n\n\nCalculates the coordinates of three cables arranged in a trifoil pattern.\n\nArguments\n\nx0: X-coordinate of the center point [m].\ny0: Y-coordinate of the center point [m].\nr_ext: External radius of the circular layout [m].\n\nReturns\n\nA tuple containing:\nxa, ya: Coordinates of the top cable [m].\nxb, yb: Coordinates of the bottom-left cable [m].\nxc, yc: Coordinates of the bottom-right cable [m].\n\nExamples\n\nxa, ya, xb, yb, xc, yc = trifoil_formation(0.0, 0.0, 0.035)\nprintln((xa, ya))  # Coordinates of top cable\nprintln((xb, yb))  # Coordinates of bottom-left cable\nprintln((xc, yc))  # Coordinates of bottom-right cable\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base-parameters-(R,-L,-C,-G)","page":"API reference","title":"Base parameters (R, L, C, G)","text":"","category":"section"},{"location":"reference/#LineCableModels.DataModel.BaseParams","page":"API reference","title":"LineCableModels.DataModel.BaseParams","text":"LineCableModels.DataModel.BaseParams\n\nThe BaseParams submodule provides fundamental functions for determining the base electrical parameters (R, L, C, G) of cable components within the LineCableModels.DataModel module. This includes implementations of standard engineering formulas for resistance, inductance, and geometric parameters of various conductor configurations.\n\nOverview\n\nImplements basic electrical engineering formulas for calculating DC resistance and inductance of different conductor geometries (tubular, strip, wire arrays).\nImplements basic formulas for capacitance and dielectric losses in insulators and semiconductors.\nProvides functions for temperature correction of material properties.\nCalculates geometric mean radii for different conductor configurations.\nIncludes functions for determining the effective length for helical wire arrangements.\nCalculates equivalent electrical parameters and correction factors for different geometries and configurations.\n\nDependencies\n\nBase\nCore\nDocStringExtensions\nForceImport\nLineCableModels\nLineCableModels.Utils\nMeasurements\nReexport\n\nExports\n\ncalc_equivalent_alpha\ncalc_equivalent_eps\ncalc_equivalent_gmr\ncalc_equivalent_lossfact\ncalc_equivalent_mu\ncalc_equivalent_rho\ncalc_gmd\ncalc_helical_params\ncalc_inductance_trifoil\ncalc_parallel_equivalent\ncalc_shunt_capacitance\ncalc_shunt_conductance\ncalc_sigma_lossfact\ncalc_solenoid_correction\ncalc_strip_resistance\ncalc_temperature_correction\ncalc_tubular_gmr\ncalc_tubular_inductance\ncalc_tubular_resistance\ncalc_wirearray_coords\ncalc_wirearray_gmr\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_alpha-Union{Tuple{T}, NTuple{4, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_alpha","text":"calc_equivalent_alpha(\n    alpha1::Union{Float64, Measurements.Measurement{Float64}},\n    R1::Union{Float64, Measurements.Measurement{Float64}},\n    alpha2::Union{Float64, Measurements.Measurement{Float64}},\n    R2::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the equivalent temperature coefficient of resistance (alpha) when two conductors are connected in parallel, by cross-weighted-resistance averaging:\n\nalpha_eq = fracalpha_1 R_2 + alpha_2 R1R_1 + R_2\n\nwhere alpha_1, alpha_2 are the temperature coefficients of the conductors, and R_1, R_2 are the respective resistances.\n\nArguments\n\nalpha1: Temperature coefficient of resistance of the first conductor [1/°C].\nR1: Resistance of the first conductor [Ω].\nalpha2: Temperature coefficient of resistance of the second conductor [1/°C].\nR2: Resistance of the second conductor [Ω].\n\nReturns\n\nThe equivalent temperature coefficient [1/°C] for the parallel combination.\n\nExamples\n\nalpha_conductor = 0.00393  # Copper\nalpha_new_part = 0.00403   # Aluminum\nR_conductor = 0.5\nR_new_part = 1.0\nalpha_eq = calc_equivalent_alpha(alpha_conductor, R_conductor, alpha_new_part, R_new_part)\nprintln(alpha_eq)  # Output: 0.00396 (approximately)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_eps-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_eps","text":"calc_equivalent_eps(\n    C_eq::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the equivalent permittivity for a coaxial cable insulation, using the formula [4]:\n\nvarepsilon_eq = fracC_eq log(fracr_extr_in)2pi varepsilon_0\n\nwhere varepsilon_0 is the permittivity of free space.\n\nArguments\n\nC_eq: Equivalent capacitance of the insulation [F/m].\nradius_ext: External radius of the insulation [m].\nradius_in: Internal radius of the insulation [m].\n\nReturns\n\nEquivalent relative permittivity of the insulation [dimensionless].\n\nExamples\n\neps_eq = calc_equivalent_eps(1e-10, 0.01, 0.005)  # Expected output: ~2.26 [dimensionless]\n\nSee also\n\nε₀\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_gmr-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:LineCableModels.DataModel.AbstractCablePart, U<:LineCableModels.DataModel.AbstractCablePart}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_gmr","text":"calc_equivalent_gmr(\n    existing::LineCableModels.DataModel.AbstractCablePart,\n    new_layer::LineCableModels.DataModel.AbstractCablePart\n) -> Any\n\n\nCalculates the equivalent geometric mean radius (GMR) of a conductor after adding a new layer, by recursive application of the multizone stranded conductor defined as [3]:\n\nGMR_eq = GMR_i-1^beta^2 cdot GMR_i^(1-beta)^2 cdot GMD^2beta(1-beta)\n\nbeta = fracS_i-1S_i-1 + S_i\n\nwhere:\n\nS_i-1 is the cumulative cross-sectional area of the existing cable part, S_i is the total cross-sectional area after inclusion of the conducting layer i.\nGMR_i-1 is the cumulative GMR of the existing cable part, GMR_i is the GMR of the conducting layer i.\nGMD is the geometric mean distance between the existing cable part and the new layer, calculated using calc_gmd.\n\nArguments\n\nexisting: The existing cable part (AbstractCablePart).\nnew_layer: The new layer being added (AbstractCablePart).\n\nReturns\n\nUpdated equivalent GMR of the combined conductor [m].\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nconductor = Conductor(Strip(0.01, 0.002, 0.05, 10, material_props))\nnew_layer = WireArray(0.02, 0.002, 7, 15, material_props)\nequivalent_gmr = calc_equivalent_gmr(conductor, new_layer)  # Expected output: Updated GMR value [m]\n\nSee also\n\ncalc_gmd\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_lossfact-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_lossfact","text":"calc_equivalent_lossfact(\n    G_eq::Union{Float64, Measurements.Measurement{Float64}},\n    C_eq::Union{Float64, Measurements.Measurement{Float64}},\n    ω::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the equivalent loss factor (tangent) of a dielectric material:\n\ntan delta = fracG_eqomega cdot C_eq\n\nwhere tan delta is the loss factor (tangent).\n\nArguments\n\nG_eq: Equivalent conductance of the material [S·m].\nC_eq: Equivalent capacitance of the material [F/m].\nω: Angular frequency [rad/s].\n\nReturns\n\nEquivalent loss factor of the dielectric material [dimensionless].\n\nExamples\n\nloss_factor = calc_equivalent_lossfact(1e-8, 1e-10, 2π*50)  # Expected output: ~0.0318 [dimensionless]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_mu-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_mu","text":"calc_equivalent_mu(\n    gmr::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the relative permeability (mu_r) based on the geometric mean radius (GMR) and conductor dimensions, by executing the inverse of calc_tubular_gmr, and solving for mu_r:\n\nlog GMR = log r_2 - mu_r left fracr_1^4left(r_2^2 - r_1^2right)^2 logleft(fracr_2r_1right) - frac3r_1^2 - r_2^24left(r_2^2 - r_1^2right) right\n\nmu_r = -fracleft(log GMR - log r_2right)fracr_1^4left(r_2^2 - r_1^2right)^2 logleft(fracr_2r_1right) - frac3r_1^2 - r_2^24left(r_2^2 - r_1^2right)\n\nwhere r_1 is the inner radius and r_2 is the outer radius.\n\nArguments\n\ngmr: Geometric mean radius of the conductor [m].\nradius_ext: External radius of the conductor [m].\nradius_in: Internal radius of the conductor [m].\n\nReturns\n\nRelative permeability (mu_r) of the conductor material [dimensionless].\n\nErrors\n\nThrows ArgumentError if radius_ext is less than radius_in.\n\nNotes\n\nAssumes a tubular geometry for the conductor, reducing to the solid case if radius_in is zero.\n\nExamples\n\ngmr = 0.015\nradius_ext = 0.02\nradius_in = 0.01\nmu_r = calc_equivalent_mu(gmr, radius_ext, radius_in)\nprintln(mu_r) # Expected output: ~1.7 [dimensionless]\n\nSee also\n\ncalc_tubular_gmr\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_rho-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_rho","text":"calc_equivalent_rho(\n    R::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext_con::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in_con::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the equivalent resistivity of a solid tubular conductor, using the formula [4]:\n\nrho_eq = R_eq S_eff = R_eq pi (r_ext^2 - r_in^2)\n\nwhere S_eff is the effective cross-sectional area of the tubular conductor.\n\nArguments\n\nR: Resistance of the conductor [Ω].\nradius_ext_con: External radius of the tubular conductor [m].\nradius_in_con: Internal radius of the tubular conductor [m].\n\nReturns\n\nEquivalent resistivity of the tubular conductor [Ω·m].\n\nExamples\n\nrho_eq = calc_equivalent_rho(0.01, 0.02, 0.01)  # Expected output: ~9.42e-4 [Ω·m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_gmd-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:LineCableModels.DataModel.AbstractCablePart, U<:LineCableModels.DataModel.AbstractCablePart}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_gmd","text":"calc_gmd(\n    co1::LineCableModels.DataModel.AbstractCablePart,\n    co2::LineCableModels.DataModel.AbstractCablePart\n) -> Any\n\n\nCalculates the geometric mean distance (GMD) between two cable parts, by using the  definition described in Grover [15]:\n\nlog GMD = left(fracsum_i=1^n_1sum_j=1^n_2 (s_1 cdot s_2) cdot log(d_ij)sum_i=1^n_1sum_j=1^n_2 (s_1 cdot s_2)right)\n\nwhere:\n\nd_ij is the Euclidean distance between elements i and j.\ns_1 and s_2 are the cross-sectional areas of the respective elements.\nn_1 and n_2 are the number of sub-elements in each cable part.\n\nArguments\n\nco1: First cable part (AbstractCablePart).\nco2: Second cable part (AbstractCablePart).\n\nReturns\n\nGeometric mean distance between the cable parts [m].\n\nNotes\n\nFor concentric structures, the GMD converges to the external radii of the outermost element.\n\ninfo: Numerical stability\nThis implementation uses a weighted sum of logarithms rather than the traditional product formula Pi(d_ij)^(1n) found in textbooks. The logarithmic approach prevents numerical underflow/overflow when dealing with many conductors or extreme distance ratios, making it significantly more stable for practical calculations.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nwire_array1 = WireArray(0.01, 0.002, 7, 10, material_props)\nwire_array2 = WireArray(0.02, 0.002, 7, 15, material_props)\ngmd = calc_gmd(wire_array1, wire_array2)  # Expected output: GMD value [m]\n\nstrip = Strip(0.01, 0.002, 0.05, 10, material_props)\ntubular = Tubular(0.01, 0.02, material_props)\ngmd = calc_gmd(strip, tubular)  # Expected output: GMD value [m]\n\nSee also\n\ncalc_wirearray_coords\ncalc_equivalent_gmr\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_helical_params-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_helical_params","text":"calc_helical_params(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    lay_ratio::Union{Float64, Measurements.Measurement{Float64}}\n) -> Tuple{Union{Float64, Measurements.Measurement{Float64}}, Union{Float64, Measurements.Measurement{Float64}}, Union{Float64, Int64, Measurements.Measurement{Float64}}}\n\n\nCalculates the mean diameter, pitch length, and overlength based on cable geometry parameters. The lay ratio is defined as the ratio of the pitch length L_p to the external diameter D_e:\n\nlambda = fracL_pD_e\n\nwhere D_e and L_p are the dimensions represented in the figure.\n\n(Image: )\n\nArguments\n\nradius_in: Inner radius of the cable layer [m].\nradius_ext: Outer radius of the cable layer [m].\nlay_ratio: Ratio of the pitch (lay) length to the external diameter of the corresponding layer of wires [dimensionless].\n\nReturns\n\nmean_diameter: Mean diameter of the cable layer [m].\npitch_length: The length over which the strands complete one full twist [m].\noverlength: Effective length increase resulting from the helical path [1/m].\n\nNotes\n\nReference values for lay_ratio are given under standard EN 50182 [12]:\n\nConductor type Steel wires Aluminum wires Lay ratio - Steel Lay ratio - Aluminum\nAAAC 4 layers - 61 (1/6/12/18/24) - 15/13.5/12.5/11\nACSR 3 layers 7 (1/6) 54 (12/18/24) 19 15/13/11.5\nACSR 2 layers 7 (1/6) 26 (10/16) 19 14/11.5\nACSR 1 layer 7 (1/6) 10 19 14\nACCC/TW - 36 (8/12/16) - 15/13.5/11.5\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.015\nlay_ratio = 12\n\nmean_diam, pitch, overlength = calc_helical_params(radius_in, radius_ext, lay_ratio)\n# mean_diam ≈ 0.025 [m]\n# pitch ≈ 0.3 [m]\n# overlength > 1.0 [1/m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_inductance_trifoil-Union{Tuple{T}, NTuple{9, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_inductance_trifoil","text":"calc_inductance_trifoil(\n    r_in_co::Union{Float64, Measurements.Measurement{Float64}},\n    r_ext_co::Union{Float64, Measurements.Measurement{Float64}},\n    rho_co::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r_co::Union{Float64, Measurements.Measurement{Float64}},\n    r_in_scr::Union{Float64, Measurements.Measurement{Float64}},\n    r_ext_scr::Union{Float64, Measurements.Measurement{Float64}},\n    rho_scr::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r_scr::Union{Float64, Measurements.Measurement{Float64}},\n    S::Union{Float64, Measurements.Measurement{Float64}};\n    rho_e,\n    f\n) -> Float64\n\n\nCalculates the positive-sequence inductance of a trifoil-configured cable system composed of core/screen assuming solid bonding, using the formula given under section 4.2.4.3 of CIGRE TB-531:\n\nZ_d = leftZ_a - Z_xright - fracleft( Z_m - Z_x right)^2Z_s - Z_x\n\nL = mathfrakImleft(fracZ_domegaright)\n\nwhere Z_a, Z_s are the self impedances of the core conductor and the screen, and Z_m, and Z_x are the mutual impedances between core/screen and between cables, respectively, as per sections 4.2.3.4, 4.2.3.5, 4.2.3.6 and 4.2.3.8 of the same document [8].\n\nArguments\n\nr_in_co: Internal radius of the phase conductor [m].\nr_ext_co: External radius of the phase conductor [m].\nrho_co: Electrical resistivity of the phase conductor material [Ω·m].\nmu_r_co: Relative permeability of the phase conductor material [dimensionless].\nr_in_scr: Internal radius of the metallic screen [m].\nr_ext_scr: External radius of the metallic screen [m].\nrho_scr: Electrical resistivity of the metallic screen material [Ω·m].\nmu_r_scr: Relative permeability of the screen conductor material [dimensionless].\nS: Spacing between conductors in trifoil configuration [m].\nrho_e: Soil resistivity [Ω·m]. Default: 100 Ω·m.\nf: Frequency [Hz]. Default: f₀.\n\nReturns\n\nPositive-sequence inductance per unit length of the cable system [H/m].\n\nExamples\n\nL = calc_inductance_trifoil(0.01, 0.015, 1.72e-8, 1.0, 0.02, 0.025, 2.83e-8, 1.0, S=0.1, rho_e=50, f=50)\nprintln(L) # Output: Inductance value in H/m\n\nSee also\n\ncalc_tubular_gmr\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_parallel_equivalent-Union{Tuple{T}, Tuple{T, T}} where T<:Union{Float64, Complex{Measurements.Measurement{Float64}}, Measurements.Measurement{Float64}, ComplexF64}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_parallel_equivalent","text":"calc_parallel_equivalent(\n    Z1::Union{Float64, Complex{Measurements.Measurement{Float64}}, Measurements.Measurement{Float64}, ComplexF64},\n    Z2::Union{Float64, Complex{Measurements.Measurement{Float64}}, Measurements.Measurement{Float64}, ComplexF64}\n) -> Any\n\n\nCalculates the parallel equivalent of two impedances (or series equivalent of two admittances):\n\nZ_eq = fracZ_1 Z_2Z_1 + Z_2\n\nThis expression, when applied recursively to LineCableModels.DataModel.WireArray objects, implements the formula for the hexagonal wiring pattern described in CIGRE TB-345 [1] [16]:\n\nfrac1R_textdc = fracpi d^24 rho left( 1 + sum_1^n frac6nk_n right)\n\nk_n = left 1 + left( pi fracD_nlambda_n right)^2 right^12\n\nwhere R_textdc is the DC resistance, d is the diameter of each wire, ho is the resistivity, n is the number of layers following the hexagonal pattern, D_n is the diameter of the n-th layer, and lambda_n is the pitch length of the n-th layer, obtained using calc_helical_params.\n\nArguments\n\nZ1: The total impedance of the existing system [Ω].\nZ2: The impedance of the new layer being added [Ω].\n\nReturns\n\nThe parallel equivalent impedance [Ω].\n\nExamples\n\nZ1 = 5.0\nZ2 = 10.0\nReq = calc_parallel_equivalent(Z1, Z2)\nprintln(Req) # Outputs: 3.3333333333333335\n\nSee also\n\ncalc_helical_params\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_shunt_capacitance-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_shunt_capacitance","text":"calc_shunt_capacitance(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    epsr::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the shunt capacitance per unit length of a coaxial structure, using the standard formula for the capacitance of a coaxial structure [8] [4] [14]:\n\nC = frac2 pi varepsilon_0 varepsilon_rlog left(fracr_extr_inright)\n\nwhere varepsilon_0 is the vacuum permittivity, varepsilon_r is the relative permittivity of the dielectric material, and r_in and r_ext are the inner and outer radii of the coaxial structure, respectively.\n\nArguments\n\nradius_in: Internal radius of the coaxial structure [m].\nradius_ext: External radius of the coaxial structure [m].\nepsr: Relative permittivity of the dielectric material [dimensionless].\n\nReturns\n\nShunt capacitance per unit length [F/m].\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.02\nepsr = 2.3\ncapacitance = calc_shunt_capacitance(radius_in, radius_ext, epsr)\nprintln(capacitance) # Expected output: ~1.24e-10 [F/m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_shunt_conductance-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_shunt_conductance","text":"calc_shunt_conductance(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    rho::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the shunt conductance per unit length of a coaxial structure, using the improved model reported in [4] [13] [17]:\n\nG = frac2pisigmalog(fracr_extr_in)\n\nwhere sigma = frac1rho is the conductivity of the dielectric/semiconducting material, r_in is the internal radius, and r_ext is the external radius of the coaxial structure.\n\nArguments\n\nradius_in: Internal radius of the coaxial structure [m].\nradius_ext: External radius of the coaxial structure [m].\nrho: Resistivity of the dielectric/semiconducting material [Ω·m].\n\nReturns\n\nShunt conductance per unit length [S·m].\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.02\nrho = 1e9\ng = calc_shunt_conductance(radius_in, radius_ext, rho)\nprintln(g) # Expected output: 2.7169e-9 [S·m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_sigma_lossfact-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_sigma_lossfact","text":"calc_sigma_lossfact(\n    G_eq::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the effective conductivity of a dielectric material from the known conductance (related to the loss factor tan delta) via [4] [13] [17]:\n\nsigma_eq = fracG_eq2pi log(fracr_extr_in)\n\nwhere sigma_eq = frac1rho_eq is the conductivity of the dielectric/semiconducting material, G_eq is the shunt conductance per unit length, r_in is the internal radius, and r_ext is the external radius of the coaxial structure.\n\nArguments\n\nG_eq: Equivalent conductance of the material [S·m].\nradius_in: Internal radius of the coaxial structure [m].\nradius_ext: External radius of the coaxial structure [m].\n\nReturns\n\nEffective material conductivity per unit length [S·m].\n\nExamples\n\nGeq = 2.7169e-9\nsigma_eq = calc_sigma_lossfact(G_eq, radius_in, radius_ext)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_solenoid_correction-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_solenoid_correction","text":"calc_solenoid_correction(\n    num_turns::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext_con::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext_ins::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the solenoid correction factor for magnetic permeability in insulated cables with helical conductors (WireArray), using the formula from Gudmundsdottir et al. [5]:\n\nmu_r sol = 1 + frac2 pi^2 N^2 (r_ins ext^2 - r_con ext^2)log(r_ins extr_con ext)\n\nwhere:\n\nN is the number of turns per unit length.\nr_con ext is the conductor external radius.\nr_ins ext is the insulator external radius.\n\nArguments\n\nnum_turns: Number of turns per unit length [1/m].\nradius_ext_con: External radius of the conductor [m].\nradius_ext_ins: External radius of the insulator [m].\n\nReturns\n\nCorrection factor for the insulator magnetic permeability [dimensionless].\n\nExamples\n\n# Cable with 10 turns per meter, conductor radius 5 mm, insulator radius 10 mm\ncorrection = calc_solenoid_correction(10, 0.005, 0.01)  # Expected output: > 1.0 [dimensionless]\n\n# Non-helical cable (straight conductor)\ncorrection = calc_solenoid_correction(NaN, 0.005, 0.01)  # Expected output: 1.0 [dimensionless]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_strip_resistance-Union{Tuple{T}, NTuple{6, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_strip_resistance","text":"calc_strip_resistance(\n    thickness::Union{Float64, Measurements.Measurement{Float64}},\n    width::Union{Float64, Measurements.Measurement{Float64}},\n    rho::Union{Float64, Measurements.Measurement{Float64}},\n    alpha::Union{Float64, Measurements.Measurement{Float64}},\n    T0::Union{Float64, Measurements.Measurement{Float64}},\n    Top::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the DC resistance of a strip conductor based on its geometric and material properties, using the basic resistance formula in terms of the resistivity and cross-sectional area:\n\nR = rho fracellW T\n\nwhere ell is the length of the strip, W is the width, and T is the thickness. The length is assumed to be infinite in the direction of current flow, so the resistance is calculated per unit length.\n\nArguments\n\nthickness: Thickness of the strip [m].\nwidth: Width of the strip [m].\nrho: Electrical resistivity of the conductor material [Ω·m].\nalpha: Temperature coefficient of resistivity [1/°C].\nT0: Reference temperature for the material properties [°C].\nTop: Operating temperature of the conductor [°C].\n\nReturns\n\nDC resistance of the strip conductor [Ω].\n\nExamples\n\nthickness = 0.002\nwidth = 0.05\nrho = 1.7241e-8\nalpha = 0.00393\nT0 = 20\nT = 25\nresistance = calc_strip_resistance(thickness, width, rho, alpha, T0, T)\n# Output: ~0.0001758 Ω\n\nSee also\n\ncalc_temperature_correction\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_temperature_correction-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_temperature_correction","text":"calc_temperature_correction(\n    alpha::Union{Float64, Measurements.Measurement{Float64}},\n    Top::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\ncalc_temperature_correction(\n    alpha::Union{Float64, Measurements.Measurement{Float64}},\n    Top::Union{Float64, Measurements.Measurement{Float64}},\n    T0::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the temperature correction factor for material properties based on the standard linear temperature model [16]:\n\nk(T) = 1 + alpha (T - T_0)\n\nwhere alpha is the temperature coefficient of the material resistivity, T is the operating temperature, and T_0 is the reference temperature. \n\nArguments\n\nalpha: Temperature coefficient of the material property [1/°C].\nT: Current temperature [°C].\nT0: Reference temperature at which the base material property was measured [°C]. Defaults to T₀.\n\nReturns\n\nTemperature correction factor to be applied to the material property [dimensionless].\n\nExamples\n\n    # Copper resistivity correction (alpha = 0.00393 [1/°C])\n    k = calc_temperature_correction(0.00393, 75.0, 20.0)  # Expected output: 1.2161\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_tubular_gmr-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_tubular_gmr","text":"calc_tubular_gmr(\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the geometric mean radius (GMR) of a tubular conductor, using [2]:\n\nlog GMR = log r_2 - mu_r left fracr_1^4left(r_2^2 - r_1^2right)^2 logleft(fracr_2r_1right) - frac3r_1^2 - r_2^24left(r_2^2 - r_1^2right) right\n\nwhere mu_r is the material magnetic permeability (relative to free space), r_1 and r_2 are the inner and outer radii of the tubular conductor, respectively. If r_2 is approximately equal to r_1 , the tube collapses into a thin shell, and the GMR is equal to r_2. If the tube becomes infinitely thick (e.g., r_2 gg r_1), the GMR diverges to infinity.\n\nArguments\n\nradius_ext: External radius of the tubular conductor [m].\nradius_in: Internal radius of the tubular conductor [m].\nmu_r: Relative permeability of the conductor material [dimensionless].\n\nReturns\n\nGeometric mean radius (GMR) of the tubular conductor [m].\n\nErrors\n\nThrows ArgumentError if radius_ext is less than radius_in.\n\nExamples\n\nradius_ext = 0.02\nradius_in = 0.01\nmu_r = 1.0\ngmr = calc_tubular_gmr(radius_ext, radius_in, mu_r)\nprintln(gmr) # Expected output: ~0.0135 [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_tubular_inductance-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_tubular_inductance","text":"calc_tubular_inductance(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the inductance of a tubular conductor per unit length, disregarding skin-effects (DC approximation) [4] [16] [14]:\n\nL = fracmu_r mu_02 pi log left( fracr_extr_in right)\n\nwhere mu_r is the relative permeability of the conductor material, mu_0 is the vacuum permeability, and r_in and r_ext are the inner and outer radii of the conductor, respectively.\n\nArguments\n\nradius_in: Internal radius of the tubular conductor [m].\nradius_ext: External radius of the tubular conductor [m].\nmu_r: Relative permeability of the conductor material [dimensionless].\n\nReturns\n\nInternal inductance of the tubular conductor per unit length [H/m].\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.02\nmu_r = 1.0\nL = calc_tubular_inductance(radius_in, radius_ext, mu_r)\n# Output: ~2.31e-7 H/m\n\nSee also\n\ncalc_tubular_resistance\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_tubular_resistance-Union{Tuple{T}, NTuple{6, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_tubular_resistance","text":"calc_tubular_resistance(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    rho::Union{Float64, Measurements.Measurement{Float64}},\n    alpha::Union{Float64, Measurements.Measurement{Float64}},\n    T0::Union{Float64, Measurements.Measurement{Float64}},\n    Top::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the DC resistance of a tubular conductor based on its geometric and material properties, using the resistivity and cross-sectional area of a hollow cylinder with radii r_in and r_ext:\n\nR = rho fracellpi (r_ext^2 - r_in^2)\n\nwhere ell is the length of the conductor, r_in and r_ext are the inner and outer radii, respectively. The length is assumed to be infinite in the direction of current flow, so the resistance is calculated per unit length.\n\nArguments\n\nradius_in: Internal radius of the tubular conductor [m].\nradius_ext: External radius of the tubular conductor [m].\nrho: Electrical resistivity of the conductor material [Ω·m].\nalpha: Temperature coefficient of resistivity [1/°C].\nT0: Reference temperature for the material properties [°C].\nTop: Operating temperature of the conductor [°C].\n\nReturns\n\nDC resistance of the tubular conductor [Ω].\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.02\nrho = 1.7241e-8\nalpha = 0.00393\nT0 = 20\nT = 25\nresistance = calc_tubular_resistance(radius_in, radius_ext, rho, alpha, T0, T)\n# Output: ~9.10e-8 Ω\n\nSee also\n\ncalc_temperature_correction\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_wirearray_coords-Union{Tuple{U}, Tuple{T}, Tuple{U, T, T, Tuple{T, T}}} where {T<:Union{Float64, Measurements.Measurement{Float64}}, U<:Int64}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_wirearray_coords","text":"calc_wirearray_coords(\n    num_wires::Int64,\n    radius_wire::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    C::Tuple{T<:Union{Float64, Measurements.Measurement{Float64}}, T<:Union{Float64, Measurements.Measurement{Float64}}}\n) -> Vector{<:Tuple{Union{Float64, Measurements.Measurement{Float64}}, Union{Float64, Measurements.Measurement{Float64}}}}\n\n\nCalculates the center coordinates of wires arranged in a circular pattern.\n\nArguments\n\nnum_wires: Number of wires in the circular arrangement [dimensionless].\nradius_wire: Radius of each individual wire [m].\nradius_in: Inner radius of the wire array (to wire centers) [m].\nC: Optional tuple representing the center coordinates of the circular arrangement [m]. Default is (0.0, 0.0).\n\nReturns\n\nVector of tuples, where each tuple contains the (x, y) coordinates [m] of the center of a wire.\n\nExamples\n\n# Create a 7-wire array with 2mm wire radius and 1cm inner radius\nwire_coords = calc_wirearray_coords(7, 0.002, 0.01)\nprintln(wire_coords[1]) # Output: First wire coordinates\n\n# Create a wire array with custom center position\nwire_coords = calc_wirearray_coords(7, 0.002, 0.01, C=(0.5, 0.3))\n\nSee also\n\nLineCableModels.DataModel.WireArray\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_wirearray_gmr-Union{Tuple{T}, Tuple{T, Int64, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_wirearray_gmr","text":"calc_wirearray_gmr(\n    lay_rad::Union{Float64, Measurements.Measurement{Float64}},\n    N::Int64,\n    rad_wire::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the geometric mean radius (GMR) of a circular wire array, using formula (62), page 335, of the book by Edward Rosa [18]:\n\nGMR = sqrta r n a^n-1\n\nwhere a is the layout radius, n is the number of wires, and r is the radius of each wire.\n\nArguments\n\nlay_rad: Layout radius of the wire array [m].\nN: Number of wires in the array [dimensionless].\nrad_wire: Radius of an individual wire [m].\nmu_r: Relative permeability of the wire material [dimensionless].\n\nReturns\n\nGeometric mean radius (GMR) of the wire array [m].\n\nExamples\n\nlay_rad = 0.05\nN = 7\nrad_wire = 0.002\nmu_r = 1.0\ngmr = calc_wirearray_gmr(lay_rad, N, rad_wire, mu_r)\nprintln(gmr) # Expected output: 0.01187... [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"reference/#Earth-properties","page":"API reference","title":"Earth properties","text":"","category":"section"},{"location":"reference/#LineCableModels.EarthProps","page":"API reference","title":"LineCableModels.EarthProps","text":"LineCableModels.EarthProps\n\nThe EarthProps module provides functionality for modeling and computing earth properties within the LineCableModels.jl package. This module includes definitions for homogeneous and layered earth models, and formulations for frequency-dependent earth properties, to be used in impedance/admittance calculations.\n\nOverview\n\nDefines the EarthModel object for representing horizontally or vertically multi-layered earth models with frequency-dependent properties (ρ, ε, μ).\nProvides the EarthLayer type for representing individual soil layers with electromagnetic properties.\nImplements a multi-dispatch framework to allow different formulations of frequency-dependent earth models with AbstractFDEMFormulation.\nContains utility functions for building complex multi-layered earth models and generating data summaries.\n\nDependencies\n\nBase\nCore\nDataFrames\nDocStringExtensions\nForceImport\nLineCableModels\nLineCableModels.Utils\nMeasurements\nReexport\n\nExports\n\nCPEarth\nDataFrame\nEarthLayer\nEarthModel\n\n\n\n\n\n","category":"module"},{"location":"reference/#DataFrames.DataFrame-Tuple{EarthModel}","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(earth_model::EarthModel) -> DataFrame\n\n\nGenerates a DataFrame summarizing basic properties of earth layers from an EarthModel.\n\nArguments\n\nearth_model: Instance of EarthModel containing earth layers.\n\nReturns\n\nA DataFrame with columns:\nrho_g: Base (DC) resistivity of each layer [Ω·m].\nepsr_g: Base (DC) relative permittivity of each layer [dimensionless].\nmur_g: Base (DC) relative permeability of each layer [dimensionless].\nthickness: Thickness of each layer [m].\n\nExamples\n\ndf = DataFrame(earth_model)\nprintln(df)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.CPEarth","page":"API reference","title":"LineCableModels.EarthProps.CPEarth","text":"struct CPEarth <: LineCableModels.EarthProps.AbstractFDEMFormulation\n\nRepresents an earth model with constant properties (CP), i.e. frequency-invariant electromagnetic properties.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.EarthProps.CPEarth-Union{Tuple{T}, Tuple{Vector{T}, T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.CPEarth","text":"Functor implementation for CPEarth.\n\nComputes frequency-dependent earth properties using the CPEarth formulation, which assumes frequency-invariant values for resistivity, permittivity, and permeability.\n\nArguments\n\nfrequencies: Vector of frequency values [Hz].\nbase_rho_g: Base (DC) electrical resistivity of the soil [Ω·m].\nbase_epsr_g: Base (DC) relative permittivity of the soil [dimensionless].\nbase_mur_g: Base (DC) relative permeability of the soil [dimensionless].\nformulation: Instance of a subtype of AbstractFDEMFormulation defining the computation method.\n\nReturns\n\nrho: Vector of resistivity values [Ω·m] at the given frequencies.\nepsilon: Vector of permittivity values [F/m] at the given frequencies.\nmu: Vector of permeability values [H/m] at the given frequencies.\n\nExamples\n\nfrequencies = [1e3, 1e4, 1e5]\n\n# Using the CP model\nrho, epsilon, mu = CPEarth(frequencies, 100, 10, 1, CPEarth())\nprintln(rho)     # Output: [100, 100, 100]\nprintln(epsilon) # Output: [8.854e-11, 8.854e-11, 8.854e-11]\nprintln(mu)      # Output: [1.2566e-6, 1.2566e-6, 1.2566e-6]\n\nSee also\n\nEarthLayer\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.EarthLayer","page":"API reference","title":"LineCableModels.EarthProps.EarthLayer","text":"struct EarthLayer{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents one single earth layer in an EarthModel object, with base and frequency-dependent properties, and attributes:\n\nbase_rho_g::Union{Float64, Measurements.Measurement{Float64}}: Base (DC) electrical resistivity [Ω·m].\nbase_epsr_g::Union{Float64, Measurements.Measurement{Float64}}: Base (DC) relative permittivity [dimensionless].\nbase_mur_g::Union{Float64, Measurements.Measurement{Float64}}: Base (DC)  relative permeability [dimensionless].\nt::Union{Float64, Measurements.Measurement{Float64}}: Thickness of the layer [m].\nrho_g::Vector{T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Computed resistivity values [Ω·m] at given frequencies.\neps_g::Vector{T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Computed permittivity values [F/m] at given frequencies.\nmu_g::Vector{T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Computed permeability values [H/m] at given frequencies.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.EarthProps.EarthLayer-Union{Tuple{T}, Tuple{T, T, T, T, Vector{T}, Vector{T}, Vector{T}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.EarthLayer","text":"Constructs an EarthLayer instance with specified base and frequency-dependent properties.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.EarthLayer-Union{Tuple{T}, Tuple{Vector{T}, T, T, T, T, LineCableModels.EarthProps.AbstractFDEMFormulation}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.EarthLayer","text":"EarthLayer(\n    frequencies::Array{T<:Union{Float64, Measurements.Measurement{Float64}}, 1},\n    base_rho_g::Union{Float64, Measurements.Measurement{Float64}},\n    base_epsr_g::Union{Float64, Measurements.Measurement{Float64}},\n    base_mur_g::Union{Float64, Measurements.Measurement{Float64}},\n    t::Union{Float64, Measurements.Measurement{Float64}},\n    freq_dependence::LineCableModels.EarthProps.AbstractFDEMFormulation\n) -> EarthLayer\n\n\nConstructs an EarthLayer instance with specified base properties and computes its frequency-dependent values.\n\nArguments\n\nfrequencies: Vector of frequency values [Hz].\nbase_rho_g: Base (DC) electrical resistivity of the layer [Ω·m].\nbase_epsr_g: Base (DC) relative permittivity of the layer [dimensionless].\nbase_mur_g: Base (DC) relative permeability of the layer [dimensionless].\nt: Thickness of the layer [m].\nfreq_dependence: Instance of a subtype of AbstractFDEMFormulation defining the computation method for frequency-dependent properties.\n\nReturns\n\nAn EarthLayer instance with computed frequency-dependent properties.\n\nExamples\n\nfrequencies = [1e3, 1e4, 1e5]\nlayer = EarthLayer(frequencies, 100, 10, 1, 5, CPEarth())\nprintln(layer.rho_g) # Output: [100, 100, 100]\nprintln(layer.eps_g) # Output: [8.854e-11, 8.854e-11, 8.854e-11]\nprintln(layer.mu_g)  # Output: [1.2566e-6, 1.2566e-6, 1.2566e-6]\n\nSee also\n\nCPEarth\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.EarthModel","page":"API reference","title":"LineCableModels.EarthProps.EarthModel","text":"struct EarthModel{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a multi-layered earth model with frequency-dependent properties, and attributes:\n\nfreq_dependence::LineCableModels.EarthProps.AbstractFDEMFormulation: Selected frequency-dependent formulation for earth properties.\nvertical_layers::Bool: Boolean flag indicating whether the model is treated as vertically layered.\nlayers::Array{EarthLayer{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Vector of EarthLayer objects, starting with an air layer and the specified first earth layer.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.EarthProps.EarthModel-Union{Tuple{T}, Tuple{LineCableModels.EarthProps.AbstractFDEMFormulation, Bool, Array{EarthLayer{T}, 1}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.EarthModel","text":"Constructs an EarthModel instance with specified attributes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.EarthModel-Union{Tuple{T}, Tuple{Vector{T}, T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.EarthModel","text":"EarthModel(\n    frequencies::Array{T<:Union{Float64, Measurements.Measurement{Float64}}, 1},\n    rho_g::Union{Float64, Measurements.Measurement{Float64}},\n    epsr_g::Union{Float64, Measurements.Measurement{Float64}},\n    mur_g::Union{Float64, Measurements.Measurement{Float64}};\n    t,\n    freq_dependence,\n    vertical_layers,\n    air_layer\n) -> EarthModel\n\n\nConstructs an EarthModel instance with a specified first earth layer. A semi-infinite air layer is always added before the first earth layer.\n\nArguments\n\nfrequencies: Vector of frequency values [Hz].\nrho_g: Base (DC) electrical resistivity of the first earth layer [Ω·m].\nepsr_g: Base (DC) relative permittivity of the first earth layer [dimensionless].\nmur_g: Base (DC) relative permeability of the first earth layer [dimensionless].\nt: Thickness of the first earth layer [m]. For homogeneous earth models (or the bottommost layer), set t = Inf.\nfreq_dependence: Instance of a subtype of AbstractFDEMFormulation defining the computation method for frequency-dependent properties (default: CPEarth).\nvertical_layers: Boolean flag indicating whether the model should be treated as vertically-layered (default: false).\nair_layer: optional EarthLayer object representing the semi-infinite air layer (default: EarthLayer(frequencies, Inf, 1.0, 1.0, Inf, freq_dependence)).\n\nReturns\n\nAn EarthModel instance with the specified attributes and computed frequency-dependent properties.\n\nExamples\n\nfrequencies = [1e3, 1e4, 1e5]\nearth_model = EarthModel(frequencies, 100, 10, 1, t=Inf)\nprintln(length(earth_model.layers)) # Output: 2 (air + top layer)\nprintln(earth_model.rho_eff) # Output: missing\n\nSee also\n\nEarthLayer\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"reference/#Import-and-export","page":"API reference","title":"Import & export","text":"","category":"section"},{"location":"reference/#LineCableModels.ImportExport","page":"API reference","title":"LineCableModels.ImportExport","text":"LineCableModels.ImportExport\n\nThe ImportExport module provides methods for serializing and deserializing data structures in LineCableModels.jl, and data exchange with external programs.\n\nOverview\n\nThis module provides functionality for:\n\nSaving and loading cable designs and material libraries to/from JSON and other formats.\nExporting cable system models to PSCAD format.\nSerializing custom types with special handling for measurements and complex numbers.\n\nThe module implements a generic serialization framework with automatic type reconstruction and proper handling of Julia-specific types like Measurement objects and Inf/NaN values.\n\nDependencies\n\nBase\nCore\nDates\nDocStringExtensions\nEzXML\nForceImport\nJSON3\nLineCableModels\nLineCableModels.DataModel\nLineCableModels.EarthProps\nLineCableModels.Materials\nLineCableModels.Utils\nMeasurements\nReexport\nSerialization\n\nExports\n\n\n\n\n\n","category":"module"},{"location":"reference/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"reference/#Materials-library","page":"API reference","title":"Materials library","text":"","category":"section"},{"location":"reference/#LineCableModels.Materials","page":"API reference","title":"LineCableModels.Materials","text":"LineCableModels.Materials\n\nThe Materials module provides functionality for managing and utilizing material properties within the LineCableModels.jl package. This module includes definitions for material properties, a library for storing and retrieving materials, and functions for manipulating material data.\n\nOverview\n\nDefines the Material struct representing fundamental physical properties of materials.\nProvides the MaterialsLibrary mutable struct for storing a collection of materials.\nIncludes functions for adding, removing, and retrieving materials from the library.\nSupports loading and saving material data from/to JSON files.\nContains utility functions for displaying material data.\n\nDependencies\n\nBase\nCore\nDataFrames\nDocStringExtensions\nForceImport\nLineCableModels\nLineCableModels.Utils\nMeasurements\nReexport\n\nExports\n\nMaterial\nMaterialsLibrary\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.Materials.Material","page":"API reference","title":"LineCableModels.Materials.Material","text":"struct Material{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nDefines electromagnetic and thermal properties of a material used in cable modeling:\n\nrho::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistivity of the material [Ω·m].\neps_r::Union{Float64, Measurements.Measurement{Float64}}: Relative permittivity [dimensionless].\nmu_r::Union{Float64, Measurements.Measurement{Float64}}: Relative permeability [dimensionless].\nT0::Union{Float64, Measurements.Measurement{Float64}}: Reference temperature for property evaluations [°C].\nalpha::Union{Float64, Measurements.Measurement{Float64}}: Temperature coefficient of resistivity [1/°C].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.Materials.Material-NTuple{5, Any}","page":"API reference","title":"LineCableModels.Materials.Material","text":"Material(rho, eps_r, mu_r, T0, alpha) -> Material\n\n\nWeakly-typed constructor that infers the target scalar type T from the arguments, coerces values to T, and calls the strict numeric kernel.\n\nArguments\n\nrho: Resistivity [Ω·m].\neps_r: Relative permittivity [1].\nmu_r: Relative permeability [1].\nT0: Reference temperature [°C].\nalpha: Temperature coefficient of resistivity [1/°C].\n\nReturns\n\nMaterial{T} where T = resolve_T(rho, eps_r, mu_r, T0, alpha).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Materials.MaterialsLibrary","page":"API reference","title":"LineCableModels.Materials.MaterialsLibrary","text":"mutable struct MaterialsLibrary <: AbstractDict{String, Material}\n\nStores a collection of predefined materials for cable modeling, indexed by material name:\n\ndata::Dict{String, Material}: Dictionary mapping material names to Material objects.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.Materials.MaterialsLibrary-Tuple{}","page":"API reference","title":"LineCableModels.Materials.MaterialsLibrary","text":"MaterialsLibrary(; add_defaults) -> MaterialsLibrary\n\n\nConstructs an empty MaterialsLibrary instance and initializes with default materials.\n\nArguments\n\nNone.\n\nReturns\n\nA MaterialsLibrary object populated with default materials.\n\nExamples\n\n# Create a new, empty library\nlibrary = MaterialsLibrary()\n\nSee also\n\nMaterial\n_add_default_materials!\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"reference/#Utilities","page":"API reference","title":"Utilities","text":"","category":"section"},{"location":"reference/#LineCableModels.Utils","page":"API reference","title":"LineCableModels.Utils","text":"LineCableModels.Utils\n\nThe Utils module provides utility functions and constants for the  LineCableModels.jl package. This module includes functions for handling measurements, numerical comparisons, and other common tasks.\n\nOverview\n\nProvides general constants used throughout the package.\nIncludes utility functions for numerical comparisons and handling measurements.\nContains functions to compute uncertainties and bounds for measurements.\n\nDependencies\n\nBase\nCore\nDocStringExtensions\nForceImport\nLineCableModels\nMacroTools\nPkg\nPlots\nReexport\nStatistics\n\nExports\n\n_CLEANMETHODLIST\nbias_to_uncertain\ncoerce_to_T\nis_headless\n@measurify\n@parameterize\npercent_error\npercent_to_uncertain\nresolve_T\nresolve_backend\nto_certain\nto_lower\nto_nominal\nto_upper\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.Utils._CLEANMETHODLIST","page":"API reference","title":"LineCableModels.Utils._CLEANMETHODLIST","text":"Modified _CLEANMETHODLIST abbreviation with sanitized file paths.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#LineCableModels.Utils.bias_to_uncertain-Tuple{Float64, Vector{<:Measurements.Measurement}}","page":"API reference","title":"LineCableModels.Utils.bias_to_uncertain","text":"bias_to_uncertain(\n    nominal::Float64,\n    measurements::Vector{<:Measurements.Measurement}\n) -> Any\n\n\nComputes the uncertainty of a measurement by incorporating systematic bias.\n\nArguments\n\nnominal: The deterministic nominal value (Float64).\nmeasurements: A vector of Measurement values from the Measurements.jl package.\n\nReturns\n\nA new Measurement object representing the mean measurement value with an uncertainty that accounts for both statistical variation and systematic bias.\n\nNotes\n\nComputes the mean value and its associated uncertainty from the given measurements.\nDetermines the bias as the absolute difference between the deterministic nominal value and the mean measurement.\nThe final uncertainty is the sum of the standard uncertainty (sigma_mean) and the systematic bias.\n\nExamples\n\nusing Measurements\n\nnominal = 10.0\nmeasurements = [10.2 ± 0.1, 9.8 ± 0.2, 10.1 ± 0.15]\nresult = bias_to_uncertain(nominal, measurements)\nprintln(result)  # Output: Measurement with adjusted uncertainty\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.coerce_to_T","page":"API reference","title":"LineCableModels.Utils.coerce_to_T","text":"Public coercion API. Converts scalars and containers to a target type T, applying element‑wise coercion recursively. Complex numbers are handled by splitting into real and imaginary parts and coercing each side independently.\n\nArguments\n\nx: Input value (scalar or container) [dimensionless].\n::Type{T}: Target type [dimensionless].\n\nReturns\n\nValue coerced to the target type:\nFor Real → Complex{P}: constructs Complex{P}(coerce_to_T(re, P), coerce_to_T(im, P)) (imaginary part from 0).\nFor Complex → Real: discards the imaginary part and coerces the real part.\nFor AbstractArray, Tuple, NamedTuple: coerces each element recursively.\nFor other types: defers to _coerce_elt_to_T.\n\nExamples\n\nusing Measurements\n\n# Scalar\ncoerce_to_T(1.2, Float32)                         # 1.2f0\ncoerce_to_T(1.2, Measurement{Float64})            # 1.2 ± 0.0\ncoerce_to_T(1 + 2im, Complex{Float32})            # 1.0f0 + 2.0f0im\ncoerce_to_T(1 + 2im, Float64)                     # 1.0\n\n# Containers\ncoerce_to_T([1.0, 2.0], Measurement{Float64})     # measurement array\ncoerce_to_T((1.0, 2.0), Float32)                  # (1.0f0, 2.0f0)\ncoerce_to_T((; a=1.0, b=2.0), Float32)            # (a = 1.0f0, b = 2.0f0)\n\nMethods\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:262.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:266.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:269.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:272.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:276.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:279.\n\ncoerce_to_T(A, _)\n\ndefined at typecoercion.jl:283.\n\ncoerce_to_T(A, _)\n\ndefined at typecoercion.jl:284.\n\ncoerce_to_T(t, _)\n\ndefined at typecoercion.jl:287.\n\ncoerce_to_T(t, _)\n\ndefined at typecoercion.jl:288.\n\ncoerce_to_T(nt, _)\n\ndefined at typecoercion.jl:292.\n\ncoerce_to_T(nt, _)\n\ndefined at typecoercion.jl:294.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:298.\n\nSee also\n\n_coerce_elt_to_T\nresolve_T\n\n\n\n\n\n","category":"function"},{"location":"reference/#LineCableModels.Utils.is_headless-Tuple{}","page":"API reference","title":"LineCableModels.Utils.is_headless","text":"is_headless() -> Bool\n\n\nDetermines if the current execution environment is headless (without display capability).\n\nReturns\n\ntrue if running in a continuous integration environment or without display access.\nfalse otherwise when a display is available.\n\nExamples\n\nif is_headless()\n\t# Use non-graphical backend\n\tgr()\nelse\n\t# Use interactive backend\n\tplotlyjs()\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.percent_error-Tuple{Number}","page":"API reference","title":"LineCableModels.Utils.percent_error","text":"percent_error(m::Number) -> Any\n\n\nComputes the percentage uncertainty of a measurement.\n\nArguments\n\nm: A numerical value, expected to be of type Measurement from the Measurements.jl package.\n\nReturns\n\nThe percentage uncertainty, computed as 100 * uncertainty(m) / value(m), if m is a Measurement.\nNaN if m is not a Measurement.\n\nExamples\n\nusing Measurements\n\nm = 10.0 ± 2.0\npercent_err = percent_error(m)  # Output: 20.0\n\nnot_a_measurement = 5.0\npercent_err_invalid = percent_error(not_a_measurement)  # Output: NaN\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.percent_to_uncertain-Tuple{Any, Any}","page":"API reference","title":"LineCableModels.Utils.percent_to_uncertain","text":"percent_to_uncertain(\n    val,\n    perc\n) -> Union{Missing, Measurements.Measurement}\n\n\nConverts a value to a measurement with uncertainty based on percentage.\n\nArguments\n\nval: The nominal value.\nperc: The percentage uncertainty (0 to 100).\n\nReturns\n\nA Measurement type with the given value and calculated uncertainty.\n\nExamples\n\nusing Measurements\n\npercent_to_uncertain(100.0, 5)  # Output: 100.0 ± 5.0\npercent_to_uncertain(10.0, 10)  # Output: 10.0 ± 1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.resolve_T-Tuple","page":"API reference","title":"LineCableModels.Utils.resolve_T","text":"resolve_T(args...) -> Type\n\n\nResolves the promotion target type to be used by constructors and coercion utilities based on the runtime arguments. The decision uses structure‑aware predicates for Measurement and Complex:\n\nIf any argument contains Measurement and any contains Complex, returns Complex{Measurement{BASE_FLOAT}}.\nElse if any contains Measurement, returns Measurement{BASE_FLOAT}.\nElse if any contains Complex, returns Complex{BASE_FLOAT}.\nOtherwise returns BASE_FLOAT.\n\nArguments\n\nargs...: Values whose types will drive the promotion decision [dimensionless].\n\nReturns\n\nA Type suitable for numeric promotion in subsequent coercion.\n\nExamples\n\nusing Measurements\n\nT = resolve_T(1.0, 2.0)                       # BASE_FLOAT\nT = resolve_T(1 + 0im, 2.0)                    # Complex{BASE_FLOAT}\nT = resolve_T(measurement(1.0, 0.1), 2.0)      # Measurement{BASE_FLOAT}\nT = resolve_T(measurement(1.0, 0.1), 2 + 0im)  # Complex{Measurement{BASE_FLOAT}}\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.resolve_backend","page":"API reference","title":"LineCableModels.Utils.resolve_backend","text":"resolve_backend(\n\n) -> Union{Plots.GRBackend, Plots.PlotlyJSBackend}\nresolve_backend(backend) -> Any\n\n\nSelects the appropriate plotting backend based on the environment.\n\nArguments\n\nbackend: Optional explicit backend to use. If provided, this backend will be activated.\n\nReturns\n\nNothing. The function activates the chosen backend.\n\nNotes\n\nAutomatically selects GR for headless environments (CI or no DISPLAY) and PlotlyJS for interactive use when no backend is explicitly specified. This is particularly needed when running within CI environments.\n\nExamples\n\nresolve_backend()           # Auto-selects based on environment\nresolve_backend(pyplot)     # Explicitly use PyPlot backend\n\n\n\n\n\n","category":"function"},{"location":"reference/#LineCableModels.Utils.to_certain-Tuple{Any}","page":"API reference","title":"LineCableModels.Utils.to_certain","text":"to_certain(value) -> Any\n\n\nConverts a measurement to a value with zero uncertainty, retaining the numeric type Measurement.\n\nArguments\n\nvalue: Input value that may be a Measurement type or another type.\n\nReturns\n\nIf input is a Measurement, returns the same value with zero uncertainty; otherwise returns the original value unchanged.\n\nExamples\n\nx = 5.0 ± 0.1\nresult = to_certain(x)  # Output: 5.0 ± 0.0\n\ny = 10.0\nresult = to_certain(y)  # Output: 10.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.to_lower-Tuple{Number}","page":"API reference","title":"LineCableModels.Utils.to_lower","text":"to_lower(m::Number) -> Any\n\n\nComputes the lower bound of a measurement value.\n\nArguments\n\nm: A numerical value, expected to be of type Measurement from the Measurements.jl package.\n\nReturns\n\nThe lower bound, computed as value(m) - uncertainty(m) if m is a Measurement.\nNaN if m is not a Measurement.\n\nExamples\n\nusing Measurements\n\nm = 10.0 ± 2.0\nlower = to_lower(m)  # Output: 8.0\n\nnot_a_measurement = 5.0\nlower_invalid = to_lower(not_a_measurement)  # Output: NaN\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.to_nominal-Tuple{Any}","page":"API reference","title":"LineCableModels.Utils.to_nominal","text":"to_nominal(x) -> Any\n\n\nExtracts the nominal value from a measurement or returns the original value.\n\nArguments\n\nx: Input value which can be a Measurement type or any other type.\n\nReturns\n\nThe nominal value if x is a Measurement, otherwise returns x unchanged.\n\nExamples\n\nusing Measurements\n\nto_nominal(1.0)  # Output: 1.0\nto_nominal(5.2 ± 0.3)  # Output: 5.2\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.to_upper-Tuple{Number}","page":"API reference","title":"LineCableModels.Utils.to_upper","text":"to_upper(m::Number) -> Any\n\n\nComputes the upper bound of a measurement value.\n\nArguments\n\nm: A numerical value, expected to be of type Measurement from the Measurements.jl package.\n\nReturns\n\nThe upper bound of m, computed as value(m) + uncertainty(m) if m is a Measurement.\nNaN if m is not a Measurement.\n\nExamples\n\nusing Measurements\n\nm = 10.0 ± 2.0\nupper = to_upper(m)  # Output: 12.0\n\nnot_a_measurement = 5.0\nupper_invalid = to_upper(not_a_measurement)  # Output: NaN\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.@measurify-Tuple{Any}","page":"API reference","title":"LineCableModels.Utils.@measurify","text":"@measurify(function_definition)\n\nWraps a function definition. If any argument tied to a parametric type T is a Measurement, this macro automatically promotes any other arguments of the same parametric type T to Measurement with zero uncertainty. Other arguments (e.g., i::Int) are forwarded without changes.\n\n\n\n\n\n","category":"macro"},{"location":"reference/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"reference/#Private-API","page":"API reference","title":"Private API","text":"","category":"section"},{"location":"reference/#Data-model-2","page":"API reference","title":"Data model","text":"","category":"section"},{"location":"reference/#DataFrames.DataFrame","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(design::CableDesign; ...) -> DataFrame\nDataFrame(\n    design::CableDesign,\n    format::Symbol;\n    S,\n    rho_e\n) -> DataFrame\n\n\nExtracts and displays data from a CableDesign.\n\nArguments\n\ndesign: A CableDesign object to extract data from.\nformat: Symbol indicating the level of detail:\n:baseparams: Basic RLC parameters with nominal value comparison (default).\n:components: Component-level equivalent properties.\n:detailed: Individual cable part properties with layer-by-layer breakdown.\nS: Separation distance between cables [m] (only used for :baseparams format). Default: outermost cable diameter.\nrho_e: Resistivity of the earth [Ω·m] (only used for :baseparams format). Default: 100.\n\nReturns\n\nA DataFrame containing the requested cable data in the specified format.\n\nExamples\n\n# Get basic RLC parameters\ndata = DataFrame(design)  # Default is :baseparams format\n\n# Get component-level data\ncomp_data = DataFrame(design, :components)\n\n# Get detailed part-by-part breakdown\ndetailed_data = DataFrame(design, :detailed)\n\n# Specify earth parameters for core calculations\ncore_data = DataFrame(design, :baseparams, S=0.5, rho_e=150)\n\nSee also\n\nCableDesign\ncalc_tubular_resistance\ncalc_inductance_trifoil\ncalc_shunt_capacitance\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataFrames.DataFrame-Tuple{CablesLibrary}","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(library::CablesLibrary) -> DataFrame\n\n\nLists the cable designs in a CablesLibrary object as a DataFrame.\n\nArguments\n\nlibrary: An instance of CablesLibrary whose cable designs are to be displayed.\n\nReturns\n\nA DataFrame object with the following columns:\ncable_id: The unique identifier for each cable design.\nnominal_data: A string representation of the nominal data for each cable design.\ncomponents: A comma-separated string listing the components of each cable design.\n\nExamples\n\nlibrary = CablesLibrary()\ndesign1 = CableDesign(\"example1\", nominal_data=NominalData(...), components=Dict(\"A\"=>...))\ndesign2 = CableDesign(\"example2\", nominal_data=NominalData(...), components=Dict(\"C\"=>...))\nadd!(library, design1)\nadd!(library, design2)\n\n# Display the library as a DataFrame\ndf = DataFrame(library)\nfirst(df, 5)  # Show the first 5 rows of the DataFrame\n\nSee also\n\nCablesLibrary\nCableDesign\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataFrames.DataFrame-Tuple{LineCableSystem}","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(system::LineCableSystem) -> DataFrame\n\n\nGenerates a summary DataFrame for cable positions and phase mappings within a LineCableSystem.\n\nArguments\n\nsystem: A LineCableSystem object containing the cable definitions and their configurations.\n\nReturns\n\nA DataFrame containing:\ncable_id: Identifier of each cable design.\nhorz: Horizontal coordinate of each cable [m].\nvert: Vertical coordinate of each cable [m].\nphase_mapping: Human-readable string representation mapping each cable component to its assigned phase.\n\nExamples\n\ndf = DataFrame(cable_system)\nprintln(df)\n# Output:\n# │ cable_id   │ horz │ vert  │ phase_mapping           │\n# │------------│------│-------│-------------------------│\n# │ \"Cable1\"   │ 0.0  │ -0.5  │ core: 1, sheath: 0      │\n# │ \"Cable2\"   │ 0.35 │ -1.25 │ core: 2, sheath: 0      │\n\nSee also\n\nLineCableSystem\nCablePosition\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.AbstractCablePart","page":"API reference","title":"LineCableModels.DataModel.AbstractCablePart","text":"abstract type AbstractCablePart{T}\n\nAbstract type representing a generic cable part.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.AbstractConductorPart","page":"API reference","title":"LineCableModels.DataModel.AbstractConductorPart","text":"abstract type AbstractConductorPart{T} <: LineCableModels.DataModel.AbstractCablePart{T}\n\nAbstract type representing a conductive part of a cable.\n\nSubtypes implement specific configurations:\n\nWireArray\nTubular\nStrip\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.AbstractInsulatorPart","page":"API reference","title":"LineCableModels.DataModel.AbstractInsulatorPart","text":"abstract type AbstractInsulatorPart{T} <: LineCableModels.DataModel.AbstractCablePart{T}\n\nAbstract type representing an insulating part of a cable.\n\nSubtypes implement specific configurations:\n\nInsulator\nSemicon\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.delete!-Tuple{CablesLibrary, String}","page":"API reference","title":"Base.delete!","text":"delete!(library::CablesLibrary, cable_id::String)\n\n\nRemoves a cable design from a CablesLibrary object by its ID.\n\nArguments\n\nlibrary: An instance of CablesLibrary from which the cable design will be removed.\ncable_id: The ID of the cable design to remove.\n\nReturns\n\nNothing. Modifies the data field of the CablesLibrary object in-place by removing the specified cable design if it exists.\n\nExamples\n\nlibrary = CablesLibrary()\ndesign = CableDesign(\"example\", ...) # Initialize a CableDesign\nadd!(library, design)\n\n# Remove the cable design\ndelete!(library, \"example\")\nhaskey(library, \"example\")  # Returns false\n\nSee also\n\nCablesLibrary\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.get","page":"API reference","title":"Base.get","text":"get(\n    library::CablesLibrary,\n    cable_id::String\n) -> Union{Nothing, CableDesign}\nget(\n    library::CablesLibrary,\n    cable_id::String,\n    default\n) -> Any\n\n\nRetrieves a cable design from a CablesLibrary object by its ID.\n\nArguments\n\nlibrary: An instance of CablesLibrary from which the cable design will be retrieved.\ncable_id: The ID of the cable design to retrieve.\n\nReturns\n\nA CableDesign object corresponding to the given cable_id if found, otherwise nothing.\n\nExamples\n\nlibrary = CablesLibrary()\ndesign = CableDesign(\"example\", ...) # Initialize a CableDesign\nadd!(library, design)\n\n# Retrieve the cable design\nretrieved_design = get(library, \"cable1\")\nprintln(retrieved_design.id)  # Prints \"example\"\n\n# Attempt to retrieve a non-existent design\nmissing_design = get(library, \"nonexistent_id\")\nprintln(missing_design === nothing)  # Prints true\n\nSee also\n\nCablesLibrary\nCableDesign\nadd!\ndelete!\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CableComponent}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    component::CableComponent\n)\n\n\nDefines the display representation of a CableComponent object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\ncomponent: The CableComponent object to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CableDesign}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    design::CableDesign\n)\n\n\nDefines the display representation of a CableDesign object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\ndesign: The CableDesign object to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Union{ConductorGroup, InsulatorGroup}}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    group::Union{ConductorGroup, InsulatorGroup}\n)\n\n\nDefines the display representation of a ConductorGroup or InsulatorGroupobjects for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\ngroup: The ConductorGroup or InsulatorGroup instance to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, T}} where T<:LineCableModels.DataModel.AbstractCablePart","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    part::LineCableModels.DataModel.AbstractCablePart\n)\n\n\nDefines the display representation of an AbstractCablePart object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\npart: The AbstractCablePart instance to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._coerced_args-Union{Tuple{C}, Tuple{Type{C}, Any, Any, Tuple}} where C","page":"API reference","title":"LineCableModels.DataModel._coerced_args","text":"_coerced_args(_::Type{C}, ntv, Tp, order::Tuple) -> Tuple\n\n\nBuilds the positional argument tuple to feed the typed core constructor, coercing only the fields returned by coercive_fields(C) to type Tp. Non‑coercive fields (e.g., integer flags) are passed through unchanged. Field order is controlled by order (a tuple of symbols), typically (required_fields(C)..., keyword_fields(C)...).\n\nArguments\n\n::Type{C}: Component type [dimensionless].\nntv: Normalized NamedTuple returned by validate! [dimensionless].\nTp: Target element type for numeric coercion [dimensionless].\norder::Tuple: Field order used to assemble the positional tuple [dimensionless].\n\nReturns\n\nA Tuple of arguments in the requested order, with coercions applied where configured.\n\nExamples\n\nargs = _coerced_args(Tubular, ntv, Float64, (:radius_in, :radius_ext, :material_props, :temperature))\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._ctor_materialize-Tuple{Any, Any}","page":"API reference","title":"LineCableModels.DataModel._ctor_materialize","text":"_ctor_materialize(mod, x) -> Any\n\n\nUtility for the constructor macro to materialize input tuples from either:\n\nA tuple literal expression (e.g., (:a, :b, :c)), or\nA bound constant tuple name (e.g., _REQ_TUBULAR).\n\nUsed to keep macro call sites short while allowing both styles.\n\nArguments\n\nmod: Module where constants are resolved [dimensionless].\nx: Expression or symbol representing a tuple [dimensionless].\n\nReturns\n\nA standard Julia Tuple (of symbols or defaults).\n\nErrors\n\nErrorException if x is neither a tuple literal nor a bound constant name.\n\nExamples\n\nsyms = _ctor_materialize(@__MODULE__, :( :a, :b ))\nsyms = _ctor_materialize(@__MODULE__, :_REQ_TUBULAR)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._do_add!-Union{Tuple{Tg}, Tuple{ConductorGroup{Tg}, Type{<:LineCableModels.DataModel.AbstractConductorPart}, Vararg{Any}}} where Tg","page":"API reference","title":"LineCableModels.DataModel._do_add!","text":"_do_add!(\n    group::ConductorGroup{Tg},\n    C::Type{<:LineCableModels.DataModel.AbstractConductorPart},\n    args...;\n    kwargs...\n)\n\n\nInternal, in-place insertion (no promotion logic). Assumes :radius_in was materialized. Runs Validation → parsing, then coerces fields to the group’s T and updates equivalent properties and book-keeping.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._do_add!-Union{Tuple{Tg}, Tuple{InsulatorGroup{Tg}, Type{<:LineCableModels.DataModel.AbstractInsulatorPart}, Vararg{Any}}} where Tg","page":"API reference","title":"LineCableModels.DataModel._do_add!","text":"_do_add!(\n    group::InsulatorGroup{Tg},\n    C::Type{<:LineCableModels.DataModel.AbstractInsulatorPart},\n    args...;\n    f,\n    kwargs...\n)\n\n\nDo the actual insertion for InsulatorGroup with the group already at the correct scalar type. Validates/parses the part, coerces to the group’s T, constructs the strict numeric core, and updates geometry and admittances at the provided frequency.\n\nReturns the mutated group (same object).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._extract_part_properties-Tuple{Any, Any}","page":"API reference","title":"LineCableModels.DataModel._extract_part_properties","text":"_extract_part_properties(part, properties) -> Any\n\n\nHelper function to extract properties from a part for detailed format.\n\nArguments\n\npart: An instance of AbstractCablePart from which to extract properties.\nproperties: A vector of symbols indicating which properties to extract (not used in the current implementation).\n\nReturns\n\nA vector containing the extracted properties in the following order:\ntype: The lowercase string representation of the part's type.\nradius_in: The inner radius of the part, if it exists, otherwise missing.\nradius_ext: The outer radius of the part, if it exists, otherwise missing.\ndiameter_in: The inner diameter of the part (2 * radiusin), if `radiusinexists, otherwisemissing`.\ndiameter_ext: The outer diameter of the part (2 * radiusext), if `radiusextexists, otherwisemissing`.\nthickness: The difference between radius_ext and radius_in, if both exist, otherwise missing.\ncross_section: The cross-sectional area of the part, if it exists, otherwise missing.\nnum_wires: The number of wires in the part, if it exists, otherwise missing.\nresistance: The resistance of the part, if it exists, otherwise missing.\nalpha: The temperature coefficient of resistivity of the part or its material, if it exists, otherwise missing.\ngmr: The geometric mean radius of the part, if it exists, otherwise missing.\ngmr_ratio: The ratio of gmr to radius_ext, if both exist, otherwise missing.\nshunt_capacitance: The shunt capacitance of the part, if it exists, otherwise missing.\nshunt_conductance: The shunt conductance of the part, if it exists, otherwise missing.\n\nNotes\n\nThis function is used to create a standardized format for displaying detailed information about cable parts.\n\nExamples\n\npart = Conductor(...)\nproperties = [:radius_in, :radius_ext, :resistance]  # Example of properties to extract\nextracted_properties = _extract_part_properties(part, properties)\nprintln(extracted_properties)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._get_material_color-Tuple{Any}","page":"API reference","title":"LineCableModels.DataModel._get_material_color","text":"_get_material_color(\n    material_props;\n    rho_weight,\n    epsr_weight,\n    mur_weight\n) -> Any\n\n\nGenerates a color representation for a Material based on its physical properties.\n\nArguments\n\nmaterial_props: Dictionary containing material properties:\nrho: Electrical resistivity [Ω·m].\neps_r: Relative permittivity [dimensionless].\nmu_r: Relative permeability [dimensionless].\nrho_weight: Weight assigned to resistivity in color blending (default: 1.0) [dimensionless].\nepsr_weight: Weight assigned to permittivity in color blending (default: 0.1) [dimensionless].\nmur_weight: Weight assigned to permeability in color blending (default: 0.1) [dimensionless].\n\nReturns\n\nAn RGBA object representing the combined color based on the material's properties.\n\nNotes\n\nColors are normalized and weighted using property-specific gradients:\n\nConductors (ρ ≤ 5ρ₀): White → Dark gray\nPoor conductors (5ρ₀ < ρ ≤ 10⁴): Bronze → Greenish-brown\nInsulators (ρ > 10⁴): Greenish-brown → Black\nPermittivity: Gray → Orange\nPermeability: Silver → Purple\nThe overlay function combines colors with their respective alpha/weight values.\n\nExamples\n\nmaterial_props = Dict(\n\t:rho => 1.7241e-8,\n\t:eps_r => 2.3,\n\t:mu_r => 1.0\n)\ncolor = _get_material_color(material_props)\nprintln(color) # Expected output: RGBA(0.9, 0.9, 0.9, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._normalize_radii-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T","page":"API reference","title":"LineCableModels.DataModel._normalize_radii","text":"_normalize_radii(_::Type{T}, rin, rex) -> Any\n\n\nResolves radius parameters for cable components, converting from various input formats to standardized inner radius, outer radius, and thickness values.\n\nThis function serves as a high-level interface to the radius resolution system. It processes inputs through a two-stage pipeline:\n\nFirst normalizes input parameters to consistent forms using _parse_radius_operand.\nThen delegates to specialized implementations via _do_resolve_radius based on the component type.\n\nArguments\n\nparam_in: Inner boundary parameter (defaults to radius) [m]. Can be a number, a Diameter , a Thickness, or an AbstractCablePart.\nparam_ext: Outer boundary parameter (defaults to radius) [m]. Can be a number, a Diameter , a Thickness, or an AbstractCablePart.\nobject_type: Type associated to the constructor of the new AbstractCablePart.\n\nReturns\n\nradius_in: Normalized inner radius [m].\nradius_ext: Normalized outer radius [m].\nthickness: Computed thickness or specialized dimension depending on the method [m]. For WireArray components, this value represents the wire radius instead of thickness.\n\nSee also\n\nDiameter\nThickness\nAbstractCablePart\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._parse_radius_operand","page":"API reference","title":"LineCableModels.DataModel._parse_radius_operand","text":"Parses input values into radius representation based on object type and input type.\n\nArguments\n\nx: Input value that can be a raw number, a Diameter, a Thickness, or other convertible type [m].\nobject_type: Type parameter used for dispatch.\n\nReturns\n\nParsed radius value in appropriate units [m].\n\nExamples\n\nradius = _parse_radius_operand(10.0, ...)   # Direct radius value\nradius = _parse_radius_operand(Diameter(20.0), ...)  # From diameter object\nradius = _parse_radius_operand(Thickness(5.0), ...)  # From thickness object\n\nMethods\n\n_parse_radius_operand(x, _)\n\ndefined at radii.jl:68.\n\n_parse_radius_operand(d, _)\n\ndefined at radii.jl:69.\n\n_parse_radius_operand(p, _)\n\ndefined at radii.jl:70.\n\n_parse_radius_operand(p, _)\n\ndefined at radii.jl:71.\n\n_parse_radius_operand(x, _)\n\ndefined at radii.jl:75.\n\n_parse_radius_operand(x, _)\n\ndefined at radii.jl:77.\n\nSee also\n\nDiameter\nThickness\n\n\n\n\n\n","category":"function"},{"location":"reference/#LineCableModels.DataModel._print_fields-Tuple{IO, Any, Vector{Symbol}}","page":"API reference","title":"LineCableModels.DataModel._print_fields","text":"_print_fields(\n    io::IO,\n    obj,\n    fields_to_show::Vector{Symbol};\n    sigdigits\n) -> Int64\n\n\nPrint the specified fields of an object in a compact format.\n\nArguments\n\nio: The output stream.\nobj: The object whose fields will be displayed.\nfields_to_show: Vector of field names (as Symbols) to display.\nsigdigits: Number of significant digits for rounding numeric values.\n\nReturns\n\nNumber of fields that were actually displayed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._promotion_T-Union{Tuple{C}, Tuple{Type{C}, Any, Tuple}} where C","page":"API reference","title":"LineCableModels.DataModel._promotion_T","text":"_promotion_T(_::Type{C}, ntv, _order::Tuple) -> Type\n\n\nDetermines the promoted numeric element type for convenience constructors of component C. The promotion is computed across the values of coercive_fields(C), extracted from the normalized NamedTuple ntv produced by validate!. This ensures all numeric fields that participate in calculations share a common element type (e.g., Float64, Measurement{Float64}).\n\nArguments\n\n::Type{C}: Component type [dimensionless].\nntv: Normalized NamedTuple returned by validate! [dimensionless].\n_order::Tuple: Ignored by this method; present for arity symmetry with _coerced_args [dimensionless].\n\nReturns\n\nThe promoted numeric element type [dimensionless].\n\nExamples\n\nTp = _promotion_T(Tubular, (radius_in=0.01, radius_ext=0.02, material_props=mat, temperature=20.0), ())\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._with_kwdefaults-Union{Tuple{C}, Tuple{Type{C}, NamedTuple}} where C","page":"API reference","title":"LineCableModels.DataModel._with_kwdefaults","text":"_with_kwdefaults(\n    _::Type{C},\n    kwargs::NamedTuple\n) -> NamedTuple\n\n\nMerge per-part keyword defaults declared via Validation.keyword_defaults with user-provided kwargs and return a NamedTuple suitable for forwarding.\n\nDefaults may be a NamedTuple or a Tuple zipped against Validation.keyword_fields(::Type{C}). User keys always win.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.coerce_to_T-Union{Tuple{T}, Tuple{NominalData{T}, Type{T}}} where T","page":"API reference","title":"LineCableModels.Utils.coerce_to_T","text":"Identity: no allocation when already at T.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, LineCableModels.DataModel.AbstractCablePart}} where T","page":"API reference","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_ext},\n    _::LineCableModels.DataModel.AbstractCablePart\n) -> Bool\n\n\nDefault policy for outer radius raw inputs (annular shells): reject AbstractCablePart proxies. Outer radius must be numeric or a Thickness wrapper to avoid creating zero‑thickness layers.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_ext}: Field tag for the outer radius [dimensionless].\n::AbstractCablePart: Proxy object [dimensionless].\n\nReturns\n\nfalse always.\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_ext), prev_layer)  # false\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, Thickness}} where T","page":"API reference","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_ext},\n    _::Thickness\n) -> Bool\n\n\nDefault policy for outer radius raw inputs (annular shells): accept Thickness as a convenience wrapper. The thickness is expanded to an outer radius during parsing.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_ext}: Field tag for the outer radius [dimensionless].\n::Thickness: Thickness wrapper [dimensionless].\n\nReturns\n\nBool indicating acceptance (true).\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_ext), Thickness(1e-3))  # true\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_in}, LineCableModels.DataModel.AbstractCablePart}} where T","page":"API reference","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_in},\n    p::LineCableModels.DataModel.AbstractCablePart\n) -> Bool\n\n\nDefault policy for inner radius raw inputs: accept proxies that expose an outer radius. This permits stacking by hijacking p.radius_ext during parsing.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_in}: Field tag for the inner radius [dimensionless].\np::AbstractCablePart: Proxy object [dimensionless].\n\nReturns\n\nBool indicating acceptance (true if hasproperty(p, :radius_ext)).\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_in), prev_layer)  # true if prev_layer has :radius_ext\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.add!-Tuple{CablesLibrary, CableDesign}","page":"API reference","title":"LineCableModels.add!","text":"Stores a cable design in a CablesLibrary object.\n\nArguments\n\nlibrary: An instance of CablesLibrary to which the cable design will be added.\ndesign: A CableDesign object representing the cable design to be added. This object must have a cable_id field to uniquely identify it.\n\nReturns\n\nNone. Modifies the data field of the CablesLibrary object in-place by adding the new cable design.\n\nExamples\n\nlibrary = CablesLibrary()\ndesign = CableDesign(\"example\", ...) # Initialize CableDesign with required fields\nadd!(library, design)\nprintln(library) # Prints the updated dictionary containing the new cable design\n\nSee also\n\nCablesLibrary\nCableDesign\ndelete!\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.add!-Union{Tuple{C}, Tuple{T}, Tuple{ConductorGroup{T}, Type{C}, Vararg{Any}}} where {T, C<:LineCableModels.DataModel.AbstractConductorPart}","page":"API reference","title":"LineCableModels.add!","text":"add!(\n    group::ConductorGroup{T},\n    part_type::Type{C<:LineCableModels.DataModel.AbstractConductorPart},\n    args...;\n    kwargs...\n) -> ConductorGroup{Tg} where Tg\n\n\nAdd a new conductor part to a ConductorGroup, validating raw inputs, normalizing proxies, and promoting the group’s numeric type if required.\n\nBehavior:\n\nApply part-level keyword defaults.\nDefault radius_in to group.radius_ext if absent.\nCompute Tnew = resolve_T(group, radius_in, args..., values(kwargs)...).\nIf Tnew === T, mutate in place; else coerce_to_T(group, Tnew) then mutate and return the promoted group.\n\nArguments\n\ngroup: ConductorGroup object to which the new part will be added.\npart_type: Type of conductor part to add (AbstractConductorPart).\nargs...: Positional arguments specific to the constructor of the part_type (AbstractConductorPart) [various].\nkwargs...: Named arguments for the constructor including optional values specific to the constructor of the part_type (AbstractConductorPart) [various].\n\nReturns\n\nThe function modifies the ConductorGroup instance in place and does not return a value.\n\nNotes\n\nUpdates gmr, resistance, alpha, radius_ext, cross_section, and num_wires to account for the new part.\nThe temperature of the new part defaults to the temperature of the first layer if not specified.\nThe radius_in of the new part defaults to the external radius of the existing conductor if not specified.\n\nwarning: Note\nWhen an AbstractCablePart is provided as radius_in, the constructor retrieves its radius_ext value, allowing the new cable part to be placed directly over the existing part in a layered cable design.\nIn case of uncertain measurements, if the added cable part is of a different type than the existing one, the uncertainty is removed from the radius value before being passed to the new component. This ensures that measurement uncertainties do not inappropriately cascade across different cable parts.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nconductor = ConductorGroup(Strip(0.01, 0.002, 0.05, 10, material_props))\nadd!(conductor, WireArray, 0.02, 0.002, 7, 15, material_props, temperature = 25)\n\nSee also\n\nConductorGroup\nWireArray\nStrip\nTubular\ncalc_equivalent_gmr\ncalc_parallel_equivalent\ncalc_equivalent_alpha\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.add!-Union{Tuple{C}, Tuple{T}, Tuple{InsulatorGroup{T}, Type{C}, Vararg{Any}}} where {T, C<:LineCableModels.DataModel.AbstractInsulatorPart}","page":"API reference","title":"LineCableModels.add!","text":"add!(\n    group::InsulatorGroup{T},\n    part_type::Type{C<:LineCableModels.DataModel.AbstractInsulatorPart},\n    args...;\n    f,\n    kwargs...\n) -> InsulatorGroup{Tg} where Tg\n\n\nAdds a new part to an existing InsulatorGroup object and updates its equivalent electrical parameters.\n\nBehavior:\n\nApply part-level keyword defaults (from Validation.keyword_defaults).\nDefault radius_in to group.radius_ext if absent.\nCompute Tnew = resolve_T(group, radius_in, args..., values(kwargs)..., f).\nIf Tnew === T, mutate in place; else coerce_to_T(group, Tnew) then mutate and return the promoted group.\n\nArguments\n\ngroup: InsulatorGroup object to which the new part will be added.\npart_type: Type of insulator part to add (AbstractInsulatorPart).\nargs...: Positional arguments specific to the constructor of the part_type (AbstractInsulatorPart) [various].\nkwargs...: Named arguments for the constructor including optional values specific to the constructor of the part_type (AbstractInsulatorPart) [various].\n\nReturns\n\nThe function modifies the InsulatorGroup instance in place and does not return a value.\n\nNotes\n\nUpdates shunt_capacitance, shunt_conductance, radius_ext, and cross_section to account for the new part.\nThe radius_in of the new part defaults to the external radius of the existing insulator group if not specified.\n\nwarning: Note\nWhen an AbstractCablePart is provided as radius_in, the constructor retrieves its radius_ext value, allowing the new cable part to be placed directly over the existing part in a layered cable design.\nIn case of uncertain measurements, if the added cable part is of a different type than the existing one, the uncertainty is removed from the radius value before being passed to the new component. This ensures that measurement uncertainties do not inappropriately cascade across different cable parts.\n\nExamples\n\nmaterial_props = Material(1e10, 3.0, 1.0, 20.0, 0.0)\ninsulator_group = InsulatorGroup(Insulator(0.01, 0.015, material_props))\nadd!(insulator_group, Semicon, 0.015, 0.018, material_props)\n\nSee also\n\nInsulatorGroup\nInsulator\nSemicon\ncalc_parallel_equivalent\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.add!-Union{Tuple{T}, Tuple{LineCableSystem{T}, CableDesign, Number, Number}, Tuple{LineCableSystem{T}, CableDesign, Number, Number, Union{Nothing, Dict{String, Int64}}}} where T","page":"API reference","title":"LineCableModels.add!","text":"add!(\n    system::LineCableSystem{T},\n    cable::CableDesign,\n    horz::Number,\n    vert::Number\n) -> LineCableSystem{T} where T\nadd!(\n    system::LineCableSystem{T},\n    cable::CableDesign,\n    horz::Number,\n    vert::Number,\n    conn::Union{Nothing, Dict{String, Int64}}\n) -> LineCableSystem{T} where T\n\n\nConvenience add! that accepts a cable design and coordinates (and optional mapping). Builds a CablePosition and forwards to add!(system, pos).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.add!-Union{Tuple{T}, Tuple{LineCableSystem{T}, CablePosition}} where T","page":"API reference","title":"LineCableModels.add!","text":"add!(\n    system::LineCableSystem{T},\n    pos::CablePosition\n) -> LineCableSystem{T} where T\n\n\nAdds a new cable position to an existing LineCableSystem, updating its phase mapping and cable count. If adding the position introduces a different numeric scalar type, the system is promoted and the promoted system is returned. Otherwise, mutation happens in place.\n\nArguments\n\nsystem: Instance of LineCableSystem to which the cable will be added.\ncable: A CableDesign object defining the cable structure.\nhorz: Horizontal coordinate [m].\nvert: Vertical coordinate [m].\nconn: Dictionary mapping component names to phase indices, or nothing for automatic assignment.\n\nReturns\n\nThe modified LineCableSystem object with the new cable added.\n\nExamples\n\ncable_design = CableDesign(\"example\", nominal_data, components_dict)\n\n# Define coordinates for two cables\nxa, ya = 0.0, -1.0\nxb, yb = 1.0, -2.0\n\n# Create initial system with one cable\ncablepos1 = CablePosition(cable_design, xa, ya, Dict(\"core\" => 1))\ncable_system = LineCableSystem(\"test_case_1\", 1000.0, cablepos1)\n\n# Add second cable to system\nadd!(cable_system, cable_design, xb, yb, Dict(\"core\" => 2))\n\nprintln(cable_system.num_cables)  # Prints: 2\n\nSee also\n\nLineCableSystem\nCablePosition\nCableDesign\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.preview-Tuple{CableDesign}","page":"API reference","title":"LineCableModels.preview","text":"preview(\n    design::CableDesign;\n    x_offset,\n    y_offset,\n    plt,\n    display_plot,\n    display_legend,\n    backend,\n    sz\n) -> Any\n\n\nDisplays the cross-section of a cable design.\n\nArguments\n\ndesign: A CableDesign object representing the cable structure.\nx_offset: Horizontal offset for the plot [m].\ny_offset: Vertical offset for the plot [m].\nplt: An optional Plots.Plot object to use for plotting.\ndisplay_plot: Boolean flag to display the plot after rendering.\ndisplay_legend: Boolean flag to display the legend in the plot.\nbackend: Optional plotting backend to use. If not specified, the function will choose a suitable backend based on the environment (e.g., GR for headless, PlotlyJS for interactive).\nsz: Optional plot dimensions (width, height). Default: (800, 600).\n\nReturns\n\nA Plots.Plot object representing the visualized cable design.\n\nExamples\n\nconductor_group = ConductorGroup(central_conductor)\ninsulator_group = InsulatorGroup(main_insulation)\ncomponent = CableComponent(\"core\", conductor_group, insulator_group)\ndesign = CableDesign(\"example\", component)\ncable_plot = preview(design)  # Cable cross-section is displayed\n\nSee also\n\nCableDesign\nConductorGroup\nInsulatorGroup\nWireArray\nTubular\nStrip\nSemicon\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.preview-Tuple{LineCableSystem}","page":"API reference","title":"LineCableModels.preview","text":"preview(\n    system::LineCableSystem;\n    earth_model,\n    zoom_factor,\n    backend,\n    sz,\n    display_plot\n) -> Plots.Plot\n\n\nDisplays the cross-section of a cable system.\n\nArguments\n\nsystem: A LineCableSystem object containing the cable arrangement.\nearth_model: Optional EarthModel to display earth layers.\nzoom_factor: A scaling factor for adjusting the x-axis limits [dimensionless].\nbackend: Optional plotting backend to use.\nsz: Optional plot dimensions (width, height). Default: (800, 600).\n\nReturns\n\nNothing. Displays a plot of the cable system cross-section with cables, earth layers (if applicable), and the air/earth interface.\n\nExamples\n\nsystem = LineCableSystem(\"test_system\", 1000.0, cable_pos)\nearth_params = EarthModel(f, 100.0, 10.0, 1.0)\npreview(system, earth_model=earth_params, zoom_factor=0.5)\n\nSee also\n\nLineCableSystem\nEarthModel\nCablePosition\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.@_ctor","page":"API reference","title":"LineCableModels.DataModel.@_ctor","text":"Generates a weakly‑typed convenience constructor for a component T. The generated method:\n\nAccepts exactly the positional fields listed in REQ.\nAccepts keyword arguments listed in OPT with defaults DEFS.\nCalls validate!(T, ...) forwarding variables (not defaults),\nComputes the promotion type via _promotion_T(T, ntv, order),\nCoerces only coercive_fields(T) via _coerced_args(T, ntv, Tp, order),\nDelegates to the numeric core T(...) with the coerced positional tuple.\n\nREQ, OPT, and DEFS can be provided as tuple literals or as names of bound constant tuples. order is implicitly (REQ..., OPT...).\n\nArguments\n\nT: Component type (bare name) [dimensionless].\nREQ: Tuple of required positional field names [dimensionless].\nOPT: Tuple of optional keyword field names [dimensionless]. Defaults to ().\nDEFS: Tuple of default values matching OPT [dimensionless]. Defaults to ().\n\nReturns\n\nA method definition for the weakly‑typed constructor.\n\nExamples\n\nconst _REQ_TUBULAR = (:radius_in, :radius_ext, :material_props)\nconst _OPT_TUBULAR = (:temperature,)\nconst _DEFS_TUBULAR = (T₀,)\n\n@_ctor Tubular _REQ_TUBULAR _OPT_TUBULAR _DEFS_TUBULAR\n\n# Expands roughly to:\n# function Tubular(radius_in, radius_ext, material_props; temperature=T₀)\n#   ntv = validate!(Tubular, radius_in, radius_ext, material_props; temperature=temperature)\n#   Tp  = _promotion_T(Tubular, ntv, (:radius_in, :radius_ext, :material_props, :temperature))\n#   args = _coerced_args(Tubular, ntv, Tp, (:radius_in, :radius_ext, :material_props, :temperature))\n#   return Tubular(args...)\n# end\n\nNotes\n\nDefaults supplied in DEFS are escaped into the method signature (evaluated at macro expansion time).\nForwarding into validate! always uses variables (e.g., temperature=temperature), never literal defaults.\nThe macro is hygiene‑aware; identifiers validate!, _promotion_T, _coerced_args, and the type name are properly escaped.\n\nErrors\n\nErrorException if length(OPT) != length(DEFS).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Earth-properties-2","page":"API reference","title":"Earth properties","text":"","category":"section"},{"location":"reference/#LineCableModels.EarthProps.AbstractFDEMFormulation","page":"API reference","title":"LineCableModels.EarthProps.AbstractFDEMFormulation","text":"abstract type AbstractFDEMFormulation\n\nAbstract type representing different frequency-dependent earth models (FDEM). Used in the multi-dispatch implementation of _calc_earth_properties.\n\nCurrently available formulations\n\nCPEarth: Constant properties (CP) model.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, EarthModel}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    model::EarthModel\n)\n\n\nDefines the display representation of a EarthModel object for REPL or text output.\n\nArguments\n\nio: The output stream to write the representation to [IO].\nmime: The MIME type for plain text output [MIME\"text/plain\"].\nmodel: The EarthModel instance to be displayed.\n\nReturns\n\nNothing. Modifies io to format the output.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.coerce_to_T-Union{Tuple{T}, Tuple{EarthLayer, Type{T}}} where T","page":"API reference","title":"LineCableModels.Utils.coerce_to_T","text":"coerce_to_T(layer::EarthLayer, _::Type{T}) -> EarthLayer\n\n\nConverts an EarthLayer{S} to EarthLayer{T} by coercing each stored field to the target element type T and rebuilding the layer via its inner constructor. Scalar and array fields are converted using the generic coerce_to_T machinery.\n\nArguments\n\nlayer: Source Earth layer [dimensionless].\n::Type{T}: Target element type for numeric fields [dimensionless].\n\nReturns\n\nEarthLayer{T} with all numeric state converted to T.\n\nExamples\n\nℓ64 = coerce_to_T(layer, Float64)\nℓM  = coerce_to_T(layer, Measurement{Float64})\n\nSee also\n\ncoerce_to_T\nresolve_T\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.coerce_to_T-Union{Tuple{T}, Tuple{EarthModel, Type{T}}} where T","page":"API reference","title":"LineCableModels.Utils.coerce_to_T","text":"coerce_to_T(model::EarthModel, _::Type{T}) -> EarthModel\n\n\nConverts an EarthModel{S} to EarthModel{T} by reconstructing the model with all layers coerced to the new scalar type T. Layer conversion is delegated to coerce_to_T(::EarthLayer, ::Type), and non-numeric metadata are forwarded unchanged.\n\nArguments\n\nmodel: Source Earth model [dimensionless].\n::Type{T}: Target element type for numeric fields [dimensionless].\n\nReturns\n\nEarthModel{T} rebuilt with each layer and numeric payload converted to T.\n\nExamples\n\nm64 = coerce_to_T(model, Float64)\nmM  = coerce_to_T(model, Measurement{Float64})\n\nSee also\n\ncoerce_to_T\nresolve_T\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.add!-Union{Tuple{T}, Tuple{EarthModel{T}, Vector{T}, T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.add!","text":"add!(\n    model::EarthModel{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    frequencies::Array{T<:Union{Float64, Measurements.Measurement{Float64}}, 1},\n    base_rho_g::Union{Float64, Measurements.Measurement{Float64}},\n    base_epsr_g::Union{Float64, Measurements.Measurement{Float64}},\n    base_mur_g::Union{Float64, Measurements.Measurement{Float64}};\n    t\n) -> EarthModel\n\n\nAdds a new earth layer to an existing EarthModel.\n\nArguments\n\nmodel: Instance of EarthModel to which the new layer will be added.\nfrequencies: Vector of frequency values [Hz].\nbase_rho_g: Base electrical resistivity of the new earth layer [Ω·m].\nbase_epsr_g: Base relative permittivity of the new earth layer [dimensionless].\nbase_mur_g: Base relative permeability of the new earth layer [dimensionless].\nt: Thickness of the new earth layer [m] (default: Inf).\n\nReturns\n\nModifies model in place by appending a new EarthLayer.\n\nNotes\n\nFor horizontal layering (vertical_layers = false):\n\nLayer 1 (air) is always infinite (t = Inf).\nLayer 2 (first earth layer) can be infinite if modeling a homogeneous half-space.\nIf adding a third layer (length(EarthModel.layers) == 3), it can be infinite only if the previous layer is finite.\nNo two successive earth layers (length(EarthModel.layers) > 2) can have infinite thickness.\n\nFor vertical layering (vertical_layers = true):\n\nLayer 1 (air) is always horizontal and infinite at z > 0.\nLayer 2 (first vertical layer) is always infinite in z < 0 and y < 0. The first vertical layer is assumed to always end at y = 0.\nLayer 3 (second vertical layer) can be infinite (establishing a vertical interface at y = 0).\nSubsequent layers can be infinite only if the previous is finite.\nNo two successive vertical layers (length(EarthModel.layers) > 3) can both be infinite.\n\nExamples\n\nfrequencies = [1e3, 1e4, 1e5]\n\n# Define a horizontal model with finite thickness for the first earth layer\nhorz_earth_model = EarthModel(frequencies, 100, 10, 1, t=5)\n\n# Add a second horizontal earth layer\nadd!(horz_earth_model, frequencies, 200, 15, 1, t=10)\nprintln(length(horz_earth_model.layers)) # Output: 3\n\n# The bottom layer should be set to infinite thickness\nadd!(horz_earth_model, frequencies, 300, 15, 1, t=Inf)\nprintln(length(horz_earth_model.layers)) # Output: 4\n\n# Initialize a vertical-layered model with first interface at y = 0.\nvert_earth_model = EarthModel(frequencies, 100, 10, 1, t=Inf, vertical_layers=true)\n\n# Add a second vertical layer at y = 0 (this can also be infinite)\nadd!(vert_earth_model, frequencies, 150, 12, 1, t=Inf)\nprintln(length(vert_earth_model.layers)) # Output: 3\n\n# Attempt to add a third infinite layer (invalid case)\ntry\n\tadd!(vert_earth_model, frequencies, 120, 12, 1, t=Inf)\ncatch e\n\tprintln(e) # Error: Cannot add consecutive vertical layers with infinite thickness.\nend\n\n# Fix: Set a finite thickness to the currently rightmost layer\nvert_earth_model.layers[end].t = 3\n\n# Add the third layer with infinite thickness now\nadd!(vert_earth_model, frequencies, 120, 12, 1, t=Inf)\nprintln(length(vert_earth_model.layers)) # Output: 4\n\nSee also\n\nEarthLayer\n\n\n\n\n\n","category":"method"},{"location":"reference/#Materials-library-2","page":"API reference","title":"Materials library","text":"","category":"section"},{"location":"reference/#DataFrames.DataFrame-Tuple{MaterialsLibrary}","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(library::MaterialsLibrary) -> DataFrame\n\n\nLists the contents of a MaterialsLibrary as a DataFrame.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary to be displayed.\n\nReturns\n\nA DataFrame containing the material properties.\n\nExamples\n\nlibrary = MaterialsLibrary()\ndf = DataFrame(library)\n\nSee also\n\nLineCableModels.ImportExport.save\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.delete!-Tuple{MaterialsLibrary, String}","page":"API reference","title":"Base.delete!","text":"delete!(library::MaterialsLibrary, name::String)\n\n\nRemoves a material from a MaterialsLibrary.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary from which the material will be removed.\nname: Name of the material to be removed.\n\nReturns\n\nThe modified instance of MaterialsLibrary without the specified material.\n\nErrors\n\nThrows an error if the material does not exist in the library.\n\nExamples\n\nlibrary = MaterialsLibrary()\ndelete!(library, \"copper\")\n\nSee also\n\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.get-2","page":"API reference","title":"Base.get","text":"get(\n    library::MaterialsLibrary,\n    name::String\n) -> Union{Nothing, Material}\nget(library::MaterialsLibrary, name::String, default) -> Any\n\n\nRetrieves a material from a MaterialsLibrary by name.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary containing the materials.\nname: Name of the material to retrieve.\n\nReturns\n\nThe requested Material if found, otherwise nothing.\n\nExamples\n\nlibrary = MaterialsLibrary()\nmaterial = get(library, \"copper\")\n\nSee also\n\nadd!\ndelete!\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Dict{String, Material}}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    dict::Dict{String, Material}\n)\n\n\nDefines the display representation of a MaterialsLibrary object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\ndict: The MaterialsLibrary contents to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the library.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, MaterialsLibrary}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    library::MaterialsLibrary\n)\n\n\nDefines the display representation of a MaterialsLibrary object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\nlibrary: The MaterialsLibrary instance to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the library.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Material}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    material::Material\n)\n\n\nDefines the display representation of a Material object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\nmaterial: The Material instance to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the material.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Materials._add_default_materials!-Tuple{MaterialsLibrary}","page":"API reference","title":"LineCableModels.Materials._add_default_materials!","text":"_add_default_materials!(\n    library::MaterialsLibrary\n) -> MaterialsLibrary\n\n\nPopulates a MaterialsLibrary with commonly used materials, assigning predefined electrical and thermal properties.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary to be populated.\n\nReturns\n\nThe modified instance of MaterialsLibrary containing the predefined materials.\n\nExamples\n\nlibrary = MaterialsLibrary()\n_add_default_materials!(library)\n\nSee also\n\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.add!-Tuple{MaterialsLibrary, AbstractString, Material}","page":"API reference","title":"LineCableModels.add!","text":"add!(\n    library::MaterialsLibrary,\n    name::AbstractString,\n    material::Material\n) -> MaterialsLibrary\n\n\nAdds a new material to a MaterialsLibrary.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary where the material will be added.\nname: Name of the material.\nmaterial: Instance of Material containing its properties.\n\nReturns\n\nThe modified instance of MaterialsLibrary with the new material added.\n\nErrors\n\nThrows an error if a material with the same name already exists in the library.\n\nExamples\n\nlibrary = MaterialsLibrary()\nmaterial = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nadd!(library, \"copper\", material)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Utilities-2","page":"API reference","title":"Utilities","text":"","category":"section"},{"location":"reference/#LineCableModels.Utils._CleanMethodList","page":"API reference","title":"LineCableModels.Utils._CleanMethodList","text":"Override DocStringExtensions.format for _CLEANMETHODLIST.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.Utils._coerce_elt_to_T","page":"API reference","title":"LineCableModels.Utils._coerce_elt_to_T","text":"Element‑wise coercion kernel. Converts a single leaf value to the target type T while preserving semantics for Measurement, numeric types, and sentinels.\n\nArguments\n\nx: Input leaf value [dimensionless].\n::Type{T}: Target type [dimensionless].\n\nReturns\n\nValue coerced to the target, according to the rules below.\n\nNotes\n\nNumber → R<:AbstractFloat: uses convert(R, x).\nNumber → M<:Measurement: embeds the number as a zero‑uncertainty measurement (i.e., zero(M) + x).\nMeasurement → M<:Measurement: recreates with the target inner type (value and uncertainty cast to _meas_inner(M)).\nMeasurement → R<:AbstractFloat: drops uncertainty and converts the nominal value.\nnothing and missing pass through unchanged.\nBool, Symbol, String, Function, DataType: passed through unchanged for measurement/real targets.\nFallback: returns x unchanged.\n\nExamples\n\nusing Measurements\n\n_coerce_elt_to_T(1.2, Float32)                         # 1.2f0\n_coerce_elt_to_T(1.2, Measurement{Float64})            # 1.2 ± 0.0\n_coerce_elt_to_T(measurement(2.0, 0.1), Float32)       # 2.0f0\n_coerce_elt_to_T(measurement(2.0, 0.1), Measurement{Float32})  # 2.0 ± 0.1 (Float32 inner)\n_coerce_elt_to_T(missing, Float64)                     # missing\n\nMethods\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:205.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:206.\n\n_coerce_elt_to_T(m, _)\n\ndefined at typecoercion.jl:207.\n\n_coerce_elt_to_T(m, _)\n\ndefined at typecoercion.jl:209.\n\n_coerce_elt_to_T(_, _)\n\ndefined at typecoercion.jl:210.\n\n_coerce_elt_to_T(_, _)\n\ndefined at typecoercion.jl:211.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:212.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:213.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:214.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:215.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LineCableModels.Utils._hascomplex_type","page":"API reference","title":"LineCableModels.Utils._hascomplex_type","text":"Determines whether a Type contains or is a Complex number type somewhere in its structure. The check is recursive over arrays, tuples (including variadic tuples), named tuples, and union types. For concrete struct types, the predicate descends into field types. Guards are present to avoid infinite recursion through known self‑referential types (e.g., Measurements.Measurement).\n\nArguments\n\n::Type: Type to inspect [dimensionless].\n\nReturns\n\nBool indicating whether a Complex type occurs anywhere within the type structure.\n\nNotes\n\nFor AbstractArray{S}, only the element type S is inspected.\nFor Tuple and NamedTuple{N,T}, the parameters are traversed.\nFor Union, both branches are inspected.\nConcrete Measurement types are treated as terminal and are not descended.\n\nExamples\n\n_hascomplex_type(Float64)                  # false\n_hascomplex_type(Complex{Float64})         # true\n_hascomplex_type(Vector{ComplexF64})       # true\n_hascomplex_type(Tuple{Int, ComplexF64})   # true\n\nMethods\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:81.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:82.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:83.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:84.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:86.\n\n_hascomplex_type(T)\n\ndefined at typecoercion.jl:87.\n\n_hascomplex_type(T)\n\ndefined at typecoercion.jl:88.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:94.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LineCableModels.Utils._hasmeas_type-Tuple{Type{<:Measurements.Measurement}}","page":"API reference","title":"LineCableModels.Utils._hasmeas_type","text":"_hasmeas_type(_::Type{<:Measurements.Measurement}) -> Bool\n\n\nDetermines whether a Type contains or is a Measurements.Measurement somewhere in its structure. The check is recursive over arrays, tuples (including variadic tuples), named tuples, and union types. For concrete struct types, the predicate descends into field types. Guards are present to avoid infinite recursion through known self‑contained types (e.g., Complex).\n\nArguments\n\n::Type: Type to inspect [dimensionless].\n\nReturns\n\nBool indicating whether a Measurement occurs anywhere within the type structure.\n\nNotes\n\nFor AbstractArray{S}, only the element type S is inspected.\nFor Tuple and NamedTuple{N,T}, the parameters are traversed.\nFor Union, both branches are inspected.\nConcrete Complex types are treated as terminal and are not descended.\n\nExamples\n\nusing Measurements\n\n_hasmeas_type(Float64)                    # false\n_hasmeas_type(Measurement{Float64})       # true\n_hasmeas_type(Vector{Measurement{Float64}}) # true\n_hasmeas_type(Tuple{Int, Float64})        # false\n_hasmeas_type(Union{Int, Measurement{Float64}}) # true\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils._meas_inner-Union{Tuple{Type{Measurements.Measurement{S}}}, Tuple{S}} where S","page":"API reference","title":"LineCableModels.Utils._meas_inner","text":"_meas_inner(_::Type{Measurements.Measurement{S}}) -> Any\n\n\nExtracts the real inner type S from Measurement{S}.\n\nArguments\n\n::Type{Measurement{S}}: Measurement type wrapper [dimensionless].\n\nReturns\n\nThe inner floating‐point type S [dimensionless].\n\nExamples\n\nusing Measurements\n\nS = _meas_inner(Measurement{Float64})  # Float64\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.is_in_testset-Tuple{}","page":"API reference","title":"LineCableModels.Utils.is_in_testset","text":"is_in_testset() -> Any\n\n\nChecks if the code is running inside a @testset by checking if Test is loaded in the current session and then calling get_testset_depth().\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.@autoexport-Tuple{}","page":"API reference","title":"LineCableModels.Utils.@autoexport","text":"Automatically exports public functions, types, and modules from a module. This is meant for temporary development chores and should never be used in production code.\n\nArguments\n\nNone.\n\nReturns\n\nAn export expression containing all public symbols that should be exported.\n\nNotes\n\nThis macro scans the current module for all defined symbols and automatically generates an export statement for public functions, types, and submodules, excluding built-in and private names. Private names are considered those starting with an underscore ('_'), as per standard Julia conventions.\n\nExamples\n\n@autoexport\n\n\n\n\n\n","category":"macro"},{"location":"reference/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"reference/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages   = [\"reference.md\"]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"tutorials/tutorial2/#Tutorial-2-Building-a-cable-design","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"This tutorial demonstrates how to model a typical medium-voltage single-core power cable using the LineCableModels.jl package. The objective is to build a complete representation of a single-core 18/30 kV cable with a 1000 mm² aluminum conductor and 35 mm² copper screen.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Tutorial outline","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Pages = [\n\t\"tutorial2.md\",\n]\nDepth = 2:3","category":"page"},{"location":"tutorials/tutorial2/#Introduction","page":"Tutorial 2 - Building a cable design","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Single-core power cables have a complex structure consisting of multiple concentric layers, each with specific geometric and material properties – for example, a cable of type NA2XS(FL)2Y 18/30 is shown here. Prior to building actual transmission line models that incorporate cables as part of the transmission system, e.g. for EMT simulations, power flow, harmonics, protection studies etc., it is necessary to determine the base (or DC) electrical parameters of the cable itself.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"This tutorial covers:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Creating a detailed CableDesign with all its components.\nExamining the main electrical parameters (R, L, C) of the cable core ConductorGroup and main InsulatorGroup.\nExamining the equivalent electromagnetic properties of every CableComponent (core, sheath, jacket).\nSaving the cable design to a CablesLibrary for future use.\nAssigning CableDesign objects to a LineCableSystem and exporting the model to PSCAD for EMT analysis.","category":"page"},{"location":"tutorials/tutorial2/#Getting-started","page":"Tutorial 2 - Building a cable design","title":"Getting started","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Load the package and set up the environment:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"using DataFrames\nusing LineCableModels\nfullfile(filename) = joinpath(@__DIR__, filename); #hide\nsetup_logging!(0); #hide\nnothing #hide","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Initialize materials library with default values:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"materials = MaterialsLibrary(add_defaults=true)\nmaterials_df = DataFrame(materials)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"# Alternatively, it can be loaded from the example file built in the previous tutorial:\nload!(materials, file_name = \"materials_library.json\")","category":"page"},{"location":"tutorials/tutorial2/#Cable-dimensions","page":"Tutorial 2 - Building a cable design","title":"Cable dimensions","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The cable under consideration is a medium-voltage, stranded aluminum conductor cable with XLPE insulation, copper wire concentric screens, water-blocking tape, and PE jacket that is rated for 18/30 kV systems. This information is typically found in the cable datasheet and is fully described in the code type under standards HD 620 10C [10] or DIN VDE 0276-620 [11]:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"NA2XS(FL)2Y\n-----------\n│ │   │  │\n│ │   │  └── 2Y: Outer sheath of polyethylene (PE)\n│ │   └── (FL): Longitudinal watertight protection\n│ │\n│ └── 2XS: XLPE insulation with screen of copper wires\n└── NA: Aluminum conductor","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"After some research, it is found that a typical cable of this type has the following configuration:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"num_co_wires = 61  # number of core wires\nnum_sc_wires = 49  # number of screen wires\nd_core = 38.1e-3   # nominal core overall diameter\nd_w = 4.7e-3       # nominal strand diameter of the core\nt_sc_in = 0.6e-3   # nominal internal semicon thickness\nt_ins = 8e-3       # nominal main insulation thickness\nt_sc_out = 0.3e-3  # nominal external semicon thickness\nd_ws = .95e-3      # nominal wire screen diameter\nt_cut = 0.1e-3     # nominal thickness of the copper tape (around wire screens)\nw_cut = 10e-3      # nominal width of copper tape\nt_wbt = .3e-3      # nominal thickness of the water blocking tape\nt_sct = .3e-3      # nominal thickness of the semiconductive tape\nt_alt = .15e-3     # nominal thickness of the aluminum tape\nt_pet = .05e-3     # nominal thickness of the pe face in the aluminum tape\nt_jac = 2.4e-3     # nominal PE jacket thickness\n\nd_overall = d_core #hide\nlayers = [] #hide\npush!(layers, (\"Conductor\", missing, d_overall * 1000)) #hide\nd_overall += 2 * t_sct #hide\npush!(layers, (\"Inner semiconductive tape\", t_sct * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sc_in #hide\npush!(layers, (\"Inner semiconductor\", t_sc_in * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_ins #hide\npush!(layers, (\"Main insulation\", t_ins * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sc_out #hide\npush!(layers, (\"Outer semiconductor\", t_sc_out * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sct #hide\npush!(layers, (\"Outer semiconductive tape\", t_sct * 1000, d_overall * 1000)) #hide\nd_overall += 2 * d_ws #hide\npush!(layers, (\"Wire screen\", d_ws * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_cut #hide\npush!(layers, (\"Copper tape\", t_cut * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_wbt #hide\npush!(layers, (\"Water-blocking tape\", t_wbt * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_alt #hide\npush!(layers, (\"Aluminum tape\", t_alt * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_pet #hide\npush!(layers, (\"PE with aluminum face\", t_pet * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_jac #hide\npush!(layers, (\"PE jacket\", t_jac * 1000, d_overall * 1000)); #hide\nnothing #hide","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The cable structure is summarized in a table for better visualization, with dimensions in milimiters:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"df = DataFrame( #hide\n    layer=first.(layers), #hide\n    thickness=[ #hide\n        ismissing(t) ? \"-\" : round(t, sigdigits=2) for t in getindex.(layers, 2) #hide\n    ], #hide\n    diameter=[round(d, digits=2) for d in getindex.(layers, 3)], #hide\n) #hide","category":"page"},{"location":"tutorials/tutorial2/#Using-the-cable-constructors","page":"Tutorial 2 - Building a cable design","title":"Using the cable constructors","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"note: Object hierarchy\nThe LineCableModels.DataModel module implements a carefully designed component hierarchy that mirrors the physical construction of power cables while maintaining the mathematical relationships required for accurate electrical modeling.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"CableDesign\n├── CableComponent\n│   ├── conductor_group::ConductorGroup <: AbstractConductorPart\n│   │   ├── conductor_props::Material\n│   │   └── layers::Vector{AbstractConductorPart}\n│   │       ├── WireArray\n│   │       ├── Tubular\n│   │       ├── Strip\n│   │       └── …\n│   └── insulator_group::InsulatorGroup <: AbstractInsulatorPart\n│       ├── insulator_props::Material\n│       └── layers::Vector{AbstractInsulatorPart}\n│           ├── Insulator\n│           ├── Semicon\n│           └── …\n⋮\n├── CableComponent\n│   ├── …\n⋮   ⋮","category":"page"},{"location":"tutorials/tutorial2/#Cable-designs","page":"Tutorial 2 - Building a cable design","title":"Cable designs","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The CableDesign object is the main container for all cable components. It encapsulates the entire cable structure and provides methods for calculating global cable properties.","category":"page"},{"location":"tutorials/tutorial2/#Cable-components","page":"Tutorial 2 - Building a cable design","title":"Cable components","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Each CableComponent represents a functional group of the cable (core, sheath, armor, outer), organized into a conductor group and an insulator group with their respective effective material properties. This structure is designed to provide precise calculation of electromagnetic parameters.","category":"page"},{"location":"tutorials/tutorial2/#Conductor-groups","page":"Tutorial 2 - Building a cable design","title":"Conductor groups","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The ConductorGroup object serves as a specialized container for organizing AbstractConductorPart elements in layers. It calculates equivalent resistance (R) and inductance (L) values for all contained conductive elements, handling the complexity of different geometrical arrangements.","category":"page"},{"location":"tutorials/tutorial2/#AbstractConductorPart-implementations","page":"Tutorial 2 - Building a cable design","title":"AbstractConductorPart implementations","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The WireArray object models stranded cores and screens with helical patterns and circular cross-sections.\nThe Tubular object represents simple tubular conductors with straightforward parameter calculations.\nThe Strip object models conductor tapes following helical patterns with rectangular cross-sections.","category":"page"},{"location":"tutorials/tutorial2/#Insulator-groups","page":"Tutorial 2 - Building a cable design","title":"Insulator groups","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The InsulatorGroup object organizes AbstractInsulatorPart elements in concentric layers, calculating the equivalent capacitance (C) and conductance (G) parameters.","category":"page"},{"location":"tutorials/tutorial2/#AbstractInsulatorPart-implementations","page":"Tutorial 2 - Building a cable design","title":"AbstractInsulatorPart implementations","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The Insulator object represents dielectric layers with very high resistivity.\nThe Semicon object models semiconducting layers with intermediate resistivity and high permittivity.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"note: Equivalent circuit parameters\nThe  hierarchical structure enables accurate calculation of equivalent circuit parameters by:Computing geometry-specific parameters at the AbstractConductorPart and AbstractInsulatorPart levels.\nAggregating these into equivalent parameters within ConductorGroup and InsulatorGroup.\nConverting the composite structure into an equivalent coaxial model by matching lumped circuit quantities (R, L, C, G) to effective electromagnetic properties (ρ, ε, µ) at the CableComponent level. The effective properties are stored in dedicated Material objects.","category":"page"},{"location":"tutorials/tutorial2/#Core-and-main-insulation","page":"Tutorial 2 - Building a cable design","title":"Core and main insulation","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The core consists of a 4-layer AAAC stranded conductor with 61 wires arranged in (1/6/12/18/24) pattern, with respective lay ratios of (15/13.5/12.5/11) [12]. Stranded conductors are modeled using the WireArray object, which handles the helical pattern and twisting effects via the calc_helical_params method.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Initialize the conductor object and assign the central wire:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"aluminum\")\ncore = ConductorGroup(WireArray(0.0, Diameter(d_w), 1, 0.0, material))","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"tip: Convenience methods\nThe add! method internally passes the radius_ext of the existing object to the radius_in argument of the new conductor. This enables easy stacking of multiple layers without redundancy. Moreover, the Diameter method is a convenience function that converts the diameter to radius at the constructor level. This maintains alignment with manufacturer specifications while enabling internal calculations to use radius values directly. This approach eliminates repetitive unit conversions and potential sources of implementation error.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Add the subsequent layers of wires and inspect the object:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"add!(core, WireArray, Diameter(d_w), 6, 15.0, material)\nadd!(core, WireArray, Diameter(d_w), 12, 13.5, material)\nadd!(core, WireArray, Diameter(d_w), 18, 12.5, material)\nadd!(core, WireArray, Diameter(d_w), 24, 11.0, material)","category":"page"},{"location":"tutorials/tutorial2/#Inner-semiconductor","page":"Tutorial 2 - Building a cable design","title":"Inner semiconductor","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The inner semiconductor layer ensures uniform electric field distribution between the conductor and insulation, eliminating air gaps and reducing field concentrations. An optional semiconductive tape is often used to ensure core uniformity and enhanced adherence.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"tip: Convenience methods\nThe Thickness type is a convenience wrapper that simplifies layer construction. When used in a constructor, it automatically calculates the outer radius by adding the thickness to the inner radius (which is inherited from the previous layer's outer radius).","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Inner semiconductive tape:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"polyacrylate\")\nmain_insu = InsulatorGroup(Semicon(core, Thickness(t_sct), material))","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Inner semiconductor (1000 Ω.m as per IEC 840):","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"semicon1\")\nadd!(main_insu, Semicon, Thickness(t_sc_in), material)","category":"page"},{"location":"tutorials/tutorial2/#Main-insulation","page":"Tutorial 2 - Building a cable design","title":"Main insulation","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"XLPE (cross-linked polyethylene) is the standard insulation material for modern medium and high voltage cables due to its excellent dielectric properties.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Add the insulation layer:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"pe\")\nadd!(main_insu, Insulator, Thickness(t_ins), material)","category":"page"},{"location":"tutorials/tutorial2/#Outer-semiconductor","page":"Tutorial 2 - Building a cable design","title":"Outer semiconductor","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Similar to the inner semiconductor, the outer semiconductor provides a uniform transition from insulation to the metallic screen.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Outer semiconductor (500 Ω.m as per IEC 840):","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"semicon2\")\nadd!(main_insu, Semicon, Thickness(t_sc_out), material)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Outer semiconductive tape:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"polyacrylate\")\nadd!(main_insu, Semicon, Thickness(t_sct), material)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Group core-related components:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"core_cc = CableComponent(\"core\", core, main_insu)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"With the core parts properly defined, the CableDesign object is initialized with nominal data from the datasheet. This includes voltage ratings and reference electrical parameters that will be used to benchmark the design.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Define the nominal values and instantiate the CableDesign with the core_cc component:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"cable_id = \"18kV_1000mm2\"\ndatasheet_info = NominalData(\n    designation_code=\"NA2XS(FL)2Y\",\n    U0=18.0,                        # Phase-to-ground voltage [kV]\n    U=30.0,                         # Phase-to-phase voltage [kV]\n    conductor_cross_section=1000.0, # [mm²]\n    screen_cross_section=35.0,      # [mm²]\n    resistance=0.0291,              # DC resistance [Ω/km]\n    capacitance=0.39,               # Capacitance [μF/km]\n    inductance=0.3,                 # Inductance in trifoil [mH/km]\n)\ncable_design = CableDesign(cable_id, core_cc, nominal_data=datasheet_info)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"At this point, it becomes possible to preview the cable design:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"plt1 = preview(cable_design)","category":"page"},{"location":"tutorials/tutorial2/#Wire-screens","page":"Tutorial 2 - Building a cable design","title":"Wire screens","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The metallic screen (typically copper) serves multiple purposes:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Provides a return path for fault currents.\nEnsures radial symmetry of the electric field.\nActs as electrical shielding.\nProvides mechanical protection.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Build the wire screens on top of the previous layer:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"lay_ratio = 10.0 # typical value for wire screens\nmaterial = get(materials, \"copper\")\nscreen_con =\n    ConductorGroup(WireArray(main_insu, Diameter(d_ws), num_sc_wires, lay_ratio, material))","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Add the equalizing copper tape wrapping the wire screen:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"add!(screen_con, Strip, Thickness(t_cut), w_cut, lay_ratio, material)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Water blocking tape over screen:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"polyacrylate\")\nscreen_insu = InsulatorGroup(Semicon(screen_con, Thickness(t_wbt), material))","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Group sheath components and assign to design:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"sheath_cc = CableComponent(\"sheath\", screen_con, screen_insu)\nadd!(cable_design, sheath_cc)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Examine the newly added components:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"plt2 = preview(cable_design)","category":"page"},{"location":"tutorials/tutorial2/#Outer-jacket-components","page":"Tutorial 2 - Building a cable design","title":"Outer jacket components","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Modern cables often include an aluminum tape as moisture barrier and PE (polyethylene) outer jacket for mechanical protection.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Add the aluminum foil (moisture barrier):","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"aluminum\")\njacket_con = ConductorGroup(Tubular(screen_insu, Thickness(t_alt), material))","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"PE layer after aluminum foil:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"pe\")\njacket_insu = InsulatorGroup(Insulator(jacket_con, Thickness(t_pet), material))","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"PE jacket (outer mechanical protection):","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"material = get(materials, \"pe\")\nadd!(jacket_insu, Insulator, Thickness(t_jac), material)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"tip: Convenience methods\nTo facilitate data entry, it is possible to call the add! method directly on the ConductorGroup and InsulatorGroup constituents of the component to include, without instantiating the CableComponent first.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Assign the jacket parts directly to the design:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"add!(cable_design, \"jacket\", jacket_con, jacket_insu)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Inspect the finished cable design:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"plt3 = preview(cable_design)","category":"page"},{"location":"tutorials/tutorial2/#Examining-the-cable-parameters-(RLC)","page":"Tutorial 2 - Building a cable design","title":"Examining the cable parameters (RLC)","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"In this section, the cable design is examined and the calculated parameters are compared with datasheet values. LineCableModels.jl provides methods to analyze the design in different levels of detail.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Compare with datasheet information (R, L, C values):","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"core_df = DataFrame(cable_design, :baseparams)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Obtain the equivalent electromagnetic properties of the cable:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"components_df = DataFrame(cable_design, :components)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Get detailed description of all cable parts:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"detailed_df = DataFrame(cable_design, :detailed)","category":"page"},{"location":"tutorials/tutorial2/#Saving-the-cable-design","page":"Tutorial 2 - Building a cable design","title":"Saving the cable design","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"note: Cables library\nDesigns can be saved to a library for future use. The CablesLibrary is a container for storing multiple cable designs, allowing for easy access and reuse in different projects.  Library management is performed using the DataFrame, add!, and save functions.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Store the cable design and inspect the library contents:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"library = CablesLibrary()\nadd!(library, cable_design)\nlibrary_df = DataFrame(library)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Save to file for later use:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"output_file = fullfile(\"cables_library.json\")\nsave(library, file_name=output_file);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial2/#Defining-a-cable-system","page":"Tutorial 2 - Building a cable design","title":"Defining a cable system","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"note: Cable systems\nA cable system is a collection of cables with defined positions, length and environmental characteristics. The LineCableSystem object is the main container for all cable systems, and it allows the definition of multiple cables in different configurations (e.g., trifoil, flat etc.). This object is the entry point for all system-related calculations and analyses.","category":"page"},{"location":"tutorials/tutorial2/#Earth-model","page":"Tutorial 2 - Building a cable design","title":"Earth model","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The earth return path significantly affects cable impedance calculations and needs to be properly modeled. In this tutorial, only a basic model with typical soil properties is defined. This will be further elaborated in the subsequent tutorials.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Define a frequency-dependent earth model (1 Hz to 1 MHz):","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"f = 10.0 .^ range(0, stop=6, length=10)  # Frequency range\nearth_params = EarthModel(f, 100.0, 10.0, 1.0)  # 100 Ω·m resistivity, εr=10, μr=1","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Earth model base (DC) properties:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"earthmodel_df = DataFrame(earth_params)","category":"page"},{"location":"tutorials/tutorial2/#Three-phase-system-in-trifoil-configuration","page":"Tutorial 2 - Building a cable design","title":"Three-phase system in trifoil configuration","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"This section ilustrates the construction of a cable system with three identical cables arranged in a trifoil formation.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Define system center point (underground at 1 m depth) and the trifoil positions","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"x0, y0 = 0.0, -1.0\nxa, ya, xb, yb, xc, yc = trifoil_formation(x0, y0, 0.035);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Initialize the LineCableSystem with the first cable (phase A):","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"cablepos = CablePosition(cable_design, xa, ya,\n    Dict(\"core\" => 1, \"sheath\" => 0, \"jacket\" => 0))\ncable_system = LineCableSystem(\"18kV_1000mm2_trifoil\", 1000.0, cablepos)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Add remaining cables (phases B and C):","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"add!(cable_system, cable_design, xb, yb,\n    Dict(\"core\" => 2, \"sheath\" => 0, \"jacket\" => 0))\nadd!(cable_system, cable_design, xc, yc,\n    Dict(\"core\" => 3, \"sheath\" => 0, \"jacket\" => 0))","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"note: Phase mapping\nThe add! function allows the specification of phase mapping for each cable. The Dict argument maps the cable components to their respective phases, where core is the conductor, sheath is the screen, and jacket is the outer jacket. The values (1, 2, 3) represent the phase numbers (A, B, C) in this case. Components mapped to phase 0 will be Kron-eliminated (grounded). Components set to the same phase will be bundled into an equivalent phase.","category":"page"},{"location":"tutorials/tutorial2/#Cable-system-preview","page":"Tutorial 2 - Building a cable design","title":"Cable system preview","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"In this section the complete three-phase cable system is examined.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Display system details:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"system_df = DataFrame(cable_system)","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Visualize the cross-section of the three-phase system:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"plt4 = preview(cable_system, zoom_factor=0.15)","category":"page"},{"location":"tutorials/tutorial2/#PSCAD-export","page":"Tutorial 2 - Building a cable design","title":"PSCAD export","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"The final step showcases how to export the model for electromagnetic transient simulations in PSCAD.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Export to PSCAD input file:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"output_file = fullfile(\"$(cable_system.system_id)_export.pscx\")\nexport_file = export_data(:pscad, cable_system, earth_params, file_name=output_file);\nnothing #hide","category":"page"},{"location":"tutorials/tutorial2/#Conclusion","page":"Tutorial 2 - Building a cable design","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"This tutorial has demonstrated how to:","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"Create a detailed model of a complex power cable with multiple concentric layers.\nCalculate and analyze the cable base parameters (R, L, C).\nDesign a three-phase cable system in trifoil arrangement.\nExport the model for further analysis in specialized software.","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"LineCableModels.jl provides a powerful framework for accurate power cable modeling with a physically meaningful representation of all cable components. This approach ensures that electromagnetic parameters are calculated with high precision. Now you can go ahead and run these cable simulations like a boss!","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"","category":"page"},{"location":"tutorials/tutorial2/","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"🏠 Back to Tutorials","category":"page"},{"location":"validation/#Validation-module","page":"Validation module","title":"Validation module","text":"","category":"section"},{"location":"validation/#Contents","page":"Validation module","title":"Contents","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Pages = [\"validation.md\"]\nDepth = 3","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"This section documents the validation framework used by component constructors. The design is deterministic, non‑magical, and trait‑driven. The flow is:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"sanitize(Type, args, kwargs)  →  parse(Type, nt)  →  apply rules  →  construct","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"The typed cores accept numbers only. All proxy handling happens in the convenience constructors via validate!.","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"","category":"page"},{"location":"validation/#Architecture","page":"Validation module","title":"Architecture","text":"","category":"section"},{"location":"validation/#Pipeline","page":"Validation module","title":"Pipeline","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"sanitize(::Type{T}, args::Tuple, kwargs::NamedTuple)\nRejects wrong arities: exactly length(required_fields(T)) positionals are expected; optionals must be passed as keywords listed in keyword_fields(T).\nMaps positionals to names using required_fields(T); merges keyword arguments; rejects unknown keywords.\nIf has_radii(T) == true, checks admissibility of raw radius inputs with is_radius_input(T, Val(:radius_in), x) and is_radius_input(T, Val(:radius_ext), x). The default accepts only real, non‑complex numbers; types may extend to allow proxies.\nReturns a raw NamedTuple.\nparse(::Type{T}, nt)\nNormalizes raw inputs to canonical representation (e.g., radius proxies → numeric radii) while preserving domain semantics (e.g., uncertainty reset rules).\nReturns a normalized NamedTuple.\nRule application\n_rules(T) is generated from traits; evaluates over the normalized NamedTuple.\nStandard bundles are injected when traits are true (e.g., for radii: Normalized, Finite, Nonneg, Less).\nPer‑type extras come from extra_rules(T).\nvalidate!(::Type{T}, args...; kwargs...)\nOrchestrates the pipeline. Use this in all convenience constructors.","category":"page"},{"location":"validation/#Traits-(configuration-surface)","page":"Validation module","title":"Traits (configuration surface)","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"has_radii(::Type{T})::Bool — enables the radii rule bundle and raw acceptance checks.\nhas_temperature(::Type{T})::Bool — enables finiteness check on :temperature.\nrequired_fields(::Type{T})::NTuple — positional keys.\nkeyword_fields(::Type{T})::NTuple — keyword argument keys.\ncoercive_fields(::Type{T})::NTuple — values that participate in type promotion and will be coerced (default: required_fields ∪ keyword_fields).\nis_radius_input(::Type{T}, Val(:field), x)::Bool — raw admissibility predicate for radii inputs; extend to allow proxies by field.\nextra_rules(::Type{T})::NTuple{K,Rule} — additional constraints appended to the generated bundle.","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Import before extending:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"import ..Validation: has_radii, has_temperature, required_fields, keyword_fields,\n                     coercive_fields, is_radius_input, parse, extra_rules","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Failing to import will create shadow functions in your module; the engine will not see your methods.","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"","category":"page"},{"location":"validation/#Rules","page":"Validation module","title":"Rules","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Rules are small value types struct <: Rule with an _apply(::Rule, nt, ::Type{T}) method. All rule methods must:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Read data from the normalized NamedTuple nt.\nThrow ArgumentError for logical violations; DomainError for numerical domain violations (non‑finite).\nAvoid allocations; use @inline where appropriate.","category":"page"},{"location":"validation/#Standard-rules","page":"Validation module","title":"Standard rules","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Normalized(:field) — field must be numeric post‑parse.\nFinite(:field) — isfinite must hold.\nNonneg(:field) — value ≥ 0.\nPositive(:field) — value > 0.\nIntegerField(:field) — value isa Integer.\nLess(:a,:b) — strict ordering a < b.\nLessEq(:a,:b) — non‑strict ordering a ≤ b.\nIsA{M}(:field) — type membership check.\nOneOf(:field, set) — membership in a finite set.","category":"page"},{"location":"validation/#Custom-rule-pattern","page":"Validation module","title":"Custom rule pattern","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"struct InRange{T} <: Validation.Rule\n    name::Symbol; lo::T; hi::T\nend\n\n@inline function Validation._apply(r::InRange, nt, ::Type{T}) where {T}\n    x = getfield(nt, r.name)\n    (x isa Number && !(x isa Complex)) || throw(ArgumentError(\"[$(String(nameof(T)))] $(r.name) must be real\"))\n    (r.lo ≤ x ≤ r.hi) || throw(ArgumentError(\"[$(String(nameof(T)))] $(r.name) out of range $(r.lo):$(r.hi), got $(x)\"))\nend","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Attach via extra_rules(::Type{X}) = (InRange(:alpha, 0.0, 1.0), ...).","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"","category":"page"},{"location":"validation/#Example-implementation-—-DataModel.Tubular","page":"Validation module","title":"Example implementation — DataModel.Tubular","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Typed core (numbers only):","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"function Tubular(radius_in::T, radius_ext::T, material_props::Material{T}, temperature::T) where {T<:REALSCALAR}","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Rationale: all proxy resolution must happen before reaching the typed core to avoid duplicate parsing and to keep type promotion deterministic.","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Trait configuration:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"const _REQ_TUBULAR = (:radius_in, :radius_ext, :material_props,)\nconst _OPT_TUBULAR = (:temperature,)\nconst _DEFS_TUBULAR = (T₀,)\n\nValidation.has_radii(::Type{Tubular}) = true\nValidation.has_temperature(::Type{Tubular}) = true\nValidation.required_fields(::Type{Tubular}) = _REQ_TUBULAR\nValidation.keyword_fields(::Type{Tubular}) = _OPT_TUBULAR","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"has_radii = true enables the radii bundle: Normalized(:radius_in), Normalized(:radius_ext), Finite, Nonneg, Less(:radius_in,:radius_ext).\nhas_temperature = true adds Finite(:temperature).\nrequired_fields defines the mandatory positional fields.\nkeyword_fields defines the optional fields that will receive default values.","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Raw proxy acceptance:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Validation.is_radius_input(::Type{Tubular}, ::Val{:radius_in}, x::AbstractCablePart) = true\nValidation.is_radius_input(::Type{Tubular}, ::Val{:radius_ext}, x::Thickness) = true\nValidation.is_radius_input(::Type{Tubular}, ::Val{:radius_ext}, x::Diameter) = true","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"The inner radius may take an existing cable part (its radius_ext); the outer radius may take a Thickness or Diameter wrapper.","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Extra rules:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Validation.extra_rules(::Type{Tubular}) = (IsA{Material}(:material_props),)","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Parsing:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Validation.parse(::Type{Tubular}, nt) = begin\n    rin, rex = _normalize_radii(Tubular, nt.radius_in, nt.radius_ext)\n    (; nt..., radius_in=rin, radius_ext=rex)\nend","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Convenience constructor:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"@_ctor Tubular _REQ_TUBULAR _OPT_TUBULAR _DEFS_TUBULAR","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"This expands to a weakly‑typed method that calls validate!, promotes using _promotion_T, coerces via _coerced_args, and delegates to the numeric core.","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Failure modes intentionally trapped:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Wrong arity, missing keys → sanitize via required_fields.\nString/complex radii → sanitize via default is_radius_input (unless explicitly allowed).\nForgotten parsing after allowing proxies → caught by Normalized rules.\nGeometry violations (radius_in ≥ radius_ext) → Less(:radius_in,:radius_ext).","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"","category":"page"},{"location":"validation/#Template-for-a-new-component","page":"Validation module","title":"Template for a new component","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"# 1) Numeric core (numbers only)\nfunction NewPart(a::T, b::T, material::Material{T}, temperature::T) where {T<:REALSCALAR}\n    # compute derived, then construct\nend\n\n# 2) Trait config\nValidation.has_radii(::Type{NewPart}) = true\nValidation.has_temperature(::Type{NewPart}) = true\nValidation.required_fields(::Type{NewPart}) = (:a, :b, :material)\nValidation.keyword_fields(::Type{NewPart})  = (:temperature,)\n\n# 3) Raw acceptance (extend only what you intend to parse)\nValidation.is_radius_input(::Type{NewPart}, ::Val{:radius_in},  x::AbstractCablePart) = true\nValidation.is_radius_input(::Type{NewPart}, ::Val{:radius_ext}, x::Thickness)        = true\n\n# 4) Extra rules\nValidation.extra_rules(::Type{NewPart}) = (\n    IsA{Material}(:material),\n)\n\n# 5) Parsing (proxy → numeric)\nValidation.parse(::Type{NewPart}, nt) = begin\n    a′, b′ = _normalize_radii(NewPart, nt.a, nt.b)\n    (; nt..., a=a′, b=b′)\nend\n\n# 6) Convenience constructor — generated\n@_ctor NewPart (:a, :b, :material) (:temperature,) (T₀,)","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"","category":"page"},{"location":"validation/#Extending-traits","page":"Validation module","title":"Extending traits","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Traits are just methods. Add traits only when behavior toggles; avoid proliferation.","category":"page"},{"location":"validation/#New-feature-flags","page":"Validation module","title":"New feature flags","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Example: a shielding flag with its own bundle.","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Validation.has_shield(::Type) = false\nValidation.has_shield(::Type{SomeType}) = true","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Extend _rules inside Validation to splice the corresponding checks when has_shield(T) is true.","category":"page"},{"location":"validation/#Field‑specific-admissibility","page":"Validation module","title":"Field‑specific admissibility","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"If only :radius_in should accept proxies, extend the field‑tagged predicate:","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Validation.is_radius_input(::Type{X}, ::Val{:radius_in},  p::AbstractCablePart) = true\nValidation.is_radius_input(::Type{X}, ::Val{:radius_ext}, ::AbstractCablePart)  = false","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"","category":"page"},{"location":"validation/#Testing-guidelines","page":"Validation module","title":"Testing guidelines","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Test arity: (), (1), (1,2) → ArgumentError.\nTest raw type rejections: strings, complex numbers.\nTest proxy acceptance: prior layer objects, Thickness, Diameter when allowed.\nTest parse correctness: outputs numeric and respect uncertainty rules.\nTest rule violations: negative radii, inverted radii, non‑finite values, invalid sets.\nTest constructor round‑trip: convenience path and numeric core produce equivalent instances after coercion.","category":"page"},{"location":"validation/#Usage-notes","page":"Validation module","title":"Usage notes","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Keep all proxy handling in parse. Do not call normalizers in constructors.\nError messages must be terse and contextualized with the component type name.\nPrefer tuple returns and NamedTuple updates to avoid allocations.\nWhen adding rules, benchmark _apply implementations.","category":"page"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"","category":"page"},{"location":"validation/#API-reference","page":"Validation module","title":"API reference","text":"","category":"section"},{"location":"validation/#LineCableModels.Validation","page":"Validation module","title":"LineCableModels.Validation","text":"LineCableModels.Validation\n\nThe Validation module implements a trait-driven, three-phase input checking pipeline for component constructors in LineCableModels. Inputs are first sanitized (arity and shape checks on raw arguments), then parsed (proxy values normalized to numeric radii), and finally validated by a generated set of rules.\n\nOverview\n\nCentralized constructor input handling: sanitize → parse → rule application.\nTrait hooks configure per‑type behavior (has_radii, has_temperature, required_fields, keyword_fields, coercive_fields, etc.).\nRules are small value objects (Rule subtypes) applied to a normalized NamedTuple.\n\nDependencies\n\nBase\nCore\nDocStringExtensions\nForceImport\nLineCableModels\nLineCableModels.Utils\nReexport\n\nExports\n\nFinite\nIntegerField\nIsA\nLess\nLessEq\nNonneg\nNormalized\nOneOf\nPositive\ncoercive_fields\nextra_rules\nhas_radii\nhas_temperature\nis_radius_input\nkeyword_defaults\nkeyword_fields\nparse\nrequired_fields\nsanitize\nvalidate!\n\n\n\n\n\n","category":"module"},{"location":"validation/#LineCableModels.Validation.Finite","page":"Validation module","title":"LineCableModels.Validation.Finite","text":"struct Finite <: LineCableModels.Validation.Rule\n\nRule that enforces finiteness of a numeric field.\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.IntegerField","page":"Validation module","title":"LineCableModels.Validation.IntegerField","text":"struct IntegerField <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be of an integer type.\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.IsA","page":"Validation module","title":"LineCableModels.Validation.IsA","text":"struct IsA{M} <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be isa M for a specified type parameter M.\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Less","page":"Validation module","title":"LineCableModels.Validation.Less","text":"struct Less <: LineCableModels.Validation.Rule\n\nRule that enforces a strict ordering constraint a < b between two fields.\n\na::Symbol: Left‑hand field name.\nb::Symbol: Right‑hand field name.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.LessEq","page":"Validation module","title":"LineCableModels.Validation.LessEq","text":"struct LessEq <: LineCableModels.Validation.Rule\n\nRule that enforces a non‑strict ordering constraint a ≤ b between two fields.\n\na::Symbol: Left‑hand field name.\nb::Symbol: Right‑hand field name.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Nonneg","page":"Validation module","title":"LineCableModels.Validation.Nonneg","text":"struct Nonneg <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be non‑negative (≥ 0).\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Normalized","page":"Validation module","title":"LineCableModels.Validation.Normalized","text":"struct Normalized <: LineCableModels.Validation.Rule\n\nRule that enforces that a field has already been normalized to a numeric value during parsing. Intended to guard that parse has executed and removed proxies.\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.OneOf","page":"Validation module","title":"LineCableModels.Validation.OneOf","text":"struct OneOf{S} <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be in the set S.\n\nname::Symbol\nset::Any\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Positive","page":"Validation module","title":"LineCableModels.Validation.Positive","text":"struct Positive <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be strictly positive (> 0).\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Rule","page":"Validation module","title":"LineCableModels.Validation.Rule","text":"abstract type Rule\n\nBase abstract type for validation rules. All concrete rule types must subtype Rule and provide an _apply(::Rule, nt, ::Type{T}) method that checks a field in the normalized NamedTuple nt for the component type T.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{M}, Tuple{T}, Tuple{LineCableModels.Validation.IsA{M}, Any, Type{T}}} where {T, M}","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.IsA{M},\n    nt,\n    _::Type{T}\n) -> Bool\n\n\nApplies IsA{M} to ensure a field is of type M.\n\nArguments\n\nr: Rule instance parameterized by M [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Finite, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Finite,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies Finite to ensure the target field is a finite real number.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.IntegerField, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.IntegerField,\n    nt,\n    _::Type{T}\n) -> Bool\n\n\nApplies IntegerField to ensure the target field is an Integer.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Less, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Less,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies Less to ensure nt[a] < nt[b].\n\nArguments\n\nr: Rule instance with fields a and b [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.LessEq, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.LessEq,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies LessEq to ensure nt[a] ≤ nt[b].\n\nArguments\n\nr: Rule instance with fields a and b [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Nonneg, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Nonneg,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies Nonneg to ensure the target field is ≥ 0.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Normalized, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Normalized,\n    nt,\n    _::Type{T}\n) -> Bool\n\n\nApplies Normalized to ensure the field has been converted to a numeric value during parsing.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Positive, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Positive,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies Positive to ensure the target field is > 0.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{S}, Tuple{LineCableModels.Validation.OneOf{S}, Any, Type{T}}} where {S, T}","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.OneOf{S},\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies OneOf to ensure the target field is contained in a specified set.\n\nArguments\n\nr: Rule instance with fields name and set [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._ensure_real-Union{Tuple{T}, Tuple{Symbol, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._ensure_real","text":"_ensure_real(field::Symbol, x, _::Type{T})\n\n\nAsserts that x is a real (non‑complex) number. Used by rule implementations before performing numeric comparisons.\n\nArguments\n\nfield: Field name used in diagnostics [dimensionless].\nx: Value to check [dimensionless].\n::Type{T}: Component type for contextualized messages [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\nErrors\n\nArgumentError if x is not isa Number or is a Complex value.\n\nExamples\n\n_ensure_real(:radius_in, 0.01, SomeType)  # ok\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._kwdefaults_nt-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Validation module","title":"LineCableModels.Validation._kwdefaults_nt","text":"_kwdefaults_nt(_::Type{T}) -> NamedTuple\n\n\nInternal helper that canonicalizes keyword_defaults(T) into a NamedTuple keyed by keyword_fields(T). Accepts:\n\n() → returns an empty NamedTuple().\nNamedTuple → returned unchanged.\nTuple → zipped by position with keyword_fields(T); lengths must match.\n\nThis function does not merge user-provided keywords; callers should perform merge(_kwdefaults_nt(T), kwargs) so that user values take precedence.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNamedTuple mapping optional keyword field names to their default values.\n\nErrors\n\nIf keyword_defaults(T) returns a Tuple whose length differs from length(keyword_fields(T)).\nIf keyword_defaults(T) returns a value that is neither () nor a NamedTuple nor a Tuple.\n\nExamples\n\n```julia\n\nSuppose:\n\nkeywordfields(::Type{X})   = (:temperature, :laydirection)\n\nkeyword_defaults(::Type{X}) = (T₀, 1)\n\nkwdefaultsnt(X)  # => (temperature = T₀, lay_direction = 1)\n\nIf defaults are already a NamedTuple:\n\nkeyword_defaults(::Type{Y}) = (temperature = 25.0,)\n\nkwdefaultsnt(Y)  # => (temperature = 25.0,) ````\n\nSee also\n\nkeyword_fields\nkeyword_defaults\nsanitize\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._repr-Tuple{Any}","page":"Validation module","title":"LineCableModels.Validation._repr","text":"_repr(x) -> String\n\n\nReturns a compact textual representation of x for error messages.\n\nArguments\n\nx: Value to represent [dimensionless].\n\nReturns\n\nString with a compact repr [dimensionless].\n\nExamples\n\ns = _repr(:field)  # \":field\"\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._rules-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Validation module","title":"LineCableModels.Validation._rules","text":"_rules(_::Type{T}) -> Tuple\n\n\nGenerates (at compile time, via a @generated function) the tuple of rules to apply for component type T. The result concatenates standard bundles driven by traits and any rules returned by extra_rules(T).\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of Rule instances to apply in order.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._typename-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Validation module","title":"LineCableModels.Validation._typename","text":"_typename(_::Type{T}) -> String\n\n\nReturns the simple (unqualified) name of type T as a String. Utility for constructing diagnostic messages.\n\nArguments\n\n::Type{T}: Type whose name is requested [dimensionless].\n\nReturns\n\nString with the type name [dimensionless].\n\nExamples\n\nname = _typename(Float64)  # \"Float64\"\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.coercive_fields-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Validation module","title":"LineCableModels.Validation.coercive_fields","text":"coercive_fields(_::Type{T}) -> NTuple{6, Symbol}\n\n\nTrait hook listing coercive fields: values that participate in numeric promotion and will be converted to the promoted type by the convenience constructor. Defaults to all fields (required_fields ∪ keyword_fields). Types may override to exclude integers or categorical fields.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of field names that are coerced.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.extra_rules-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.extra_rules","text":"extra_rules(\n    _::Type\n) -> Tuple{LineCableModels.Validation.IsA{Material}}\n\n\nTrait hook providing additional rule instances for a component type. Used to append per‑type constraints after the standard bundles.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of Rule instances.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.has_radii-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.has_radii","text":"has_radii(_::Type) -> Bool\n\n\nTrait hook enabling the annular radii rule bundle on fields :radius_in and :radius_ext (normalized numbers required, finiteness, non‑negativity, and the ordering constraint :radius_in < :radius_ext). It does not indicate the mere existence of radii; it opts in to the annular/coaxial shell geometry checks.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nBool flag.\n\nExamples\n\nValidation.has_radii(Tubular)  # true\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.has_temperature-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.has_temperature","text":"has_temperature(_::Type) -> Bool\n\n\nTrait hook indicating whether a component type uses a :temperature field subject to finiteness checks.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nBool flag.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.is_radius_input-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Val{F}, Any}} where {T, F}","page":"Validation module","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(_::Type{T}, _::Val{F}, x) -> Bool\n\n\nField‑aware acceptance predicate used by sanitize to distinguish inner vs. outer radius policies. The default forwards to is_radius_input(::Type{T}, x) when no field‑specific method is defined.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{F}: Field tag; typically Val(:radius_in) or Val(:radius_ext) [dimensionless].\nx: Candidate value [dimensionless].\n\nReturns\n\nBool indicating acceptance.\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_in), 0.01)   # true\nValidation.is_radius_input(Tubular, Val(:radius_ext), 0.01)  # true\n\nSee also\n\nsanitize\nis_radius_input(::Type{T}, x)\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Validation module","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(_::Type{T}, x) -> Bool\n\n\nTrait predicate that defines admissible raw radius inputs for a component type during sanitize. The default accepts real, non‑complex numbers only. Component code may extend this to allow proxies (e.g., AbstractCablePart, Thickness, Diameter).\n\nArguments\n\n::Type{T}: Component type [dimensionless].\nx: Candidate value [dimensionless].\n\nReturns\n\nBool indicating acceptance.\n\nExamples\n\nValidation.is_radius_input(Tubular, 0.01)  # true by default\nValidation.is_radius_input(Tubular, 1 + 0im)  # false (complex)\n\nSee also\n\nsanitize\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, Number}} where T","page":"Validation module","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_ext},\n    x::Number\n) -> Bool\n\n\nDefault policy for outer radius raw inputs (annular shells): accept real numbers. Proxies are rejected at this stage to prevent zero‑thickness stacking.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_ext}: Field tag for the outer radius [dimensionless].\nx::Number: Candidate value [dimensionless].\n\nReturns\n\nBool indicating acceptance (true for real, non‑complex numbers).\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_ext), 0.02)  # true\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_in}, Number}} where T","page":"Validation module","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_in},\n    x::Number\n) -> Bool\n\n\nDefault policy for inner radius raw inputs: accept real numbers.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_in}: Field tag for the inner radius [dimensionless].\nx::Number: Candidate value [dimensionless].\n\nReturns\n\nBool indicating acceptance (true for real, non‑complex numbers).\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_in), 0.0)   # true\nValidation.is_radius_input(Tubular, Val(:radius_in), 1+0im) # false\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.keyword_defaults-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.keyword_defaults","text":"keyword_defaults(_::Type) -> Tuple{Float64}\n\n\nTrait hook supplying default values for optional keyword fields.\n\nReturn either:\n\na NamedTuple mapping defaults by name (e.g., (temperature = T₀,)), or\na plain Tuple of defaults aligned with keyword_fields(T) (same order + length).\n\nDefaults are applied in sanitize after positional→named merge and before rule application. User-provided keywords always override these defaults.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNamedTuple or Tuple with default keyword values.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.keyword_fields-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.keyword_fields","text":"keyword_fields(_::Type) -> Tuple{Symbol}\n\n\nTrait hook listing optional keyword fields considered by sanitize.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of optional keyword field names.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.parse-Tuple{Type, Any}","page":"Validation module","title":"LineCableModels.Validation.parse","text":"parse(_::Type, nt) -> NamedTuple\n\n\nParses and normalizes raw inputs produced by sanitize into the canonical form expected by rules. Default is identity; component code overrides this to resolve proxy radii to numeric values while preserving uncertainty semantics.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\nnt::NamedTuple: Raw inputs from sanitize [dimensionless].\n\nReturns\n\nNamedTuple with normalized fields (e.g., numeric :radius_in, :radius_ext).\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.required_fields-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.required_fields","text":"required_fields(_::Type) -> Tuple{Symbol, Symbol, Symbol}\n\n\nTrait hook listing required fields that must be present after positional→named merge in sanitize.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of required field names.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T","page":"Validation module","title":"LineCableModels.Validation.sanitize","text":"sanitize(\n    _::Type{T},\n    args::Tuple,\n    kwargs::NamedTuple\n) -> NamedTuple\n\n\nPerforms raw input checks and shapes the input into a NamedTuple without parsing proxies. Responsibilities: arity validation, positional→named mapping, required field presence, and raw acceptance of radius inputs via is_radius_input when has_radii(T) is true.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\nargs::Tuple: Positional arguments as received by the convenience constructor [dimensionless].\nkwargs::NamedTuple: Keyword arguments [dimensionless].\n\nReturns\n\nNamedTuple with raw (unparsed) fields.\n\nErrors\n\nArgumentError on invalid arity, excess positional arguments, missing required fields, or rejected raw radius inputs.\n\nNotes\n\nRequired arguments must be positional; optional arguments must be passed as keywords. Positional arity must equal length(required_fields(T)).\n\nExamples\n\nnt = sanitize(Tubular, (0.01, 0.02, material), (; temperature = 20.0,))\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.validate!-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T","page":"Validation module","title":"LineCableModels.Validation.validate!","text":"validate!(::Type{T}, args...; kwargs...) -> Any\n\n\nRuns the full validation pipeline for a component type: sanitize (arity and raw checks), parse (proxy normalization), then application of the generated rule set. Intended to be called from convenience constructors.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\nargs...: Positional arguments [dimensionless].\nkwargs...: Keyword arguments [dimensionless].\n\nReturns\n\nNamedTuple containing normalized fields ready for construction.\n\nErrors\n\nArgumentError from sanitize or rule checks; DomainError for finiteness violations.\n\nExamples\n\nnt = validate!(Tubular, 0.01, 0.02, material; temperature = 20.0)\n# use nt.radius_in, nt.radius_ext, nt.temperature thereafter\n\nSee also\n\nsanitize\nparse\ncoercive_fields\n\n\n\n\n\n","category":"method"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"","category":"page"},{"location":"validation/#Index","page":"Validation module","title":"Index","text":"","category":"section"},{"location":"validation/","page":"Validation module","title":"Validation module","text":"Pages   = [\"validation.md\"]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"#LineCableModels.jl","page":"Home","title":"LineCableModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LineCableModels.jl is a specialized Julia package designed to compute the electrical parameters of coaxial arbitrarily-layered underground/overhead cables with uncertainty quantification. It focuses on calculating line and cable impedances and admittances in the frequency-domain, accounting for skin effect, insulation properties, and earth-return impedances with frequency-dependent soil models.","category":"page"},{"location":"#Documentation-outline","page":"Home","title":"Documentation outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"tutorials.md\",\n    \"reference.md\",\n    \"bib.md\",\n]\nDepth = 1","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Calculates all base DC parameters of a given cable design (R, L, C and G), for solid, tubular or stranded cores, semiconductors, screens, armors, sheaths, tapes,  and water-blocking materials, with uncertainty propagation using the Measurements.jl package.\nCorrection factors to account for temperature, stranding and twisting effects on the DC resistance [1], GMR [2] and base inductance of stranded cores and wire screens [3].\nExplicit computation of dielectric losses and effective resistances for insulators and semiconductors [4]. Correction of the magnetic constant of insulation layers to account for the solenoid effect introduced by twisted strands [5].\nComputes phase-domain Z/Y matrices for poliphase systems with any number of conductors per phase, and sequence-domain components for three-phase systems, with uncertainty propagation.\nImproved equivalent tubular representation for EMT simulations and direct export to PSCAD format.\nComputes internal impedances of solid, tubular or coaxial multi-layered single-core (SC) cables, using rigorous [6] or equivalent approximate formulas available in industry-standard EMT software.\nComputes earth-return impedances and admittances of underground conductors in homogeneous soil, based on a rigorous solution of Helmholtz equation on the electric Hertzian vector, valid up to 10 MHz [7].","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clone the package and add to the Julia environment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/Electa-Git/LineCableModels.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LineCableModels","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code is provided under the BSD 3-Clause License.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"left\">Documentation generated using <a target=\"_blank\" href=\"https://github.com/JuliaDocs/Documenter.jl\">Documenter.jl</a> and <a target=\"_blank\" href=\"https://github.com/fredrikekre/Literate.jl\">Literate.jl</a>.</p>","category":"page"}]
}
