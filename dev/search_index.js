var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Contents","title":"Tutorials","text":"In this section you will find step-by-step guides to help you get started with the LineCableModels.jl package. These guides are designed to be straightforward and practical, covering the most common use cases and features. \n\nPages = Main.tutorial_pages\nDepth = 1","category":"section"},{"location":"TODO/#TODO-for-LineCableModels.jl","page":"TODO","title":"TODO for LineCableModels.jl","text":"This is a living document intended to track scientific development priorities and research directions for new features, methods and solutions to be included in the package.\n\nFor bugs, features and implementation taks, the Issues page is used.","category":"section"},{"location":"TODO/#Wishlist","page":"TODO","title":"Wishlist","text":"[ ] Pipe-type cables and MoM-SO implementation.","category":"section"},{"location":"TODO/#In-progress","page":"TODO","title":"In progress","text":"[ ] Implementation of frequency-dependent soil properties.\n[ ] Development of novel formulations for cables composed of N concentrical layers, allowing for accurate representations of semiconductor materials.\n[ ] Implementation of an interface to run finite element simulations using Onelab.","category":"section"},{"location":"TODO/#Done","page":"TODO","title":"Done âœ“","text":"[x] Object-oriented data model for cables, conductors, insulations and materials.","category":"section"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"The following docstring standards are generally adopted across the codebase.","category":"section"},{"location":"docstrings/#General-principles","page":"Docstrings","title":"General principles","text":"Placement: Docstrings must immediately precede the code entity (struct, function, module, constant) they describe.\nDelimiter: Use triple double quotes (\"\"\"Docstring content\"\"\") for all docstrings, except for individual struct field documentation.\nConciseness: Avoid redundancy. Information should be presented clearly and concisely in the appropriate section.\nTone: Use formal, precise scientific language suitable for technical documentation. Avoid contractions, colloquialisms, and ambiguous phrasing.","category":"section"},{"location":"docstrings/#Physical-unit-formatting","page":"Docstrings","title":"Physical unit formatting","text":"All variables corresponding to physical quantities must be annotated with their SI units and according to the following rules:\n\nMandatory units: ALL arguments, return values, struct fields, and constants representing physical quantities MUST have their SI units specified.\nDimensionless quantities: Physical quantities that are dimensionless MUST be explicitly marked as \\\\[dimensionless\\\\].\nNon-physical quantities: Do not add unit annotations to arguments, variables, or fields that do not represent physical quantities (e.g., counters, flags, indices).\nStandard format: Units MUST be enclosed in double-backslash escaped square brackets: \\\\[unit\\\\].\nCorrect: \\\\[m\\\\], \\\\[Hz\\\\], \\\\[Î©\\\\], \\\\[H/m\\\\], \\\\[dimensionless\\\\]\nIncorrect: [m], \\[m], m (as a standalone unit identifier)\nException for example comments: Inside `julia code blocks within the # Examples section, use regular (non-escaped) square brackets for units within comments.\nCorrect: julia result = calculation(10.0) # Output in [m]\nIncorrect: julia result = calculation(10.0) # Output in \\\\[m\\\\]\nCommon units: Use standard SI abbreviations (e.g., m, s, kg, A, K, mol, cd, Hz, N, Pa, J, W, C, V, F, Î©, S, T, H, lm, lx, Bq, Gy, Sv, Â°C). Use the Unicode middle dot Â· for multiplication where appropriate (e.g., \\\\[Î©Â·m\\\\]).","category":"section"},{"location":"docstrings/#Mathematical-formulation-formatting","page":"Docstrings","title":"Mathematical formulation formatting","text":"Requirement: Mathematical formulas rendered using LaTeX are MANDATORY only for functions/methods whose names start with the prefix calc_.\nLocation: For calc_ functions, the LaTeX formula MUST be placed within a math ... block inside the # Notes section.\nForbidden: Do NOT include math blocks or LaTeX formulations for any functions or methods not prefixed with calc_.\nLaTeX escaping: Within documentation text AND inside math blocks, all LaTeX commands (like \\frac, \\mu) MUST have their backslashes escaped (\\\\).\nCorrect: \\\\mu_r, math \\\\frac{a}{b}\nIncorrect: \\mu_r, math \\frac{a}{b}","category":"section"},{"location":"docstrings/#Documentation-templates","page":"Docstrings","title":"Documentation templates","text":"The subsections below contain templates for different types of code elements.","category":"section"},{"location":"docstrings/#Structs","page":"Docstrings","title":"Structs","text":"Main docstring: Use $(TYPEDEF) for the signature and $(TYPEDFIELDS) to list the fields automatically. Provide a concise description of the struct purpose.\n  ```julia\n  \"\"\"\n  $(TYPEDEF)\n\n  Represents a physical entity with specific properties...\n\n  $(TYPEDFIELDS)\n  \"\"\"\n  struct StructName\n      # Field definitions follow\n  end\n  ```\nField documentation:\nPlace directly above each field definition.\nUse single-line double quotes: \"Description with units \\\\[unit\\\\] or \\\\[dimensionless\\\\] if applicable.\"\nDo NOT use \"\"\" \"\"\" block quotes or inline comments (#) for documenting struct fields.","category":"section"},{"location":"docstrings/#Constructors-(inside-or-outside-structs)","page":"Docstrings","title":"Constructors (inside or outside structs)","text":"ALL constructors MUST be documented using the @doc macro placed immediately before the function keyword or the compact assignment form (TypeName(...) = ...). This applies even to default constructors if explicitly defined.\nFormat: Use $(TYPEDSIGNATURES). Include standard sections (Arguments, Returns, Examples).\n  ````julia\n  @doc \"\"\"\n  $(TYPEDSIGNATURES)\n\n  Constructs a [`StructName`](@ref) instance.\n\n  # Arguments\n\n  - `arg_name`: Description including units `\\\\[unit\\\\]` if physical.\n\n  # Returns\n\n  - A [`StructName`](@ref) object. [Optionally add details about initialization].\n\n  # Examples\n\n  ```julia\n  instance = $(FUNCTIONNAME)(...) # Provide meaningful example values\n  ```\n\n  \"\"\"\n  function StructName(...)\n      # Implementation\n  end\n  ````","category":"section"},{"location":"docstrings/#Functions-/-methods","page":"Docstrings","title":"Functions / methods","text":"Format: Start with $(TYPEDSIGNATURES). Follow the section order described.\n  ````julia\n  \"\"\"\n  $(TYPEDSIGNATURES)\n\n  Concise description of the function's purpose.\n\n  # Arguments\n\n  - `arg1`: Description, units `\\\\[unit\\\\]` if physical. Specify `Default: value` if applicable.\n  - `arg2`: Description, `\\\\[dimensionless\\\\]` if physical and dimensionless.\n\n  # Returns\n\n  - Description of the return value, including units `\\\\[unit\\\\]` if physical. Document multiple return values individually if using tuples.\n\n  # Notes  (OPTIONAL - MANDATORY ONLY for `calc_` functions for the formula)\n\n  [For `calc_` functions: Explanation and formula]\n  ```math\n  \\\\LaTeX... \\\\escaped... \\\\formula...\n  ```\n\n  # Errors \n\n  - Describes potential errors or exceptions thrown.\n\n  # Examples\n\n  ```julia\n  result = $(FUNCTIONNAME)(...) # Use representative values. Add expected output comment.\n  # Example: result = $(FUNCTIONNAME)(0.02, 0.01, 1.0) # Expected output: ~0.0135 [m]\n  ```\n\n  # See also \n\n  - [`related_package_function`](@ref)\n  \"\"\"\n  function function_name(...)\n      # Implementation\n  end\n  ````\nSection order:\nDescription (no heading)\n# Arguments\n# Returns\n# Notes (Only if needed; mandatory for calc_ functions)\n# Errors (Only if needed)\n# Examples\n# See also (Only if needed)\nSpacing: Ensure exactly one blank line separates the description from # Arguments and precedes every subsequent section heading.\nExamples: Use the $(FUNCTIONNAME) macro instead of hardcoding the function name. Use meaningful, realistic input values. Include expected output or behavior in a comment, using non-escaped brackets for units ([unit]).\nSee also: Only link to other functions within this package using [function_name](@ref). Do not link to Base Julia functions or functions from external packages unless absolutely necessary for context. Only include if the linked function provides relevant context or alternatives.","category":"section"},{"location":"docstrings/#Modules","page":"Docstrings","title":"Modules","text":"Format: The first line must be the module name indented by four spaces. Use $(IMPORTS) and $(EXPORTS) literals.\n  ````julia\n  \"\"\"\n      ModuleName\n\n  Brief description of the module purpose within the broader package (e.g., for [`Package.jl`](index.md)).\n\n  # Overview\n\n  - Bullet points describing key capabilities or features provided by the module.\n\n  # Dependencies\n\n  $(IMPORTS)\n\n  # Exports\n\n  $(EXPORTS)\n  \"\"\"\n  module ModuleName\n      # Contents\n  end\n  ````","category":"section"},{"location":"docstrings/#Constants","page":"Docstrings","title":"Constants","text":"Format: Use a single-line docstring with double quotes (\"...\"). Include a brief description, the symbol of the constant if standard (e.g., Î¼â‚€), its value, and its units using the \\\\[unit\\\\] format.\n  ```julia\n  \"Magnetic constant (vacuum permeability), Î¼â‚€ = 4Ï€ * 1e-7 \\\\[H/m\\\\]].\"\n  const Î¼â‚€ = 4Ï€ * 1e-7\n  ```","category":"section"},{"location":"docstrings/#Common-mistakes-to-avoid","page":"Docstrings","title":"Common mistakes to avoid","text":"Double-check the docstrings to avoid these common errors:\n\nMissing @doc for constructors: ALL constructors require the @doc macro before their definition.\nIncorrect struct field docstrings: Use single-line \"...\" above the field, not block \"\"\"...\"\"\" quotes or inline # comments.\nIncorrect section order: Follow the specified order for function docstring sections precisely.\nHard-coding function names in examples: Always use $(FUNCTIONNAME).\nIncorrect unit formatting: Ensure \\\\[unit\\\\] syntax is used everywhere except comments within Examples blocks ([unit]). Double-check escaping (\\\\) for LaTeX.\nAdding math formulas to non-calc_ functions: Math blocks are only for functions prefixed with calc_.","category":"section"},{"location":"tutorials/tutorial3/#Tutorial-3-Computing-line-parameters","page":"Tutorial 3 - Computing line parameters","title":"Tutorial 3 - Computing line parameters","text":"This case file demonstrates how to model an armored high-voltage single-core power cable using the LineCableModels.jl package. The objective is to build a complete representation of a single-core 525 kV cable with a 1600 mmÂ² copper conductor, 1.2 mm tubular lead sheath and 68 x 6 mm galvanized steel armor, based on the design described in [13].\n\nTutorial outline\n\nPages = [\n\t\"tutorial3.md\",\n]\nDepth = 2:3","category":"section"},{"location":"tutorials/tutorial3/#Introduction","page":"Tutorial 3 - Computing line parameters","title":"Introduction","text":"HVDC cables are constructed around a central conductor enclosed by a triple-extruded insulation system (inner/outer semi-conductive layers and main insulation). A metallic screen and protective outer sheath are then applied for land cables. Subsea designs add galvanized steel wire armor over this structure to provide mechanical strength against water pressure. A reference design for a 525 kV HVDC cable is shown here.","category":"section"},{"location":"tutorials/tutorial3/#Getting-started","page":"Tutorial 3 - Computing line parameters","title":"Getting started","text":"Load the package and set up the environment:\n\nusing LineCableModels\nusing LineCableModels.Engine.FEM\nusing LineCableModels.Engine.Transforms: Fortescue\nusing DataFrames\nusing Printf\nfullfile(filename) = joinpath(@__DIR__, filename); #hide\nset_verbosity!(0); #hide\nset_backend!(:gl); #hide\nnothing #hide\n\nInitialize library and the required materials for this design:\n\nmaterials = MaterialsLibrary(add_defaults = true)\n\nInspect the contents of the materials library:\n\nmaterials_df = DataFrame(materials)","category":"section"},{"location":"tutorials/tutorial3/#Cable-dimensions","page":"Tutorial 3 - Computing line parameters","title":"Cable dimensions","text":"The cable under consideration is a high-voltage, stranded copper conductor cable with XLPE insulation, water-blocking tape, lead tubular screens, PE inner sheath, PP bedding, steel armor and PP jacket, rated for 525 kV HVDC systems. This information is typically found in the cable datasheet and is based on the design studied in [13].\n\nThe cable is found to have the following configuration:\n\nnum_co_wires = 127 # number of core wires\nnum_ar_wires = 68  # number of armor wires\nd_core = 0.0463    # nominal core overall diameter\nd_w = 3.6649e-3    # nominal strand diameter of the core (minimum value to match datasheet)\nt_sc_in = 2e-3     # nominal internal semicon thickness\nt_ins = 26e-3      # nominal main insulation thickness\nt_sc_out = 1.8e-3  # nominal external semicon thickness\nt_wbt = .3e-3      # nominal thickness of the water blocking tape\nt_sc = 3.3e-3      # nominal lead screen thickness\nt_pe = 3e-3        # nominal PE inner sheath thickness\nt_bed = 3e-3       # nominal thickness of the PP bedding\nd_wa = 5.827e-3    # nominal armor wire diameter\nt_jac = 10e-3      # nominal PP jacket thickness\n\nd_overall = d_core #hide\nlayers = [] #hide\npush!(layers, (\"Conductor\", missing, d_overall * 1000)) #hide\nd_overall += 2 * t_sc_in #hide\npush!(layers, (\"Inner semiconductor\", t_sc_in * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_ins #hide\npush!(layers, (\"Main insulation\", t_ins * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sc_out #hide\npush!(layers, (\"Outer semiconductor\", t_sc_out * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_wbt #hide\npush!(layers, (\"Swellable tape\", t_wbt * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sc #hide\npush!(layers, (\"Lead screen\", t_sc * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_pe #hide\npush!(layers, (\"PE inner sheath\", t_pe * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_bed #hide\npush!(layers, (\"PP bedding\", t_bed * 1000, d_overall * 1000)) #hide\nd_overall += 2 * d_wa #hide\npush!(layers, (\"Stranded wire armor\", d_wa * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_jac #hide\npush!(layers, (\"PP jacket\", t_jac * 1000, d_overall * 1000)); #hide\nnothing #hide\n\nThe cable structure is summarized in a table for better visualization, with dimensions in milimiters:\n\ndf = DataFrame( #hide\n\tlayer = first.(layers), #hide\n\tthickness = [ #hide\n\t\tismissing(t) ? \"-\" : round(t, sigdigits = 2) for t in getindex.(layers, 2) #hide\n\t], #hide\n\tdiameter = [round(d, digits = 2) for d in getindex.(layers, 3)], #hide\n) #hide","category":"section"},{"location":"tutorials/tutorial3/#Core-and-main-insulation","page":"Tutorial 3 - Computing line parameters","title":"Core and main insulation","text":"Initialize the conductor object and assign the central wire:\n\nmaterial = get(materials, \"copper\")\ncore = ConductorGroup(CircStrands(0.0, Diameter(d_w), 1, 0.0, material))\n\nAdd the subsequent layers of wires and inspect the object:\n\nn_strands = 6 # Strands per layer\nn_layers = 6 # Layers of strands\nfor i in 1:n_layers\n\tadd!(core, CircStrands, Diameter(d_w), i * n_strands, 11.0, material)\nend\ncore","category":"section"},{"location":"tutorials/tutorial3/#Inner-semiconductor","page":"Tutorial 3 - Computing line parameters","title":"Inner semiconductor","text":"Inner semiconductor (1000 Î©.m as per IEC 840):\n\nmaterial = get(materials, \"semicon1\")\nmain_insu = InsulatorGroup(Semicon(core, Thickness(t_sc_in), material))","category":"section"},{"location":"tutorials/tutorial3/#Main-insulation","page":"Tutorial 3 - Computing line parameters","title":"Main insulation","text":"Add the insulation layer:\n\nmaterial = get(materials, \"pe\")\nadd!(main_insu, Insulator, Thickness(t_ins), material)","category":"section"},{"location":"tutorials/tutorial3/#Outer-semiconductor","page":"Tutorial 3 - Computing line parameters","title":"Outer semiconductor","text":"Outer semiconductor (500 Î©.m as per IEC 840):\n\nmaterial = get(materials, \"semicon2\")\nadd!(main_insu, Semicon, Thickness(t_sc_out), material)\n\nWater blocking (swellable) tape:\n\nmaterial = get(materials, \"polyacrylate\")\nadd!(main_insu, Semicon, Thickness(t_wbt), material)\n\nGroup core-related components:\n\ncore_cc = CableComponent(\"core\", core, main_insu)\n\ncable_id = \"525kV_1600mm2\"\ndatasheet_info = NominalData(\n\tdesignation_code = \"(N)2XH(F)RK2Y\",\n\tU0 = 500.0,                        # Phase (pole)-to-ground voltage [kV]\n\tU = 525.0,                         # Phase (pole)-to-phase (pole) voltage [kV]\n\tconductor_cross_section = 1600.0,  # [mmÂ²]\n\tscreen_cross_section = 1000.0,     # [mmÂ²]\n\tresistance = nothing,              # DC resistance [Î©/km]\n\tcapacitance = nothing,             # Capacitance [Î¼F/km]\n\tinductance = nothing,              # Inductance in trifoil [mH/km]\n)\ncable_design = CableDesign(cable_id, core_cc, nominal_data = datasheet_info)","category":"section"},{"location":"tutorials/tutorial3/#Lead-screen/sheath","page":"Tutorial 3 - Computing line parameters","title":"Lead screen/sheath","text":"Build the wire screens on top of the previous layer:\n\nmaterial = get(materials, \"lead\")\nscreen_con = ConductorGroup(Tubular(main_insu, Thickness(t_sc), material))\n\nPE inner sheath:\n\nmaterial = get(materials, \"pe\")\nscreen_insu = InsulatorGroup(Insulator(screen_con, Thickness(t_pe), material))\n\nPP bedding:\n\nmaterial = get(materials, \"pp\")\nadd!(screen_insu, Insulator, Thickness(t_bed), material)\n\nGroup sheath components and assign to design:\n\nsheath_cc = CableComponent(\"sheath\", screen_con, screen_insu)\nadd!(cable_design, sheath_cc)","category":"section"},{"location":"tutorials/tutorial3/#Armor-and-outer-jacket-components","page":"Tutorial 3 - Computing line parameters","title":"Armor and outer jacket components","text":"Add the armor wires on top of the previous layer:\n\nlay_ratio = 10.0 # typical value for wire screens\nmaterial = get(materials, \"steel\")\narmor_con = ConductorGroup(\n\tCircStrands(screen_insu, Diameter(d_wa), num_ar_wires, lay_ratio, material))\n\nPP layer after armor:\n\nmaterial = get(materials, \"pp\")\narmor_insu = InsulatorGroup(Insulator(armor_con, Thickness(t_jac), material))\n\nAssign the armor parts directly to the design:\n\nadd!(cable_design, \"armor\", armor_con, armor_insu)\n\nInspect the finished cable design:\n\nplt1, _ = preview(cable_design)\nplt1 #hide","category":"section"},{"location":"tutorials/tutorial3/#Examining-the-cable-parameters-(RLC)","page":"Tutorial 3 - Computing line parameters","title":"Examining the cable parameters (RLC)","text":"Summarize DC lumped parameters (R, L, C):\n\ncore_df = DataFrame(cable_design, :baseparams)\n\nObtain the equivalent electromagnetic properties of the cable:\n\ncomponents_df = DataFrame(cable_design, :components)","category":"section"},{"location":"tutorials/tutorial3/#Saving-the-cable-design","page":"Tutorial 3 - Computing line parameters","title":"Saving the cable design","text":"Load an existing CablesLibrary file or create a new one:\n\nlibrary = CablesLibrary()\nlibrary_file = fullfile(\"cables_library.json\")\nload!(library, file_name = library_file)\nadd!(library, cable_design)\nlibrary_df = DataFrame(library)\n\nSave to file for later use:\n\nsave(library, file_name = library_file);\nnothing #hide","category":"section"},{"location":"tutorials/tutorial3/#Defining-a-cable-system","page":"Tutorial 3 - Computing line parameters","title":"Defining a cable system","text":"","category":"section"},{"location":"tutorials/tutorial3/#Earth-model","page":"Tutorial 3 - Computing line parameters","title":"Earth model","text":"Define a constant frequency earth model:\n\nf = [1e-3] # Near DC frequency for the analysis\nearth_params = EarthModel(f, 100.0, 10.0, 1.0)  # 100 Î©Â·m resistivity, Îµr=10, Î¼r=1\n\nEarth model base (DC) properties:\n\nearthmodel_df = DataFrame(earth_params)","category":"section"},{"location":"tutorials/tutorial3/#Underground-bipole-configuration","page":"Tutorial 3 - Computing line parameters","title":"Underground bipole configuration","text":"Define the coordinates for both cables:\n\nxp, xn, y0 = -0.5, 0.5, -1.0;\nnothing #hide\n\nInitialize the LineCableSystem with positive pole:\n\ncablepos = CablePosition(cable_design, xp, y0,\n\tDict(\"core\" => 1, \"sheath\" => 0, \"armor\" => 0))\ncable_system = LineCableSystem(\"525kV_1600mm2_bipole\", 1000.0, cablepos)\n\nAdd the other pole (negative) to the system:\n\nadd!(cable_system, cable_design, xn, y0,\n\tDict(\"core\" => 2, \"sheath\" => 0, \"armor\" => 0))","category":"section"},{"location":"tutorials/tutorial3/#Cable-system-preview","page":"Tutorial 3 - Computing line parameters","title":"Cable system preview","text":"In this section the complete bipole cable system is examined.\n\nDisplay system details:\n\nsystem_df = DataFrame(cable_system)\n\nVisualize the cross-section of the three-phase system:\n\nplt2, _ = preview(cable_system, earth_model = earth_params, zoom_factor = 2.0)\nplt2 #hide","category":"section"},{"location":"tutorials/tutorial3/#PSCAD-and-ATPDraw-export","page":"Tutorial 3 - Computing line parameters","title":"PSCAD & ATPDraw export","text":"Export to PSCAD input file:\n\noutput_file = fullfile(\"pscad_export.pscx\")\nexport_file = export_data(:pscad, cable_system, earth_params, file_name = output_file);\nnothing #hide\n\nExport to ATPDraw project file (XML):\n\noutput_file = fullfile(\"atp_export.xml\")\nexport_file = export_data(:atp, cable_system, earth_params, file_name = output_file);\nnothing #hide","category":"section"},{"location":"tutorials/tutorial3/#FEM-calculations","page":"Tutorial 3 - Computing line parameters","title":"FEM calculations","text":"Define a LineParametersProblem with the cable system and earth model\n\nproblem = LineParametersProblem(\n\tcable_system,\n\ttemperature = 20.0,  # Operating temperature\n\tearth_props = earth_params,\n\tfrequencies = f,   # Frequency for the analysis\n);\nnothing #hide\n\nEstimate domain size based on skin depth in the earth\n\ndomain_radius = 10.0; #calc_domain_size(earth_params, f);\nnothing #hide\n\nDefine custom mesh transitions around each cable\n\nmesh_transition1 = MeshTransition(\n\tcable_system,\n\t[1],\n\tr_min = 0.08,\n\tr_length = 0.25,\n\tmesh_factor_min = 0.01 / (domain_radius / 5),\n\tmesh_factor_max = 0.25 / (domain_radius / 5),\n\tn_regions = 5)\n\nmesh_transition2 = MeshTransition(\n\tcable_system,\n\t[2],\n\tr_min = 0.08,\n\tr_length = 0.25,\n\tmesh_factor_min = 0.01 / (domain_radius / 5),\n\tmesh_factor_max = 0.25 / (domain_radius / 5),\n\tn_regions = 5);\nnothing #hide\n\nDefine runtime options\n\nopts = (\n\tforce_remesh = true,                # Force remeshing\n\tforce_overwrite = true,             # Overwrite existing files\n\tplot_field_maps = false,            # Do not compute/ plot field maps\n\tmesh_only = true,                  # Preview the mesh\n\tsave_path = fullfile(\"fem_output\"), # Results directory\n\tkeep_run_files = true,              # Archive files after each run\n\tverbosity = 1,                      # Verbosity\n);\nnothing #hide\n\nDefine the FEM formulation with the specified parameters\n\nF = FormulationSet(:FEM,\n\timpedance = Darwin(),\n\tadmittance = Electrodynamics(),\n\tdomain_radius = domain_radius,\n\tdomain_radius_inf = domain_radius * 1.25,\n\telements_per_length_conductor = 1,\n\telements_per_length_insulator = 2,\n\telements_per_length_semicon = 1,\n\telements_per_length_interfaces = 5,\n\tpoints_per_circumference = 16,\n\tmesh_size_min = 1e-6,\n\tmesh_size_max = domain_radius / 5,\n\nmeshtransitions = [meshtransition1, \tmesh_transition2],\n\n\tmesh_size_default = domain_radius / 10,\n\tmesh_algorithm = 5,\n\tmesh_max_retries = 20,\n\tmaterials = materials,\n\toptions = opts,\n);\nnothing #hide","category":"section"},{"location":"tutorials/tutorial3/#Run-the-FEM-solver","page":"Tutorial 3 - Computing line parameters","title":"Run the FEM solver","text":"@time ws, p = compute!(problem, F);","category":"section"},{"location":"tutorials/tutorial3/#Display-computation-results","page":"Tutorial 3 - Computing line parameters","title":"Display computation results","text":"per_km(p, 1; mode = :RLCG, tol = 1e-9)","category":"section"},{"location":"tutorials/tutorial3/#Export-ZY-matrices-to-ATPDraw","page":"Tutorial 3 - Computing line parameters","title":"Export ZY matrices to ATPDraw","text":"outputfile = fullfile(\"ZYexport.xml\") exportfile = exportdata(:atp, p; filename = outputfile, cablesystem = cablesystem);","category":"section"},{"location":"tutorials/tutorial3/#Obtain-the-symmetrical-components-via-Fortescue-transformation","page":"Tutorial 3 - Computing line parameters","title":"Obtain the symmetrical components via Fortescue transformation","text":"Tv, p012 = Fortescue(tol = 1e-5)(p);","category":"section"},{"location":"tutorials/tutorial3/#Inspect-the-transformed-matrices","page":"Tutorial 3 - Computing line parameters","title":"Inspect the transformed matrices","text":"per_km(p012, 1; mode = :ZY, tol = 1e-9)","category":"section"},{"location":"tutorials/tutorial3/#Or-the-corresponding-lumped-circuit-quantities","page":"Tutorial 3 - Computing line parameters","title":"Or the corresponding lumped circuit quantities","text":"per_km(p012, 1; mode = :RLCG, tol = 1e-9)\n\nusing LineCableModels.Utils: to_nominal\nusing LineCableModels.DataModel: calc_circstrands_coords\n\nfunction collect_layer_geometry(design::CableDesign;\n\tx_offset::Real = 0.0,\n\ty_offset::Real = 0.0,\n)\n\tlayer_no = Ref(0)\n\tout = Vector{\n\t\tNamedTuple{(:layer, :type, :element, :x, :y, :radius_out, :rin, :rext),\n\t\t\tTuple{Int, String, Int, Float64, Float64, Float64, Float64, Float64}},\n\t}()\n\n\tfunction push_layer!(layer, x0, y0)\n\t\tif layer isa CircStrands\n\t\t\tlayer_no[] += 1\n\t\t\trwire = to_nominal(layer.radius_wire)\n\t\t\tlay_r = layer.num_wires == 1 ? 0.0 : to_nominal(layer.radius_in)\n\t\t\tcoords = calc_circstrands_coords(layer.num_wires, rwire, lay_r; C = (x0, y0))\n\t\t\tfor (i, (x, y)) in enumerate(coords)\n\t\t\t\tpush!(out, (layer_no[], \"circstrands\", i, x, y, rwire, NaN, NaN))\n\t\t\tend\n\t\telseif layer isa Strip || layer isa Tubular || layer isa Semicon ||\n\t\t\t   layer isa Insulator\n\t\t\tlayer_no[] += 1\n\t\t\trin = to_nominal(layer.radius_in);\n\t\t\trex = to_nominal(layer.radius_ext)\n\t\t\ttyp = lowercase(string(nameof(typeof(layer))))\n\t\t\tpush!(out, (layer_no[], typ, 1, x0, y0, rex, rin, rex))\n\t\telseif layer isa ConductorGroup\n\t\t\tfor sub in layer.layers\n\t\t\t\tpush_layer!(sub, x0, y0)\n\t\t\tend\n\t\telse\n\t\t\t@warn \"Skipping layer $(typeof(layer)) in geometry collection\"\n\t\tend\n\tend\n\n\tfor comp in design.components\n\t\tfor layer in comp.conductor_group.layers\n\t\t\tpush_layer!(layer, x_offset, y_offset)\n\t\tend\n\t\tfor layer in comp.insulator_group.layers\n\t\t\tpush_layer!(layer, x_offset, y_offset)\n\t\tend\n\tend\n\treturn out\nend\n\nfunction dump_layer_geometry_csv(design::CableDesign;\n\tx_offset::Real = 0.0,\n\ty_offset::Real = 0.0,\n\tpath::AbstractString = \"layer_dump.csv\",\n)\n\tlayer_no = Ref(0)\n\n\tfunction emit!(io, layer, x0, y0)\n\t\tif layer isa CircStrands\n\t\t\tlayer_no[] += 1\n\t\t\trwire = to_nominal(layer.radius_wire)\n\t\t\tlay_r = layer.num_wires == 1 ? 0.0 : to_nominal(layer.radius_in)\n\t\t\tcoords = calc_circstrands_coords(layer.num_wires, rwire, lay_r; C = (x0, y0))\n\t\t\tfor (i, (x, y)) in enumerate(coords)\n\t\t\t\tprintln(io, \"$(layer_no[]),circstrands,$i,$x,$y,$rwire,,\")\n\t\t\tend\n\t\telseif layer isa Strip || layer isa Tubular || layer isa Semicon ||\n\t\t\t   layer isa Insulator\n\t\t\tlayer_no[] += 1\n\t\t\trin = to_nominal(layer.radius_in);\n\t\t\trex = to_nominal(layer.radius_ext)\n\t\t\ttyp = lowercase(string(nameof(typeof(layer))))\n\t\t\tprintln(io, \"$(layer_no[]),$typ,1,$x0,$y0,$rex,$rin,$rex\")\n\t\telseif layer isa ConductorGroup\n\t\t\tfor sub in layer.layers\n\t\t\t\temit!(io, sub, x0, y0)\n\t\t\tend\n\t\telse\n\t\t\t@warn \"Skipping layer $(typeof(layer)) in CSV dump\"\n\t\tend\n\tend\n\n\topen(path, \"w\") do io\n\t\tprintln(io, \"layer,type,element,x0,y0,radius_out,rin,rext\")\n\t\tfor comp in design.components\n\t\t\tfor layer in comp.conductor_group.layers\n\t\t\t\temit!(io, layer, x_offset, y_offset)\n\t\t\tend\n\t\t\tfor layer in comp.insulator_group.layers\n\t\t\t\temit!(io, layer, x_offset, y_offset)\n\t\t\tend\n\t\tend\n\tend\n\treturn path\nend\n\ndumplayergeometrycsv(cabledesign; path = fullfile(\"cable_layers.csv\"))\n\nall_wires = collect_layer_geometry(cable_design)\n\nusing Gmsh: gmsh\n\ngmsh.initialize()\n\nsystem_id = \"test\"\ngmsh.model.add(system_id)\n\ngmsh.option.set_number(\"General.InitialModule\", 0)\ngmsh.option.set_string(\"General.DefaultFileName\", system_id * \".geo\")\n\nDefine verbosity level\n\ngmsh.option.set_number(\"General.Verbosity\", 1)\n\nSet OCC model healing options\n\ngmsh.option.set_number(\"Geometry.AutoCoherence\", 1)\ngmsh.option.set_number(\"Geometry.OCCFixDegenerated\", 1)\ngmsh.option.set_number(\"Geometry.OCCFixSmallEdges\", 1)\ngmsh.option.set_number(\"Geometry.OCCFixSmallFaces\", 1)\ngmsh.option.set_number(\"Geometry.OCCSewFaces\", 1)\ngmsh.option.set_number(\"Geometry.OCCMakeSolids\", 1)\n\nLog settings based on verbosity\n\n@info \"Initialized Gmsh model: $system_id\"\n\nfunction my_disk!(x, y, r, lcp, wires, llwires)\n\tcen = gmsh.model.geo.addPoint(x, y, 0.0, lcp)\n\tp1 = gmsh.model.geo.addPoint(x+r, y, 0.0, lcp)\n\tp2 = gmsh.model.geo.addPoint(x, y+r, 0.0, lcp)\n\tp3 = gmsh.model.geo.addPoint(x-r, y, 0, lcp)\n\tp4 = gmsh.model.geo.addPoint(x, y-r, 0, lcp)\n\n\tc1 = gmsh.model.geo.addCircleArc(p1, cen, p2)\n\tc2 = gmsh.model.geo.addCircleArc(p2, cen, p3)\n\tc3 = gmsh.model.geo.addCircleArc(p3, cen, p4)\n\tc4 = gmsh.model.geo.addCircleArc(p4, cen, p1)\n\n\tll = gmsh.model.geo.addCurveLoop([c1, c2, c3, c4])\n\ts = gmsh.model.geo.addPlaneSurface([ll])\n\tpush!(wires, s)\n\tpush!(llwires, ll)\n\treturn s\nend\n\nlc = 0.0\nz0 = 0.0\ni=1\nwires = []\nllwires = []\nfor wire in all_wires\n\tx = wire.x\n\ty = wire.y\n\tr = wire.radius_out\n\tmy_disk!(x, y, r, lc, wires, llwires)\nend\n\ngmsh.model.geo.synchronize()\n\ngmsh.option.set_number(\"Geometry.SurfaceLabels\", 0)  # Show surface labels\ngmsh.option.set_number(\"Geometry.PointNumbers\", 0)\ngmsh.option.set_number(\"Geometry.CurveNumbers\", 0)\ngmsh.option.set_number(\"Geometry.SurfaceNumbers\", 0)\ngmsh.option.set_number(\"Geometry.NumSubEdges\", 160)\ngmsh.option.set_number(\"Geometry.Points\", 1)\ngmsh.option.set_number(\"Geometry.Curves\", 1)\ngmsh.option.set_number(\"Geometry.Surfaces\", 0)\ngmsh.option.set_number(\"Mesh.ColorCarousel\", 2)  # Colors by physical group\ngmsh.option.set_number(\"Mesh.LineWidth\", 1)\ngmsh.option.set_number(\"Mesh.SurfaceFaces\", 1)\n\ngmsh.fltk.initialize()\n\nDefine event check function\n\nfunction check_for_event()\n\taction = gmsh.onelab.get_string(\"ONELAB/Action\")\n\tif length(action) > 0 && action[1] == \"check\"\n\t\tgmsh.onelab.set_string(\"ONELAB/Action\", [\"\"])\n\t\t@debug \"UI interaction detected\"\n\t\tgmsh.graphics.draw()\n\tend\n\treturn true\nend\n\nWait for user to close the window\n\nwhile gmsh.fltk.is_available() == 1 && check_for_event()\n\tgmsh.fltk.wait()\nend\n\ngmsh.finalize()\n\n\n\nğŸ  Back to Tutorials","category":"section"},{"location":"bib/#Bibliography","page":"Bibliography","title":"Bibliography","text":"J.-R.Â Riba. The Role of AC Resistance of Bare Stranded Conductors for Developing Dynamic Line Rating Approaches. AppliedÂ Sciences 14 (2024).\n\n\n\nV.Â T.Â Morgan. The Current Distribution, Resistance and Internal Inductance of Linear Power System Conductorsâ€”A Review of Explicit Equations. IEEEÂ TransactionsÂ onÂ PowerÂ Delivery 28, 1252â€“1262 (2013).\n\n\n\nY.Â Yang, S.Â Fortin, J.Â Ma and F.Â P.Â Dawalibi. GMR of Stranded Multizone Conductors. In: The 4th IASTED Asian Conference on Power and Energy Systems (AsiaPES) (2008). Link.\n\n\n\nB.Â Gustavsen. Panel session on data for modeling system transients insulated cables. In: 2001 IEEE Power Engineering Society Winter Meeting. Conference Proceedings (Cat. No.01CH37194), Vol.Â 2 (2001); p.Â 718-723 vol.2.\n\n\n\nU.Â S.Â Gudmundsdottir, B.Â Gustavsen, C.Â L.Â Bak and W.Â Wiechowski. Field Test and Simulation of a 400-kV Cross-Bonded Cable System. IEEEÂ TransactionsÂ onÂ PowerÂ Delivery 26, 1403â€“1410 (2011).\n\n\n\nA.Â Ametani. A General Formulation of Impedance and Admittance of Cables. IEEEÂ TransactionsÂ onÂ PowerÂ ApparatusÂ andÂ Systems PAS-99, 902â€“910 (1980).\n\n\n\nT.Â A.Â Papadopoulos, D.Â A.Â Tsiamitros and G.Â K.Â Papagiannis. Impedances and Admittances of Underground Cables for the Homogeneous Earth Case. IEEEÂ TransactionsÂ onÂ PowerÂ Delivery 25, 961â€“969 (2010).\n\n\n\nCIGRE Working Group B1.30. Cable Systems Electrical Characteristics. Technical BrochureÂ 531 (CIGRE, Apr 2013). Link.\n\n\n\nIEC technical committee 20: Electric cables. IEC 60287 - Electric cables â€“ Calculation of the current rating (International Electrotechnical Commission, 2023). Link.\n\n\n\nT.Â C.Â 20. Distribution cables with extruded insulation for rated voltages from 3.6/6 (7.2) kV up to and including 20.8/36 (42) kV (European Committee for Electrotechnical Standardization, 2023); pp.Â 1â€“150. Link.\n\n\n\nT.Â C.Â VDE. Distribution cables with extruded insulation for rated voltages from 3.6/6 (7.2) kV up to and including 20.8/36 (42) kV (VDE, 2024); pp.Â 1â€“120. Link.\n\n\n\nT.Â C.Â 7. Conductors for Overhead Linesâ€”Round Wire Concentric Lay Stranded Conductors (European Committee for Electrotechnical Standardization, 2001); pp.Â 1â€“73. Link.\n\n\n\nT.Â Karmokar and M.Â Popov. Enhanced Modelling and Parameter Determination of HVDC Cables Using Practice-Oriented Methodology. CIGREÂ ScienceÂ andÂ Engineering 2025-February (2025).\n\n\n\nB.Â Gustavsen, J.Â Martinez and D.Â Durbak. Parameter determination for modeling system transients-Part II: Insulated cables. IEEEÂ TransactionsÂ onÂ PowerÂ Delivery 20, 2045â€“2050 (2005).\n\n\n\nE.Â B.Â Rosa. The self and mutual-inductances of linear conductors. Vol.Â 4 no.Â 2 (National Bureau of Standards, 1908).\n\n\n\nF.Â Grover and I.Â S.Â America. Inductance Calculations: Working Formulas and Tables. Dover books on engineering and engineering physics (Instrument Society of America, 1981).\n\n\n\nCIGRE Working Group B2.12. Alternating Current (AC) Resistance of Helically Stranded Conductors. Technical BrochureÂ 345 (CIGRE, Apr 2008). Link.\n\n\n\nN.Â Oussalah, Y.Â Zebboudj and S.Â A.Â Boggs. Partial Discharge Pulse Propagation in Shielded Power Cable and Implications for Detection Sensitivity. IEEEÂ ElectricalÂ InsulationÂ Magazine 23, 5â€“10 (2007).\n\n\n\nNIST Digital Library of Mathematical Functions, https://dlmf.nist.gov/, Release 1.2.4 of 2025-03-15 (2025). Olver, F. W. J. and Olde Daalhuis, A. B. and Lozier, D. W. and Schneider, B. I. and Boisvert, R. F. and Clark, C. W. and Miller, B. R. and Saunders, B. V. and Cohl, H. S. and McClain, M. A., eds.\n\n\n\nS.Â VujeviÄ‡, D.Â LovriÄ‡ and V.Â Boras. High-Accurate Numerical Computation of Internal Impedance of Cylindrical Conductors for Complex Arguments of Arbitrary Magnitude. IEEEÂ TransactionsÂ onÂ ElectromagneticÂ Compatibility 56, 1431â€“1438 (2014).\n\n\n\n","category":"section"},{"location":"CHANGELOG/#Changelog","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.\n\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"CHANGELOG/#[Unreleased]","page":"Changelog","title":"[Unreleased]","text":"/","category":"section"},{"location":"CHANGELOG/#Changed","page":"Changelog","title":"Changed","text":"Refactored CodeComponent structure and constructors.","category":"section"},{"location":"CHANGELOG/#Added","page":"Changelog","title":"Added","text":"Included interface to run finite element simulations using Onelab.\nIncluded basic coverage tests.\nIncluded import/export of CableDesigns to JSON files.","category":"section"},{"location":"CHANGELOG/#[v0.1.0](https://github.com/Electa-Git/LineCableModels.jl/releases/tag/v0.1.0)-2025-03-29","page":"Changelog","title":"v0.1.0 - 2025-03-29","text":"","category":"section"},{"location":"CHANGELOG/#Added-2","page":"Changelog","title":"Added","text":"First release. See README.md for more details.\n\n[Unreleased]: https://github.com/Electa-Git/LineCableModels.jl/compare/v0.1.0...HEAD v0.1.0: https://github.com/Electa-Git/LineCableModels.jl/releases/tag/v0.1.0","category":"section"},{"location":"tutorials/tutorial1/#Tutorial-1-Using-the-materials-library","page":"Tutorial 1 - Using the  materials library","title":"Tutorial 1 - Using the  materials library","text":"This tutorial demonstrates how to manage material properties for power cable modeling using the package LineCableModels.jl. Accurate knowledge of electromagnetic properties is essential for reliable cable design and analysis.\n\nBeyond showcasing the API, this guide serves as a practical reference by providing standard property values from recognized industry sources like CIGRE TB-531 [8] and IEC 60287 [9] that can be stored and consistently applied across multiple design iterations and simulation studies.\n\nTutorial outline\n\nPages = [\n\t\"tutorial1.md\",\n]\nDepth = 2:3","category":"section"},{"location":"tutorials/tutorial1/#Getting-started","page":"Tutorial 1 - Using the  materials library","title":"Getting started","text":"Load the package:\n\nusing LineCableModels\nusing DataFrames\nfullfile(filename) = joinpath(@__DIR__, filename); #hide\nset_verbosity!(0); #hide\nnothing #hide\n\nThe MaterialsLibrary is a container for storing electromagnetic properties of different materials used in power cables. By default, it initializes with several common materials with their standard properties.\n\nInitialize a MaterialsLibrary with default values:\n\nmaterials = MaterialsLibrary()\n\nInspect the contents of the materials library:\n\nmaterials_df = DataFrame(materials)\n\nThe function DataFrame returns a DataFrame with all materials and their properties, namely: electrical resistivity, relative permittivity, relative permeability, reference temperature, and temperature coefficient.","category":"section"},{"location":"tutorials/tutorial1/#Adding-new-materials","page":"Tutorial 1 - Using the  materials library","title":"Adding new materials","text":"note: Note\nNew materials can be added to the library using the Material constructor followed by add!.\n\nIt might be useful to add other conductor materials with corrected properties based on recognized standards [8] [9].\n\ncopper_corrected = Material(1.835e-8, 1.0, 0.999994, 20.0, 0.00393) # Copper with corrected resistivity from IEC 60287-3-2\nadd!(materials, \"copper_corrected\", copper_corrected)\naluminum_corrected = Material(3.03e-8, 1.0, 0.999994, 20.0, 0.00403) # Aluminum with corrected resistivity from IEC 60287-3-2\nadd!(materials, \"aluminum_corrected\", aluminum_corrected)\n\nlead = Material(21.4e-8, 1.0, 0.999983, 20.0, 0.00400) # Lead or lead alloy add!(materials, \"lead\", lead) steel = Material(13.8e-8, 1.0, 300.0, 20.0, 0.00450) # Steel add!(materials, \"steel\", steel) bronze = Material(3.5e-8, 1.0, 1.0, 20.0, 0.00300) # Bronze add!(materials, \"bronze\", bronze)\n\nstainless_steel = Material(70.0e-8, 1.0, 500.0, 20.0, 0.0) # Stainless steel\nadd!(materials, \"stainless_steel\", stainless_steel)\n\nWhen modeling cables for EMT analysis, one might be concerned with the impact of insulators and semiconductive layers on cable constants. Common insulation materials and semicons with different dielectric properties are reported in Table 6 of [8]. Let us include some of these materials in the MaterialsLibrary to help our future selves.\n\nepr = Material(1e15, 3.0, 1.0, 20.0, 0.005) # EPR (ethylene propylene rubber)\nadd!(materials, \"epr\", epr)\npvc = Material(1e15, 8.0, 1.0, 20.0, 0.1) # PVC (polyvinyl chloride)\nadd!(materials, \"pvc\", pvc)\nlaminated_paper = Material(1e15, 2.8, 1.0, 20.0, 0.0) # Laminated paper propylene\nadd!(materials, \"laminated_paper\", laminated_paper)\ncarbon_pe = Material(0.06, 1e3, 1.0, 20.0, 0.0) # Carbon-polyethylene compound (semicon)\nadd!(materials, \"carbon_pe\", carbon_pe)\nconductive_paper = Material(18.5, 8.6, 1.0, 20.0, 0.0) # Conductive paper layer (semicon)\nadd!(materials, \"conductive_paper\", conductive_paper)","category":"section"},{"location":"tutorials/tutorial1/#Removing-materials","page":"Tutorial 1 - Using the  materials library","title":"Removing materials","text":"note: Note\nMaterials can be removed from the library with the delete! function.\n\nAdd a duplicate material by accident:\n\nadd!(materials, \"epr_dupe\", epr)\n\nAnd now remove it using the delete! function:\n\ndelete!(materials, \"epr_dupe\")\n\nExamine the updated library after removing the duplicate:\n\nprintln(\"Material properties compiled from CIGRE TB-531 and IEC 60287:\")\nmaterials_df = DataFrame(materials)","category":"section"},{"location":"tutorials/tutorial1/#Saving-the-materials-library-to-JSON","page":"Tutorial 1 - Using the  materials library","title":"Saving the materials library to JSON","text":"output_file = fullfile(\"materials_library.json\")\nsave(materials, file_name = output_file);\nnothing #hide","category":"section"},{"location":"tutorials/tutorial1/#Retrieving-materials-for-use","page":"Tutorial 1 - Using the  materials library","title":"Retrieving materials for use","text":"note: Note\nTo load from an existing JSON file, instantiate a new MaterialsLibrary followed by a call to the load! method. Materials can be retrieved from the library using the get function.\n\nInitialize a new MaterialsLibrary and load from the JSON file:\n\nmaterials_from_json = MaterialsLibrary()\nload!(materials_from_json, file_name = output_file)\n\nRetrieve a material and display the object:\n\ncopper = get(materials_from_json, \"copper_corrected\")\n\nAccess the material properties:\n\nprintln(\"Retrieved copper_corrected material properties:\")\nprintln(\"Resistivity: $(copper.rho) Î©Â·m\")\nprintln(\"Relative permittivity: $(copper.eps_r)\")\nprintln(\"Relative permeability: $(copper.mu_r)\")\nprintln(\"Reference temperature: $(copper.T0) Â°C\")\nprintln(\"Temperature coefficient: $(copper.alpha) 1/Â°C\")","category":"section"},{"location":"tutorials/tutorial1/#Conclusion","page":"Tutorial 1 - Using the  materials library","title":"Conclusion","text":"This tutorial has demonstrated how to:\n\nInitialize a MaterialsLibrary with default Material objects.\nAdd new materials with specific properties.\nRemove duplicate materials.\nSave the library to a file for future use.\nRetrieve materials for use in cable modeling.\n\nThe MaterialsLibrary provides a flexible and traceable framework to manage material properties for accurate power cable modeling. Custom Material objects can be defined and used to match specific manufacturer data or standards requirements.\n\n\n\nğŸ  Back to Tutorials","category":"section"},{"location":"reference/#API-reference","page":"API reference","title":"API reference","text":"This page provides a comprehensive API reference for the LineCableModels.jl package. It documents all public modules, types, functions, and constants, organized by functional area. Each section corresponds to a major module in the package, with detailed information about parameters, return values, and usage examples.","category":"section"},{"location":"reference/#Contents","page":"API reference","title":"Contents","text":"Pages = [\"reference.md\"]\nDepth = 3\n\n","category":"section"},{"location":"reference/#Data-model","page":"API reference","title":"Data model","text":"","category":"section"},{"location":"reference/#Base-parameters-(R,-L,-C,-G)","page":"API reference","title":"Base parameters (R, L, C, G)","text":"","category":"section"},{"location":"reference/#Earth-properties","page":"API reference","title":"Earth properties","text":"","category":"section"},{"location":"reference/#Import-and-export","page":"API reference","title":"Import & export","text":"","category":"section"},{"location":"reference/#Materials-library","page":"API reference","title":"Materials library","text":"","category":"section"},{"location":"reference/#Utilities","page":"API reference","title":"Utilities","text":"","category":"section"},{"location":"reference/#Uncertain-Bessels","page":"API reference","title":"Uncertain Bessels","text":"","category":"section"},{"location":"reference/#Private-API","page":"API reference","title":"Private API","text":"","category":"section"},{"location":"reference/#Data-model-2","page":"API reference","title":"Data model","text":"","category":"section"},{"location":"reference/#Earth-properties-2","page":"API reference","title":"Earth properties","text":"","category":"section"},{"location":"reference/#Materials-library-2","page":"API reference","title":"Materials library","text":"","category":"section"},{"location":"reference/#Utilities-2","page":"API reference","title":"Utilities","text":"","category":"section"},{"location":"reference/#Index","page":"API reference","title":"Index","text":"Pages   = [\"reference.md\"]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"reference/#LineCableModels.DataModel","page":"API reference","title":"LineCableModels.DataModel","text":"LineCableModels.DataModel\n\nThe DataModel module provides data structures, constructors and utilities for modeling power cables within the LineCableModels.jl package. This module includes definitions for various cable components, and visualization tools for cable designs.\n\nOverview\n\nProvides objects for detailed cable modeling with the CableDesign and supporting types: CircStrands, Strip, Tubular, Semicon, and Insulator.\nIncludes objects for cable system modeling with the LineCableSystem type, and multiple formation patterns like trifoil and flat arrangements.\nContains functions for calculating the base electric properties of all elements within a CableDesign, namely: resistance, inductance (via GMR), shunt capacitance, and shunt conductance (via loss factor).\nOffers visualization tools for previewing cable cross-sections and system layouts.\nProvides a library system for storing and retrieving cable designs.\n\nDependencies\n\nBase\nColors\nDataFrames\nDates\nLineCableModels.Commons\nLineCableModels.DataModel.BaseParams\nMakie\nMeasurements\nPlots\nPrintf\nStatistics\n\nExports\n\nCableComponent\nCableDesign\nCablePosition\nCablesLibrary\nCircStrands\nConductorGroup\nDiameter\nInsulator\nInsulatorGroup\nLineCableSystem\nMaxFill\nNominalData\nRectStrands\nSemicon\nStrip\nThickness\nTubular\nWireArray\nequivalent\nflat_formation\nget_outer_radius\npreview\ntrifoil_formation\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.DataModel.CableComponent","page":"API reference","title":"LineCableModels.DataModel.CableComponent","text":"mutable struct CableComponent{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a CableComponent, i.e. a group of AbstractCablePart objects, with the equivalent geometric and material properties:\n\nid::String: Cable component identification (e.g. core/sheath/armor).\nconductor_group::ConductorGroup: The conductor group containing all conductive parts.\nconductor_props::Material: Effective properties of the equivalent coaxial conductor.\ninsulator_group::InsulatorGroup: The insulator group containing all insulating parts.\ninsulator_props::Material: Effective properties of the equivalent coaxial insulator.\n\ninfo: Definition & application\nCable components operate as containers for multiple cable parts, allowing the calculation of effective electromagnetic (EM) properties (sigma varepsilon mu). This is performed by transforming the physical objects within the CableComponent into one equivalent coaxial homogeneous structure comprised of one conductor and one insulator, each one represented by effective Material types stored in conductor_props and insulator_props fields.The effective properties approach is widely adopted in EMT-type simulations, and involves locking the internal and external radii of the conductor and insulator parts, respectively, and calculating the equivalent EM properties in order to match the previously determined values of R, L, C and G [4] [14].In applications, the CableComponent type is mapped to the main cable structures described in manufacturer datasheets, e.g., core, sheath, armor and jacket.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CableComponent-Tuple{String, ConductorGroup, InsulatorGroup}","page":"API reference","title":"LineCableModels.DataModel.CableComponent","text":"CableComponent(\n    id::String,\n    conductor_group::ConductorGroup,\n    insulator_group::InsulatorGroup\n) -> CableComponent\n\n\nWeakly-typed constructor that infers the scalar type T from the two groups, coerces them if necessary, and calls the strict kernel.\n\nArguments\n\nid: Cable component identification.\nconductor_group: The conductor group (any ConductorGroup{S}).\ninsulator_group: The insulator group (any InsulatorGroup{R}).\n\nReturns\n\nA CableComponent{T} where T is the resolved scalar type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CableComponent-Union{Tuple{T}, Tuple{String, ConductorGroup{T}, InsulatorGroup{T}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.CableComponent","text":"Initializes a CableComponent object based on its constituent conductor and insulator groups. The constructor performs the following sequence of steps:\n\nValidate that the conductor and insulator groups have matching radii at their interface.\nObtain the lumped-parameter values (R, L, C, G) from the conductor and insulator groups, which are computed within their respective constructors.\nCalculate the correction factors and equivalent electromagnetic properties of the conductor and insulator groups:\n\nQuantity Symbol Function\nResistivity (conductor) rho_con calc_equivalent_rho\nPermeability (conductor) mu_con calc_equivalent_mu\nResistivity (insulator) rho_ins calc_sigma_lossfact\nPermittivity (insulation) varepsilon_ins calc_equivalent_eps\nPermeability (insulation) mu_ins calc_solenoid_correction\n\nArguments\n\nid: Cable component identification (e.g. core/sheath/armor).\nconductor_group: The conductor group containing all conductive parts.\ninsulator_group: The insulator group containing all insulating parts.\n\nReturns\n\nA CableComponent instance with calculated equivalent properties:\n\nid::String: Cable component identification.\nconductor_group::ConductorGroup{T}: The conductor group containing all conductive parts.\nconductor_props::Material{T}: Effective properties of the equivalent coaxial conductor.\nrho: Resistivity [Î©Â·m].\neps_r: Relative permittivity [dimensionless].\nmu_r: Relative permeability [dimensionless].\nT0: Reference temperature [Â°C].\nalpha: Temperature coefficient of resistivity [1/Â°C].\ninsulator_group::InsulatorGroup{T}: The insulator group containing all insulating parts.\ninsulator_props::Material{T}: Effective properties of the equivalent coaxial insulator.\nrho: Resistivity [Î©Â·m].\neps_r: Relative permittivity [dimensionless].\nmu_r: Relative permeability [dimensionless].\nT0: Reference temperature [Â°C].\nalpha: Temperature coefficient of resistivity [1/Â°C].\n\nExamples\n\nconductor_group = ConductorGroup(...)\ninsulator_group = InsulatorGroup(...)\ncable = CableComponent(\"component_id\", conductor_group, insulator_group)  # Create cable component with base parameters @ 50 Hz\n\nSee also\n\ncalc_equivalent_rho\ncalc_equivalent_mu\ncalc_equivalent_eps\ncalc_sigma_lossfact\ncalc_solenoid_correction\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CableDesign","page":"API reference","title":"LineCableModels.DataModel.CableDesign","text":"mutable struct CableDesign{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents the design of a cable, including its unique identifier, nominal data, and components.\n\ncable_id::String: Unique identifier for the cable design.\nnominal_data::Union{Nothing, NominalData{T}} where T<:Union{Float64, Measurements.Measurement{Float64}}: Informative reference data.\ncomponents::Array{CableComponent{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Vector of cable components.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CableDesign-Tuple{String, CableComponent}","page":"API reference","title":"LineCableModels.DataModel.CableDesign","text":"CableDesign(\n    cable_id::String,\n    component::CableComponent;\n    nominal_data\n) -> CableDesign\n\n\nWeakly-typed constructor that infers the scalar type from the component (and nominal data if present), coerces values to that type, and calls the typed kernel.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CableDesign-Tuple{String, ConductorGroup, InsulatorGroup}","page":"API reference","title":"LineCableModels.DataModel.CableDesign","text":"CableDesign(\n    cable_id::String,\n    conductor_group::ConductorGroup,\n    insulator_group::InsulatorGroup;\n    component_id,\n    nominal_data\n) -> CableDesign\n\n\nConstructs a CableDesign instance from conductor and insulator groups. Convenience wrapper that builds the component with reduced boilerplate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CableDesign-Union{Tuple{T}, Tuple{String, CableComponent{T}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.CableDesign","text":"CableDesign(\n    cable_id::String,\n    component::CableComponent{T<:Union{Float64, Measurements.Measurement{Float64}}};\n    nominal_data\n) -> CableDesign\n\n\nStrict numeric kernel: constructs a CableDesign{T} from one component (typed) and optional nominal data (typed or nothing). Assumes all inputs are already at scalar type T.\n\nArguments\n\ncable_id: Unique identifier for the cable design.\ncomponent: Initial CableComponent for the design.\nnominal_data: Reference data for the cable design. Default: NominalData().\n\nReturns\n\nA CableDesign object with the specified properties.\n\nExamples\n\nconductor_group = ConductorGroup(central_conductor)\ninsulator_group = InsulatorGroup(main_insulator)\ncomponent = CableComponent(conductor_group, insulator_group)\ndesign = CableDesign(\"example\", component)\n\nSee also\n\nCableComponent\nConductorGroup\nInsulatorGroup\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CablePosition","page":"API reference","title":"LineCableModels.DataModel.CablePosition","text":"CablePosition(\n    cable::Union{Nothing, CableDesign},\n    horz::Number,\n    vert::Number\n) -> CablePosition\nCablePosition(\n    cable::Union{Nothing, CableDesign},\n    horz::Number,\n    vert::Number,\n    conn::Union{Nothing, Dict{String, Int64}}\n) -> CablePosition\n\n\nWeakly-typed constructor that infers T from the cable and coordinates, builds/validates the phase mapping, coerces inputs to T, and calls the typed kernel.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CablePosition-2","page":"API reference","title":"LineCableModels.DataModel.CablePosition","text":"struct CablePosition{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a physically defined cable with position and phase mapping within a system.\n\ndesign_data::CableDesign: The CableDesign object assigned to this cable position.\nhorz::Union{Float64, Measurements.Measurement{Float64}}: Horizontal coordinate [m].\nvert::Union{Float64, Measurements.Measurement{Float64}}: Vertical coordinate [m].\nconn::Vector{Int64}: Phase mapping vector (aligned with design_data.components).\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CablePosition-Union{Tuple{T}, Tuple{CableDesign{T}, T, T, Vector{Int64}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.CablePosition","text":"Constructs a CablePosition instance with specified cable design, coordinates, and phase mapping.\n\nArguments\n\ncable: A CableDesign object defining the cable structure.\nhorz: Horizontal coordinate [m].\nvert: Vertical coordinate [m].\nconn: A dictionary mapping component names to phase indices, or nothing for default mapping.\n\nReturns\n\nA CablePosition object with the assigned cable design, coordinates, and phase mapping.\n\nnote: Phase mapping\nThe conn argument is a Dict that maps the cable components to their respective phases. The values (1, 2, 3) represent the phase numbers (A, B, C) in a three-phase system. Components mapped to phase 0 will be Kron-eliminated (grounded). Components set to the same phase will be bundled into an equivalent phase.\n\nExamples\n\ncable_design = CableDesign(\"example\", nominal_data, components_dict)\nxa, ya = 0.0, -1.0  # Coordinates in meters\n\n# With explicit phase mapping\ncablepos1 = CablePosition(cable_design, xa, ya, Dict(\"core\" => 1))\n\n# With default phase mapping (first component to phase 1, others to 0)\ndefault_cablepos = CablePosition(cable_design, xa, ya)\n\nSee also\n\nCableDesign\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CablesLibrary","page":"API reference","title":"LineCableModels.DataModel.CablesLibrary","text":"mutable struct CablesLibrary\n\nRepresents a library of cable designs stored as a dictionary.\n\ndata::Dict{String, CableDesign}: Dictionary mapping cable IDs to the respective CableDesign objects.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CablesLibrary-Tuple{}","page":"API reference","title":"LineCableModels.DataModel.CablesLibrary","text":"CablesLibrary() -> CablesLibrary\n\n\nConstructs an empty CablesLibrary instance.\n\nArguments\n\nNone.\n\nReturns\n\nA CablesLibrary object with an empty dictionary of cable designs.\n\nExamples\n\n# Create a new, empty library\nlibrary = CablesLibrary()\n\nSee also\n\nCableDesign\nadd!\ndelete!\nLineCableModels.ImportExport.save\nDataFrame\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.CircStrands","page":"API reference","title":"LineCableModels.DataModel.CircStrands","text":"struct CircStrands{T<:Union{Float64, Measurements.Measurement{Float64}}, U<:Int64} <: LineCableModels.DataModel.AbstractStrandsLayer{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents an array of wires equally spaced around a circumference of arbitrary radius, with attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the wire array [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the wire array [m].\nradius_wire::Union{Float64, Measurements.Measurement{Float64}}: Radius of each individual wire [m].\nnum_wires::Int64: Number of wires in the array [dimensionless].\nlay_ratio::Union{Float64, Measurements.Measurement{Float64}}: Ratio defining the lay length of the wires (twisting factor) [dimensionless].\nmean_diameter::Union{Float64, Measurements.Measurement{Float64}}: Mean diameter of the wire array [m].\npitch_length::Union{Float64, Measurements.Measurement{Float64}}: Pitch length of the wire array [m].\nlay_direction::Int64: Twisting direction of the strands (1 = unilay, -1 = contralay) [dimensionless].\nmaterial_props::Material: Material object representing the physical properties of the wire material.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Temperature at which the properties are evaluated [Â°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of all wires in the array [mÂ²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance per wire in the array [Î©/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the wire array [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.CircStrands-Union{Tuple{U}, Tuple{T}, Tuple{T, T, U, T, Material{T}, T, U}} where {T<:Union{Float64, Measurements.Measurement{Float64}}, U<:Int64}","page":"API reference","title":"LineCableModels.DataModel.CircStrands","text":"CircStrands(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_wire::Union{Float64, Measurements.Measurement{Float64}},\n    num_wires::Int64,\n    lay_ratio::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}},\n    lay_direction::Int64\n) -> CircStrands{T, Int64} where T<:Union{Float64, Measurements.Measurement{Float64}}\n\n\nConstructs a CircStrands instance based on specified geometric and material parameters.\n\nArguments\n\nradius_in: Internal radius of the wire array [m].\nradius_wire: Radius of each individual wire [m].\nnum_wires: Number of wires in the array [dimensionless].\nlay_ratio: Ratio defining the lay length of the wires (twisting factor) [dimensionless].\nmaterial_props: A Material object representing the material properties.\ntemperature: Temperature at which the properties are evaluated [Â°C].\nlay_direction: Twisting direction of the strands (1 = unilay, -1 = contralay) [dimensionless].\n\nReturns\n\nA CircStrands object with calculated geometric and electrical properties.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\ncircstrands = CircStrands(0.01, Diameter(0.002), 7, 10, material_props, temperature=25)\nprintln(circstrands.mean_diameter)  # Outputs mean diameter in m\nprintln(circstrands.resistance)     # Outputs resistance in Î©/m\n\nSee also\n\nMaterial\nConductorGroup\ncalc_tubular_resistance\ncalc_circstrands_gmr\ncalc_helical_params\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.ConductorGroup","page":"API reference","title":"LineCableModels.DataModel.ConductorGroup","text":"mutable struct ConductorGroup{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractConductorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a composite conductor group assembled from multiple conductive layers or stranded wires.\n\nThis structure serves as a container for different AbstractConductorPart elements  (such as wire arrays, strips, and tubular conductors) arranged in concentric layers.  The ConductorGroup aggregates these individual parts and provides equivalent electrical  properties that represent the composite behavior of the entire assembly.\n\nAttributes\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Inner radius of the conductor group [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: Outer radius of the conductor group [m].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the entire conductor group [mÂ²].\nnum_wires::Int64: Number of individual wires in the conductor group [dimensionless].\nnum_turns::Union{Float64, Measurements.Measurement{Float64}}: Number of turns per meter of each wire strand [1/m].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: DC resistance of the conductor group [Î©].\nalpha::Union{Float64, Measurements.Measurement{Float64}}: Temperature coefficient of resistance [1/Â°C].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the conductor group [m].\nlayers::Array{LineCableModels.DataModel.AbstractConductorPart{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Vector of conductor layer components.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.ConductorGroup-Union{Tuple{CableComponent{T}}, Tuple{T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.ConductorGroup","text":"ConductorGroup(\n    component::CableComponent{T<:Union{Float64, Measurements.Measurement{Float64}}}\n) -> ConductorGroup\n\n\nBuild a ConductorGroup equivalent for a CableComponent, preserving num_turns and num_wires from the original group.\n\nConstructs a single-layer ConductorGroup{T} from the computed equivalent Tubular(component), but carries over bookkeeping fields needed by downstream corrections (e.g., solenoid correction using num_turns).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.ConductorGroup-Union{Tuple{T}, Tuple{T, T, T, Int64, T, T, T, T, Array{LineCableModels.DataModel.AbstractConductorPart{T}, 1}}} where T","page":"API reference","title":"LineCableModels.DataModel.ConductorGroup","text":"Constructs a ConductorGroup instance initializing with the central conductor part.\n\nArguments\n\ncentral_conductor: An AbstractConductorPart object located at the center of the conductor group.\n\nReturns\n\nA ConductorGroup object initialized with geometric and electrical properties derived from the central conductor.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Diameter","page":"API reference","title":"LineCableModels.DataModel.Diameter","text":"struct Diameter{T<:Real} <: LineCableModels.DataModel.AbstractRadius\n\nRepresents the diameter of a cable component.\n\nvalue::Real: Numerical value of the diameter [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Insulator","page":"API reference","title":"LineCableModels.DataModel.Insulator","text":"struct Insulator{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractInsulatorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents an insulating layer with defined geometric, material, and electrical properties given by the attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the insulating layer [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the insulating layer [m].\nmaterial_props::Material: Material properties of the insulator.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Operating temperature of the insulator [Â°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the insulating layer [mÂ²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance of the insulating layer [Î©/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the insulator [m].\nshunt_capacitance::Union{Float64, Measurements.Measurement{Float64}}: Shunt capacitance per unit length of the insulating layer [F/m].\nshunt_conductance::Union{Float64, Measurements.Measurement{Float64}}: Shunt conductance per unit length of the insulating layer [SÂ·m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Insulator-Union{Tuple{CableComponent{T}}, Tuple{T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Insulator","text":"Insulator(\n    component::CableComponent{T<:Union{Float64, Measurements.Measurement{Float64}}}\n) -> Insulator\n\n\nConstructs the equivalent coaxial insulation as an Insulator directly from a CableComponent, calling the strict positional constructor.\n\nArguments\n\ncomponent: The CableComponent providing geometry and material.\n\nReturns\n\nInsulator{T} with radii from component.insulator_group and material from component.insulator_props at the group temperature (fallback to T0).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Insulator-Union{Tuple{T}, Tuple{T, T, Material{T}, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Insulator","text":"Insulator(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}}\n) -> Insulator\n\n\nConstructs an Insulator object with specified geometric and material parameters.\n\nArguments\n\nradius_in: Internal radius of the insulating layer [m].\nradius_ext: External radius or thickness of the layer [m].\nmaterial_props: Material properties of the insulating material.\ntemperature: Operating temperature of the insulator [Â°C].\n\nReturns\n\nAn Insulator object with calculated electrical properties.\n\nExamples\n\nmaterial_props = Material(1e10, 3.0, 1.0, 20.0, 0.0)\ninsulator_layer = Insulator(0.01, 0.015, material_props, temperature=25)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.InsulatorGroup","page":"API reference","title":"LineCableModels.DataModel.InsulatorGroup","text":"mutable struct InsulatorGroup{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractInsulatorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a composite coaxial insulator group assembled from multiple insulating layers.\n\nThis structure serves as a container for different AbstractInsulatorPart elements (such as insulators and semiconductors) arranged in concentric layers. The InsulatorGroup aggregates these individual parts and provides equivalent electrical properties that represent the composite behavior of the entire assembly, stored in the attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Inner radius of the insulator group [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: Outer radius of the insulator group [m].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the entire insulator group [mÂ²].\nshunt_capacitance::Union{Float64, Measurements.Measurement{Float64}}: Shunt capacitance per unit length of the insulator group [F/m].\nshunt_conductance::Union{Float64, Measurements.Measurement{Float64}}: Shunt conductance per unit length of the insulator group [SÂ·m].\nlayers::Array{LineCableModels.DataModel.AbstractInsulatorPart{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Vector of insulator layer components.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.InsulatorGroup-Union{Tuple{CableComponent{T}}, Tuple{T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.InsulatorGroup","text":"InsulatorGroup(\n    component::CableComponent{T<:Union{Float64, Measurements.Measurement{Float64}}}\n) -> InsulatorGroup\n\n\nBuild an InsulatorGroup equivalent for a CableComponent while maintaining geometric coupling to the equivalent conductor group.\n\nStacks a single insulating layer of equivalent material and thickness over the new conductor group created from the same component.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.InsulatorGroup-Union{Tuple{T}, Tuple{T, T, T, T, T, Array{LineCableModels.DataModel.AbstractInsulatorPart{T}, 1}}} where T","page":"API reference","title":"LineCableModels.DataModel.InsulatorGroup","text":"Constructs an InsulatorGroup instance initializing with the initial insulator part.\n\nArguments\n\ninitial_insulator: An AbstractInsulatorPart object located at the innermost position of the insulator group.\n\nReturns\n\nAn InsulatorGroup object initialized with geometric and electrical properties derived from the initial insulator.\n\nExamples\n\nmaterial_props = Material(1e10, 3.0, 1.0, 20.0, 0.0)\ninitial_insulator = Insulator(0.01, 0.015, material_props)\ninsulator_group = InsulatorGroup(initial_insulator)\nprintln(insulator_group.layers)           # Output: [initial_insulator]\nprintln(insulator_group.shunt_capacitance) # Output: Capacitance in [F/m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"LineCableSystem(\n    system_id::String,\n    line_length::Number,\n    cable::CableDesign,\n    horz::Number,\n    vert::Number\n) -> LineCableSystem\nLineCableSystem(\n    system_id::String,\n    line_length::Number,\n    cable::CableDesign,\n    horz::Number,\n    vert::Number,\n    conn::Union{Nothing, Dict{String, Int64}}\n) -> LineCableSystem\n\n\nWeakly-typed convenience constructor. Builds a CablePosition from a CableDesign and coordinates, then constructs the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem-2","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"mutable struct LineCableSystem{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a cable system configuration, defining the physical structure, cables, and their positions.\n\nsystem_id::String: Unique identifier for the system.\nline_length::Union{Float64, Measurements.Measurement{Float64}}: Length of the cable system [m].\nnum_cables::Int64: Number of cables in the system.\nnum_phases::Int64: Number of actual phases in the system.\ncables::Array{CablePosition{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Cross-section cable positions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem-Tuple{String, Number, CablePosition}","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"LineCableSystem(\n    system_id::String,\n    line_length::Number,\n    cable::CablePosition\n) -> LineCableSystem\n\n\nWeakly-typed constructor. Infers scalar type T from line_length and the cable (or its design), coerces as needed, and calls the strict kernel.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem-Union{Tuple{T}, Tuple{String, T, Array{CablePosition{T}, 1}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"Strict numeric kernel. Builds a typed LineCableSystem{T} from a vector of CablePosition{T}.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.LineCableSystem-Union{Tuple{T}, Tuple{String, T, CablePosition{T}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.LineCableSystem","text":"Constructs a LineCableSystem with an initial cable position and system parameters.\n\nArguments\n\nsystem_id: Identifier for the cable system.\nline_length: Length of the cable system [m].\ncable: Initial CablePosition object defining a cable position and phase mapping.\n\nReturns\n\nA LineCableSystem object initialized with a single cable position.\n\nExamples\n\ncable_design = CableDesign(\"example\", nominal_data, components_dict)\ncablepos1 = CablePosition(cable_design, 0.0, 0.0, Dict(\"core\" => 1))\n\ncable_system = LineCableSystem(\"test_case_1\", 1000.0, cablepos1)\nprintln(cable_system.num_phases)  # Prints number of unique phase assignments\n\nSee also\n\nCablePosition\nCableDesign\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.NominalData","page":"API reference","title":"LineCableModels.DataModel.NominalData","text":"struct NominalData{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nStores nominal electrical and geometric parameters for a cable design.\n\ndesignation_code::Union{Nothing, String}: Cable designation as per DIN VDE 0271/0276.\nU0::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Rated phase-to-earth voltage [kV].\nU::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Rated phase-to-phase voltage [kV].\nconductor_cross_section::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the conductor [mmÂ²].\nscreen_cross_section::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the screen [mmÂ²].\narmor_cross_section::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the armor [mmÂ²].\nresistance::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Base (DC) resistance of the cable core [Î©/km].\ncapacitance::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Capacitance of the main insulation [Î¼F/km].\ninductance::Union{Nothing, T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Inductance of the cable (trifoil formation) [mH/km].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.NominalData-Tuple{}","page":"API reference","title":"LineCableModels.DataModel.NominalData","text":"NominalData(\n;\n    designation_code,\n    U0,\n    U,\n    conductor_cross_section,\n    screen_cross_section,\n    armor_cross_section,\n    resistance,\n    capacitance,\n    inductance\n) -> NominalData{Float64}\n\n\nWeakly-typed constructor that infers the target scalar type T from the provided numeric kwargs (ignoring nothing and the string designation), coerces numerics to T, and calls the strict kernel.\n\nIf no numeric kwargs are provided, it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Semicon","page":"API reference","title":"LineCableModels.DataModel.Semicon","text":"struct Semicon{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractInsulatorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a semiconducting layer with defined geometric, material, and electrical properties given by the attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the semiconducting layer [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the semiconducting layer [m].\nmaterial_props::Material: Material properties of the semiconductor.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Operating temperature of the semiconductor [Â°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the semiconducting layer [mÂ²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance of the semiconducting layer [Î©/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the semiconducting layer [m].\nshunt_capacitance::Union{Float64, Measurements.Measurement{Float64}}: Shunt capacitance per unit length of the semiconducting layer [F/m].\nshunt_conductance::Union{Float64, Measurements.Measurement{Float64}}: Shunt conductance per unit length of the semiconducting layer [SÂ·m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Semicon-Union{Tuple{T}, Tuple{T, T, Material{T}, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Semicon","text":"Semicon(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}}\n) -> Semicon\n\n\nConstructs a Semicon instance with calculated electrical and geometric properties.\n\nArguments\n\nradius_in: Internal radius of the semiconducting layer [m].\nradius_ext: External radius or thickness of the layer [m].\nmaterial_props: Material properties of the semiconducting material.\ntemperature: Operating temperature of the layer [Â°C] (default: Tâ‚€).\n\nReturns\n\nA Semicon object with initialized properties.\n\nExamples\n\nmaterial_props = Material(1e6, 2.3, 1.0, 20.0, 0.00393)\nsemicon_layer = Semicon(0.01, Thickness(0.002), material_props, temperature=25)\nprintln(semicon_layer.cross_section)      # Expected output: ~6.28e-5 [mÂ²]\nprintln(semicon_layer.resistance)         # Expected output: Resistance in [Î©/m]\nprintln(semicon_layer.gmr)                # Expected output: GMR in [m]\nprintln(semicon_layer.shunt_capacitance)  # Expected output: Capacitance in [F/m]\nprintln(semicon_layer.shunt_conductance)  # Expected output: Conductance in [SÂ·m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Strip","page":"API reference","title":"LineCableModels.DataModel.Strip","text":"struct Strip{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractConductorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a flat conductive strip with defined geometric and material properties given by the attributes:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the strip [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the strip [m].\nthickness::Union{Float64, Measurements.Measurement{Float64}}: Thickness of the strip [m].\nwidth::Union{Float64, Measurements.Measurement{Float64}}: Width of the strip [m].\nlay_ratio::Union{Float64, Measurements.Measurement{Float64}}: Ratio defining the lay length of the strip (twisting factor) [dimensionless].\nmean_diameter::Union{Float64, Measurements.Measurement{Float64}}: Mean diameter of the strip's helical path [m].\npitch_length::Union{Float64, Measurements.Measurement{Float64}}: Pitch length of the strip's helical path [m].\nlay_direction::Int64: Twisting direction of the strip (1 = unilay, -1 = contralay) [dimensionless].\nmaterial_props::Material: Material properties of the strip.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Temperature at which the properties are evaluated [Â°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the strip [mÂ²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance of the strip [Î©/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the strip [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Strip-Union{Tuple{T}, Tuple{T, T, T, T, Material{T}, T, Int64}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Strip","text":"Strip(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    width::Union{Float64, Measurements.Measurement{Float64}},\n    lay_ratio::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}},\n    lay_direction::Int64\n) -> Strip\n\n\nConstructs a Strip object with specified geometric and material parameters.\n\nArguments\n\nradius_in: Internal radius of the strip [m].\nradius_ext: External radius or thickness of the strip [m].\nwidth: Width of the strip [m].\nlay_ratio: Ratio defining the lay length of the strip [dimensionless].\nmaterial_props: Material properties of the strip.\ntemperature: Temperature at which the properties are evaluated [Â°C]. Defaults to Tâ‚€.\nlay_direction: Twisting direction of the strip (1 = unilay, -1 = contralay) [dimensionless]. Defaults to 1.\n\nReturns\n\nA Strip object with calculated geometric and electrical properties.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nstrip = Strip(0.01, Thickness(0.002), 0.05, 10, material_props, temperature=25)\nprintln(strip.cross_section) # Output: 0.0001 [mÂ²]\nprintln(strip.resistance)    # Output: Resistance value [Î©/m]\n\nSee also\n\nMaterial\nConductorGroup\ncalc_strip_resistance\ncalc_tubular_gmr\ncalc_helical_params\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Thickness","page":"API reference","title":"LineCableModels.DataModel.Thickness","text":"struct Thickness{T<:Real} <: LineCableModels.DataModel.AbstractRadius\n\nRepresents the thickness of a cable component.\n\nvalue::Real: Numerical value of the thickness [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Tubular","page":"API reference","title":"LineCableModels.DataModel.Tubular","text":"struct Tubular{T<:Union{Float64, Measurements.Measurement{Float64}}} <: LineCableModels.DataModel.AbstractConductorPart{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a tubular or solid (radius_in=0) conductor with geometric and material properties defined as:\n\nradius_in::Union{Float64, Measurements.Measurement{Float64}}: Internal radius of the tubular conductor [m].\nradius_ext::Union{Float64, Measurements.Measurement{Float64}}: External radius of the tubular conductor [m].\nmaterial_props::Material: A Material object representing the physical properties of the conductor material.\ntemperature::Union{Float64, Measurements.Measurement{Float64}}: Temperature at which the properties are evaluated [Â°C].\ncross_section::Union{Float64, Measurements.Measurement{Float64}}: Cross-sectional area of the tubular conductor [mÂ²].\nresistance::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistance (DC) of the tubular conductor [Î©/m].\ngmr::Union{Float64, Measurements.Measurement{Float64}}: Geometric mean radius of the tubular conductor [m].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.Tubular-Union{Tuple{CableComponent{T}}, Tuple{T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Tubular","text":"Tubular(\n    component::CableComponent{T<:Union{Float64, Measurements.Measurement{Float64}}}\n) -> Tubular\n\n\nConstructs the equivalent coaxial conductor as a Tubular directly from a CableComponent, reusing the rigorously tested positional constructor.\n\nArguments\n\ncomponent: The CableComponent providing geometry and material.\n\nReturns\n\nTubular{T} with radii from component.conductor_group and material from component.conductor_props at the group temperature (fallback to T0).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.Tubular-Union{Tuple{T}, Tuple{T, T, Material{T}, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.Tubular","text":"Tubular(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    material_props::Material{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    temperature::Union{Float64, Measurements.Measurement{Float64}}\n) -> Tubular\n\n\nInitializes a Tubular object with specified geometric and material parameters.\n\nArguments\n\nradius_in: Internal radius of the tubular conductor [m].\nradius_ext: External radius of the tubular conductor [m].\nmaterial_props: A Material object representing the physical properties of the conductor material.\ntemperature: Temperature at which the properties are evaluated [Â°C]. Defaults to Tâ‚€.\n\nReturns\n\nAn instance of Tubular initialized with calculated geometric and electrical properties.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\ntubular = Tubular(0.01, 0.02, material_props, temperature=25)\nprintln(tubular.cross_section) # Output: 0.000942 [mÂ²]\nprintln(tubular.resistance)    # Output: Resistance value [Î©/m]\n\nSee also\n\nMaterial\ncalc_tubular_resistance\ncalc_tubular_gmr\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.equivalent-Tuple{CableDesign}","page":"API reference","title":"LineCableModels.DataModel.equivalent","text":"equivalent(\n    original_design::CableDesign;\n    new_id\n) -> CableDesign\n\n\nBuilds a simplified CableDesign by replacing each component with a homogeneous equivalent and leverages shorthand constructors:\n\nConductorGroup(component::CableComponent{T}) = ConductorGroup(Tubular(component))\nInsulatorGroup(component::CableComponent{T}) = InsulatorGroup(Insulator(component))\n\nThe geometry is preserved from the original component, while materials are derived from the component's effective conductor and insulator properties.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.flat_formation-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.flat_formation","text":"flat_formation(\n    xc::Union{Float64, Measurements.Measurement{Float64}},\n    yc::Union{Float64, Measurements.Measurement{Float64}},\n    s::Union{Float64, Measurements.Measurement{Float64}};\n    vertical\n) -> NTuple{6, Union{Float64, Measurements.Measurement{Float64}}}\n\n\nCalculates the coordinates of three conductors arranged in a flat (horizontal or vertical) formation.\n\nArguments\n\nxc: X-coordinate of the reference point [m].\nyc: Y-coordinate of the reference point [m].\ns: Spacing between adjacent conductors [m].\nvertical: Boolean flag indicating whether the formation is vertical.\n\nReturns\n\nA tuple containing:\nxa, ya: Coordinates of the first conductor [m].\nxb, yb: Coordinates of the second conductor [m].\nxc, yc: Coordinates of the third conductor [m].\n\nExamples\n\n# Horizontal formation\nxa, ya, xb, yb, xc, yc = flat_formation(0.0, 0.0, 0.1)\nprintln((xa, ya))  # First conductor coordinates\nprintln((xb, yb))  # Second conductor coordinates\nprintln((xc, yc))  # Third conductor coordinates\n\n# Vertical formation\nxa, ya, xb, yb, xc, yc = flat_formation(0.0, 0.0, 0.1, vertical=true)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.trifoil_formation-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.trifoil_formation","text":"trifoil_formation(\n    x0::Union{Float64, Measurements.Measurement{Float64}},\n    y0::Union{Float64, Measurements.Measurement{Float64}},\n    r_ext::Union{Float64, Measurements.Measurement{Float64}}\n) -> NTuple{6, Union{Float64, Measurements.Measurement{Float64}}}\n\n\nCalculates the coordinates of three cables arranged in a trifoil pattern.\n\nArguments\n\nx0: X-coordinate of the center point [m].\ny0: Y-coordinate of the center point [m].\nr_ext: External radius of the circular layout [m].\n\nReturns\n\nA tuple containing:\nxa, ya: Coordinates of the top cable [m].\nxb, yb: Coordinates of the bottom-left cable [m].\nxc, yc: Coordinates of the bottom-right cable [m].\n\nExamples\n\nxa, ya, xb, yb, xc, yc = trifoil_formation(0.0, 0.0, 0.035)\nprintln((xa, ya))  # Coordinates of top cable\nprintln((xb, yb))  # Coordinates of bottom-left cable\nprintln((xc, yc))  # Coordinates of bottom-right cable\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams","page":"API reference","title":"LineCableModels.DataModel.BaseParams","text":"LineCableModels.DataModel.BaseParams\n\nThe BaseParams submodule provides fundamental functions for determining the base electrical parameters (R, L, C, G) of cable components within the LineCableModels.DataModel module. This includes implementations of standard engineering formulas for resistance, inductance, and geometric parameters of various conductor configurations.\n\nOverview\n\nImplements basic electrical engineering formulas for calculating DC resistance and inductance of different conductor geometries (tubular, strip, wire arrays).\nImplements basic formulas for capacitance and dielectric losses in insulators and semiconductors.\nProvides functions for temperature correction of material properties.\nCalculates geometric mean radii for different conductor configurations.\nIncludes functions for determining the effective length for helical wire arrangements.\nCalculates equivalent electrical parameters and correction factors for different geometries and configurations.\n\nDependencies\n\nBase\nLineCableModels.Commons\nMeasurements\n\nExports\n\ncalc_circstrands_coords\ncalc_circstrands_gmr\ncalc_equivalent_alpha\ncalc_equivalent_eps\ncalc_equivalent_gmr\ncalc_equivalent_lossfact\ncalc_equivalent_mu\ncalc_equivalent_rho\ncalc_gmd\ncalc_helical_params\ncalc_inductance_trifoil\ncalc_parallel_equivalent\ncalc_shunt_capacitance\ncalc_shunt_conductance\ncalc_sigma_lossfact\ncalc_solenoid_correction\ncalc_strip_resistance\ncalc_temperature_correction\ncalc_tubular_gmr\ncalc_tubular_inductance\ncalc_tubular_resistance\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_circstrands_coords-Union{Tuple{U}, Tuple{T}, Tuple{U, T, T, Tuple{T, T}}} where {T<:Union{Float64, Measurements.Measurement{Float64}}, U<:Int64}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_circstrands_coords","text":"calc_circstrands_coords(\n    num_wires::Int64,\n    radius_wire::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    C::Tuple{T<:Union{Float64, Measurements.Measurement{Float64}}, T<:Union{Float64, Measurements.Measurement{Float64}}}\n) -> Vector{<:Tuple{Union{Float64, Measurements.Measurement{Float64}}, Union{Float64, Measurements.Measurement{Float64}}}}\n\n\nCalculates the center coordinates of wires arranged in a circular pattern.\n\nArguments\n\nnum_wires: Number of wires in the circular arrangement [dimensionless].\nradius_wire: Radius of each individual wire [m].\nradius_in: Inner radius of the wire array (to wire centers) [m].\nC: Optional tuple representing the center coordinates of the circular arrangement [m]. Default is (0.0, 0.0).\n\nReturns\n\nVector of tuples, where each tuple contains the (x, y) coordinates [m] of the center of a wire.\n\nExamples\n\n# Create a 7-wire array with 2mm wire radius and 1cm inner radius\nwire_coords = calc_circstrands_coords(7, 0.002, 0.01)\nprintln(wire_coords[1]) # Output: First wire coordinates\n\n# Create a wire array with custom center position\nwire_coords = calc_circstrands_coords(7, 0.002, 0.01, C=(0.5, 0.3))\n\nSee also\n\nLineCableModels.DataModel.CircStrands\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_circstrands_gmr-Union{Tuple{T}, Tuple{T, Int64, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_circstrands_gmr","text":"calc_circstrands_gmr(\n    lay_rad::Union{Float64, Measurements.Measurement{Float64}},\n    N::Int64,\n    rad_wire::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the geometric mean radius (GMR) of a circular wire array, using formula (62), page 335, of the book by Edward Rosa [15]:\n\nGMR = sqrtn r n a^n-1\n\nwhere a is the layout radius, n is the number of wires, and r is the radius of each wire.\n\nArguments\n\nlay_rad: Layout radius of the wire array [m].\nN: Number of wires in the array [dimensionless].\nrad_wire: Radius of an individual wire [m].\nmu_r: Relative permeability of the wire material [dimensionless].\n\nReturns\n\nGeometric mean radius (GMR) of the wire array [m].\n\nExamples\n\nlay_rad = 0.05\nN = 7\nrad_wire = 0.002\nmu_r = 1.0\ngmr = calc_circstrands_gmr(lay_rad, N, rad_wire, mu_r)\nprintln(gmr) # Expected output: 0.01187... [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_alpha-Union{Tuple{T}, NTuple{4, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_alpha","text":"calc_equivalent_alpha(\n    alpha1::Union{Float64, Measurements.Measurement{Float64}},\n    R1::Union{Float64, Measurements.Measurement{Float64}},\n    alpha2::Union{Float64, Measurements.Measurement{Float64}},\n    R2::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the equivalent temperature coefficient of resistance (alpha) when two conductors are connected in parallel, by cross-weighted-resistance averaging:\n\nalpha_eq = fracalpha_1 R_2 + alpha_2 R1R_1 + R_2\n\nwhere alpha_1, alpha_2 are the temperature coefficients of the conductors, and R_1, R_2 are the respective resistances.\n\nArguments\n\nalpha1: Temperature coefficient of resistance of the first conductor [1/Â°C].\nR1: Resistance of the first conductor [Î©].\nalpha2: Temperature coefficient of resistance of the second conductor [1/Â°C].\nR2: Resistance of the second conductor [Î©].\n\nReturns\n\nThe equivalent temperature coefficient [1/Â°C] for the parallel combination.\n\nExamples\n\nalpha_conductor = 0.00393  # Copper\nalpha_new_part = 0.00403   # Aluminum\nR_conductor = 0.5\nR_new_part = 1.0\nalpha_eq = calc_equivalent_alpha(alpha_conductor, R_conductor, alpha_new_part, R_new_part)\nprintln(alpha_eq)  # Output: 0.00396 (approximately)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_eps-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_eps","text":"calc_equivalent_eps(\n    C_eq::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the equivalent permittivity for a coaxial cable insulation, using the formula [4]:\n\nvarepsilon_eq = fracC_eq log(fracr_extr_in)2pi varepsilon_0\n\nwhere varepsilon_0 is the permittivity of free space.\n\nArguments\n\nC_eq: Equivalent capacitance of the insulation [F/m].\nradius_ext: External radius of the insulation [m].\nradius_in: Internal radius of the insulation [m].\n\nReturns\n\nEquivalent relative permittivity of the insulation [dimensionless].\n\nExamples\n\neps_eq = calc_equivalent_eps(1e-10, 0.01, 0.005)  # Expected output: ~2.26 [dimensionless]\n\nSee also\n\nÎµâ‚€\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_gmr-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:LineCableModels.DataModel.AbstractCablePart, U<:LineCableModels.DataModel.AbstractCablePart}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_gmr","text":"calc_equivalent_gmr(\n    existing::LineCableModels.DataModel.AbstractCablePart,\n    new_layer::LineCableModels.DataModel.AbstractCablePart\n) -> Any\n\n\nCalculates the equivalent geometric mean radius (GMR) of a conductor after adding a new layer, by recursive application of the multizone stranded conductor defined as [3]:\n\nGMR_eq = GMR_i-1^beta^2 cdot GMR_i^(1-beta)^2 cdot GMD^2beta(1-beta)\n\nbeta = fracS_i-1S_i-1 + S_i\n\nwhere:\n\nS_i-1 is the cumulative cross-sectional area of the existing cable part, S_i is the total cross-sectional area after inclusion of the conducting layer i.\nGMR_i-1 is the cumulative GMR of the existing cable part, GMR_i is the GMR of the conducting layer i.\nGMD is the geometric mean distance between the existing cable part and the new layer, calculated using calc_gmd.\n\nArguments\n\nexisting: The existing cable part (AbstractCablePart).\nnew_layer: The new layer being added (AbstractCablePart).\n\nReturns\n\nUpdated equivalent GMR of the combined conductor [m].\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nconductor = Conductor(Strip(0.01, 0.002, 0.05, 10, material_props))\nnew_layer = CircStrands(0.02, 0.002, 7, 15, material_props)\nequivalent_gmr = calc_equivalent_gmr(conductor, new_layer)  # Expected output: Updated GMR value [m]\n\nSee also\n\ncalc_gmd\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_lossfact-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_lossfact","text":"calc_equivalent_lossfact(\n    G_eq::Union{Float64, Measurements.Measurement{Float64}},\n    C_eq::Union{Float64, Measurements.Measurement{Float64}},\n    Ï‰::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the equivalent loss factor (tangent) of a dielectric material:\n\ntan delta = fracG_eqomega cdot C_eq\n\nwhere tan delta is the loss factor (tangent).\n\nArguments\n\nG_eq: Equivalent conductance of the material [SÂ·m].\nC_eq: Equivalent capacitance of the material [F/m].\nÏ‰: Angular frequency [rad/s].\n\nReturns\n\nEquivalent loss factor of the dielectric material [dimensionless].\n\nExamples\n\nloss_factor = calc_equivalent_lossfact(1e-8, 1e-10, 2Ï€*50)  # Expected output: ~0.0318 [dimensionless]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_mu-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_mu","text":"calc_equivalent_mu(\n    gmr::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the relative permeability (mu_r) based on the geometric mean radius (GMR) and conductor dimensions, by executing the inverse of calc_tubular_gmr, and solving for mu_r:\n\nlog GMR = log r_2 - mu_r left fracr_1^4left(r_2^2 - r_1^2right)^2 logleft(fracr_2r_1right) - frac3r_1^2 - r_2^24left(r_2^2 - r_1^2right) right\n\nmu_r = -fracleft(log GMR - log r_2right)fracr_1^4left(r_2^2 - r_1^2right)^2 logleft(fracr_2r_1right) - frac3r_1^2 - r_2^24left(r_2^2 - r_1^2right)\n\nwhere r_1 is the inner radius and r_2 is the outer radius.\n\nArguments\n\ngmr: Geometric mean radius of the conductor [m].\nradius_ext: External radius of the conductor [m].\nradius_in: Internal radius of the conductor [m].\n\nReturns\n\nRelative permeability (mu_r) of the conductor material [dimensionless].\n\nErrors\n\nThrows ArgumentError if radius_ext is less than radius_in.\n\nNotes\n\nAssumes a tubular geometry for the conductor, reducing to the solid case if radius_in is zero.\n\nExamples\n\ngmr = 0.015\nradius_ext = 0.02\nradius_in = 0.01\nmu_r = calc_equivalent_mu(gmr, radius_ext, radius_in)\nprintln(mu_r) # Expected output: ~1.7 [dimensionless]\n\nSee also\n\ncalc_tubular_gmr\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_equivalent_rho-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_equivalent_rho","text":"calc_equivalent_rho(\n    R::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext_con::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in_con::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the equivalent resistivity of a solid tubular conductor, using the formula [4]:\n\nrho_eq = R_eq S_eff = R_eq pi (r_ext^2 - r_in^2)\n\nwhere S_eff is the effective cross-sectional area of the tubular conductor.\n\nArguments\n\nR: Resistance of the conductor [Î©].\nradius_ext_con: External radius of the tubular conductor [m].\nradius_in_con: Internal radius of the tubular conductor [m].\n\nReturns\n\nEquivalent resistivity of the tubular conductor [Î©Â·m].\n\nExamples\n\nrho_eq = calc_equivalent_rho(0.01, 0.02, 0.01)  # Expected output: ~9.42e-4 [Î©Â·m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_gmd-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:LineCableModels.DataModel.AbstractCablePart, U<:LineCableModels.DataModel.AbstractCablePart}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_gmd","text":"calc_gmd(\n    co1::LineCableModels.DataModel.AbstractCablePart,\n    co2::LineCableModels.DataModel.AbstractCablePart\n) -> Any\n\n\nCalculates the geometric mean distance (GMD) between two cable parts, by using the  definition described in Grover [16]:\n\nlog GMD = left(fracsum_i=1^n_1sum_j=1^n_2 (s_1 cdot s_2) cdot log(d_ij)sum_i=1^n_1sum_j=1^n_2 (s_1 cdot s_2)right)\n\nwhere:\n\nd_ij is the Euclidean distance between elements i and j.\ns_1 and s_2 are the cross-sectional areas of the respective elements.\nn_1 and n_2 are the number of sub-elements in each cable part.\n\nArguments\n\nco1: First cable part (AbstractCablePart).\nco2: Second cable part (AbstractCablePart).\n\nReturns\n\nGeometric mean distance between the cable parts [m].\n\nNotes\n\nFor concentric structures, the GMD converges to the external radii of the outermost element.\n\ninfo: Numerical stability\nThis implementation uses a weighted sum of logarithms rather than the traditional product formula Pi(d_ij)^(1n) found in textbooks. The logarithmic approach prevents numerical underflow/overflow when dealing with many conductors or extreme distance ratios, making it significantly more stable for practical calculations.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\ncircstrands1 = CircStrands(0.01, 0.002, 7, 10, material_props)\ncircstrands2 = CircStrands(0.02, 0.002, 7, 15, material_props)\ngmd = calc_gmd(circstrands1, circstrands2)  # Expected output: GMD value [m]\n\nstrip = Strip(0.01, 0.002, 0.05, 10, material_props)\ntubular = Tubular(0.01, 0.02, material_props)\ngmd = calc_gmd(strip, tubular)  # Expected output: GMD value [m]\n\nSee also\n\ncalc_circstrands_coords\ncalc_equivalent_gmr\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_helical_params-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_helical_params","text":"calc_helical_params(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    lay_ratio::Union{Float64, Measurements.Measurement{Float64}}\n) -> Tuple{Union{Float64, Measurements.Measurement{Float64}}, Union{Float64, Measurements.Measurement{Float64}}, Union{Float64, Int64, Measurements.Measurement{Float64}}}\n\n\nCalculates the mean diameter, pitch length, and overlength based on cable geometry parameters. The lay ratio is defined as the ratio of the pitch length L_p to the external diameter D_e:\n\nlambda = fracL_pD_e\n\nwhere D_e and L_p are the dimensions represented in the figure.\n\n(Image: )\n\nArguments\n\nradius_in: Inner radius of the cable layer [m].\nradius_ext: Outer radius of the cable layer [m].\nlay_ratio: Ratio of the pitch (lay) length to the external diameter of the corresponding layer of wires [dimensionless].\n\nReturns\n\nmean_diameter: Mean diameter of the cable layer [m].\npitch_length: The length over which the strands complete one full twist [m].\noverlength: Effective length increase resulting from the helical path [1/m].\n\nNotes\n\nReference values for lay_ratio are given under standard EN 50182 [12]:\n\nConductor type Steel wires Aluminum wires Lay ratio - Steel Lay ratio - Aluminum\nAAAC 4 layers - 61 (1/6/12/18/24) - 15/13.5/12.5/11\nACSR 3 layers 7 (1/6) 54 (12/18/24) 19 15/13/11.5\nACSR 2 layers 7 (1/6) 26 (10/16) 19 14/11.5\nACSR 1 layer 7 (1/6) 10 19 14\nACCC/TW - 36 (8/12/16) - 15/13.5/11.5\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.015\nlay_ratio = 12\n\nmean_diam, pitch, overlength = calc_helical_params(radius_in, radius_ext, lay_ratio)\n# mean_diam â‰ˆ 0.025 [m]\n# pitch â‰ˆ 0.3 [m]\n# overlength > 1.0 [1/m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_inductance_trifoil-Union{Tuple{T}, NTuple{11, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_inductance_trifoil","text":"calc_inductance_trifoil(\n    r_in_co::Union{Float64, Measurements.Measurement{Float64}},\n    r_ext_co::Union{Float64, Measurements.Measurement{Float64}},\n    rho_co::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r_co::Union{Float64, Measurements.Measurement{Float64}},\n    r_in_scr::Union{Float64, Measurements.Measurement{Float64}},\n    r_ext_scr::Union{Float64, Measurements.Measurement{Float64}},\n    rho_scr::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r_scr::Union{Float64, Measurements.Measurement{Float64}},\n    S::Union{Float64, Measurements.Measurement{Float64}},\n    rho_e::Union{Float64, Measurements.Measurement{Float64}},\n    f::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the positive-sequence inductance of a trifoil-configured cable system composed of core/screen assuming solid bonding, using the formula given under section 4.2.4.3 of CIGRE TB-531:\n\nZ_d = leftZ_a - Z_xright - fracleft( Z_m - Z_x right)^2Z_s - Z_x\n\nL = mathfrakImleft(fracZ_domegaright)\n\nwhere Z_a, Z_s are the self impedances of the core conductor and the screen, and Z_m, and Z_x are the mutual impedances between core/screen and between cables, respectively, as per sections 4.2.3.4, 4.2.3.5, 4.2.3.6 and 4.2.3.8 of the same document [8].\n\nArguments\n\nr_in_co: Internal radius of the phase conductor [m].\nr_ext_co: External radius of the phase conductor [m].\nrho_co: Electrical resistivity of the phase conductor material [Î©Â·m].\nmu_r_co: Relative permeability of the phase conductor material [dimensionless].\nr_in_scr: Internal radius of the metallic screen [m].\nr_ext_scr: External radius of the metallic screen [m].\nrho_scr: Electrical resistivity of the metallic screen material [Î©Â·m].\nmu_r_scr: Relative permeability of the screen conductor material [dimensionless].\nS: Spacing between conductors in trifoil configuration [m].\nrho_e: Soil resistivity [Î©Â·m]. Default: 100 Î©Â·m.\nf: Frequency [Hz]. Default: fâ‚€.\n\nReturns\n\nPositive-sequence inductance per unit length of the cable system [H/m].\n\nExamples\n\nL = calc_inductance_trifoil(0.01, 0.015, 1.72e-8, 1.0, 0.02, 0.025, 2.83e-8, 1.0, S=0.1, rho_e=50, f=50)\nprintln(L) # Output: Inductance value in H/m\n\nSee also\n\ncalc_tubular_gmr\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_parallel_equivalent-Union{Tuple{T}, Tuple{T, T}} where T<:Union{Float64, Complex{Measurements.Measurement{Float64}}, Measurements.Measurement{Float64}, ComplexF64}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_parallel_equivalent","text":"calc_parallel_equivalent(\n    Z1::Union{Float64, Complex{Measurements.Measurement{Float64}}, Measurements.Measurement{Float64}, ComplexF64},\n    Z2::Union{Float64, Complex{Measurements.Measurement{Float64}}, Measurements.Measurement{Float64}, ComplexF64}\n) -> Any\n\n\nCalculates the parallel equivalent of two impedances (or series equivalent of two admittances):\n\nZ_eq = fracZ_1 Z_2Z_1 + Z_2\n\nThis expression, when applied recursively to LineCableModels.DataModel.CircStrands objects, implements the formula for the hexagonal wiring pattern described in CIGRE TB-345 [1] [17]:\n\nfrac1R_textdc = fracpi d^24 rho left( 1 + sum_1^n frac6nk_n right)\n\nk_n = left 1 + left( pi fracD_nlambda_n right)^2 right^12\n\nwhere R_textdc is the DC resistance, d is the diameter of each wire, ho is the resistivity, n is the number of layers following the hexagonal pattern, D_n is the diameter of the n-th layer, and lambda_n is the pitch length of the n-th layer, obtained using calc_helical_params.\n\nArguments\n\nZ1: The total impedance of the existing system [Î©].\nZ2: The impedance of the new layer being added [Î©].\n\nReturns\n\nThe parallel equivalent impedance [Î©].\n\nExamples\n\nZ1 = 5.0\nZ2 = 10.0\nReq = calc_parallel_equivalent(Z1, Z2)\nprintln(Req) # Outputs: 3.3333333333333335\n\nSee also\n\ncalc_helical_params\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_shunt_capacitance-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_shunt_capacitance","text":"calc_shunt_capacitance(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    epsr::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the shunt capacitance per unit length of a coaxial structure, using the standard formula for the capacitance of a coaxial structure [8] [4] [14]:\n\nC = frac2 pi varepsilon_0 varepsilon_rlog left(fracr_extr_inright)\n\nwhere varepsilon_0 is the vacuum permittivity, varepsilon_r is the relative permittivity of the dielectric material, and r_in and r_ext are the inner and outer radii of the coaxial structure, respectively.\n\nArguments\n\nradius_in: Internal radius of the coaxial structure [m].\nradius_ext: External radius of the coaxial structure [m].\nepsr: Relative permittivity of the dielectric material [dimensionless].\n\nReturns\n\nShunt capacitance per unit length [F/m].\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.02\nepsr = 2.3\ncapacitance = calc_shunt_capacitance(radius_in, radius_ext, epsr)\nprintln(capacitance) # Expected output: ~1.24e-10 [F/m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_shunt_conductance-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_shunt_conductance","text":"calc_shunt_conductance(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    rho::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the shunt conductance per unit length of a coaxial structure, using the improved model reported in [4] [13] [18]:\n\nG = frac2pisigmalog(fracr_extr_in)\n\nwhere sigma = frac1rho is the conductivity of the dielectric/semiconducting material, r_in is the internal radius, and r_ext is the external radius of the coaxial structure.\n\nArguments\n\nradius_in: Internal radius of the coaxial structure [m].\nradius_ext: External radius of the coaxial structure [m].\nrho: Resistivity of the dielectric/semiconducting material [Î©Â·m].\n\nReturns\n\nShunt conductance per unit length [SÂ·m].\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.02\nrho = 1e9\ng = calc_shunt_conductance(radius_in, radius_ext, rho)\nprintln(g) # Expected output: 2.7169e-9 [SÂ·m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_sigma_lossfact-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_sigma_lossfact","text":"calc_sigma_lossfact(\n    G_eq::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the effective conductivity of a dielectric material from the known conductance (related to the loss factor tan delta) via [4] [13] [18]:\n\nsigma_eq = fracG_eq2pi log(fracr_extr_in)\n\nwhere sigma_eq = frac1rho_eq is the conductivity of the dielectric/semiconducting material, G_eq is the shunt conductance per unit length, r_in is the internal radius, and r_ext is the external radius of the coaxial structure.\n\nArguments\n\nG_eq: Equivalent conductance of the material [SÂ·m].\nradius_in: Internal radius of the coaxial structure [m].\nradius_ext: External radius of the coaxial structure [m].\n\nReturns\n\nEffective material conductivity per unit length [SÂ·m].\n\nExamples\n\nGeq = 2.7169e-9\nsigma_eq = calc_sigma_lossfact(G_eq, radius_in, radius_ext)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_solenoid_correction-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_solenoid_correction","text":"calc_solenoid_correction(\n    num_turns::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext_con::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext_ins::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the solenoid correction factor for magnetic permeability in insulated cables with helical conductors (CircStrands), using the formula from Gudmundsdottir et al. [5]:\n\nmu_r sol = 1 + frac2 pi^2 N^2 (r_ins ext^2 - r_con ext^2)log(r_ins extr_con ext)\n\nwhere:\n\nN is the number of turns per unit length.\nr_con ext is the conductor external radius.\nr_ins ext is the insulator external radius.\n\nArguments\n\nnum_turns: Number of turns per unit length [1/m].\nradius_ext_con: External radius of the conductor [m].\nradius_ext_ins: External radius of the insulator [m].\n\nReturns\n\nCorrection factor for the insulator magnetic permeability [dimensionless].\n\nExamples\n\n# Cable with 10 turns per meter, conductor radius 5 mm, insulator radius 10 mm\ncorrection = calc_solenoid_correction(10, 0.005, 0.01)  # Expected output: > 1.0 [dimensionless]\n\n# Non-helical cable (straight conductor)\ncorrection = calc_solenoid_correction(NaN, 0.005, 0.01)  # Expected output: 1.0 [dimensionless]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_strip_resistance-Union{Tuple{T}, NTuple{6, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_strip_resistance","text":"calc_strip_resistance(\n    thickness::Union{Float64, Measurements.Measurement{Float64}},\n    width::Union{Float64, Measurements.Measurement{Float64}},\n    rho::Union{Float64, Measurements.Measurement{Float64}},\n    alpha::Union{Float64, Measurements.Measurement{Float64}},\n    T0::Union{Float64, Measurements.Measurement{Float64}},\n    Top::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the DC resistance of a strip conductor based on its geometric and material properties, using the basic resistance formula in terms of the resistivity and cross-sectional area:\n\nR = rho fracellW T\n\nwhere ell is the length of the strip, W is the width, and T is the thickness. The length is assumed to be infinite in the direction of current flow, so the resistance is calculated per unit length.\n\nArguments\n\nthickness: Thickness of the strip [m].\nwidth: Width of the strip [m].\nrho: Electrical resistivity of the conductor material [Î©Â·m].\nalpha: Temperature coefficient of resistivity [1/Â°C].\nT0: Reference temperature for the material properties [Â°C].\nTop: Operating temperature of the conductor [Â°C].\n\nReturns\n\nDC resistance of the strip conductor [Î©].\n\nExamples\n\nthickness = 0.002\nwidth = 0.05\nrho = 1.7241e-8\nalpha = 0.00393\nT0 = 20\nT = 25\nresistance = calc_strip_resistance(thickness, width, rho, alpha, T0, T)\n# Output: ~0.0001758 Î©\n\nSee also\n\ncalc_temperature_correction\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_temperature_correction-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_temperature_correction","text":"calc_temperature_correction(\n    alpha::Union{Float64, Measurements.Measurement{Float64}},\n    Top::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\ncalc_temperature_correction(\n    alpha::Union{Float64, Measurements.Measurement{Float64}},\n    Top::Union{Float64, Measurements.Measurement{Float64}},\n    T0::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the temperature correction factor for material properties based on the standard linear temperature model [17]:\n\nk(T) = 1 + alpha (T - T_0)\n\nwhere alpha is the temperature coefficient of the material resistivity, T is the operating temperature, and T_0 is the reference temperature. \n\nArguments\n\nalpha: Temperature coefficient of the material property [1/Â°C].\nT: Current temperature [Â°C].\nT0: Reference temperature at which the base material property was measured [Â°C]. Defaults to Tâ‚€.\n\nReturns\n\nTemperature correction factor to be applied to the material property [dimensionless].\n\nExamples\n\n\t# Copper resistivity correction (alpha = 0.00393 [1/Â°C])\n\tk = calc_temperature_correction(0.00393, 75.0, 20.0)  # Expected output: 1.2161\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_tubular_gmr-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_tubular_gmr","text":"calc_tubular_gmr(\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the geometric mean radius (GMR) of a tubular conductor, using [2]:\n\nlog GMR = log r_2 - mu_r left fracr_1^4left(r_2^2 - r_1^2right)^2 logleft(fracr_2r_1right) - frac3r_1^2 - r_2^24left(r_2^2 - r_1^2right) right\n\nwhere mu_r is the material magnetic permeability (relative to free space), r_1 and r_2 are the inner and outer radii of the tubular conductor, respectively. If r_2 is approximately equal to r_1 , the tube collapses into a thin shell, and the GMR is equal to r_2. If the tube becomes infinitely thick (e.g., r_2 gg r_1), the GMR diverges to infinity.\n\nArguments\n\nradius_ext: External radius of the tubular conductor [m].\nradius_in: Internal radius of the tubular conductor [m].\nmu_r: Relative permeability of the conductor material [dimensionless].\n\nReturns\n\nGeometric mean radius (GMR) of the tubular conductor [m].\n\nErrors\n\nThrows ArgumentError if radius_ext is less than radius_in.\n\nExamples\n\nradius_ext = 0.02\nradius_in = 0.01\nmu_r = 1.0\ngmr = calc_tubular_gmr(radius_ext, radius_in, mu_r)\nprintln(gmr) # Expected output: ~0.0135 [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_tubular_inductance-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_tubular_inductance","text":"calc_tubular_inductance(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    mu_r::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the inductance of a tubular conductor per unit length, disregarding skin-effects (DC approximation) [4] [17] [14]:\n\nL = fracmu_r mu_02 pi log left( fracr_extr_in right)\n\nwhere mu_r is the relative permeability of the conductor material, mu_0 is the vacuum permeability, and r_in and r_ext are the inner and outer radii of the conductor, respectively.\n\nArguments\n\nradius_in: Internal radius of the tubular conductor [m].\nradius_ext: External radius of the tubular conductor [m].\nmu_r: Relative permeability of the conductor material [dimensionless].\n\nReturns\n\nInternal inductance of the tubular conductor per unit length [H/m].\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.02\nmu_r = 1.0\nL = calc_tubular_inductance(radius_in, radius_ext, mu_r)\n# Output: ~2.31e-7 H/m\n\nSee also\n\ncalc_tubular_resistance\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.BaseParams.calc_tubular_resistance-Union{Tuple{T}, NTuple{6, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.DataModel.BaseParams.calc_tubular_resistance","text":"calc_tubular_resistance(\n    radius_in::Union{Float64, Measurements.Measurement{Float64}},\n    radius_ext::Union{Float64, Measurements.Measurement{Float64}},\n    rho::Union{Float64, Measurements.Measurement{Float64}},\n    alpha::Union{Float64, Measurements.Measurement{Float64}},\n    T0::Union{Float64, Measurements.Measurement{Float64}},\n    Top::Union{Float64, Measurements.Measurement{Float64}}\n) -> Union{Float64, Measurements.Measurement{Float64}}\n\n\nCalculates the DC resistance of a tubular conductor based on its geometric and material properties, using the resistivity and cross-sectional area of a hollow cylinder with radii r_in and r_ext:\n\nR = rho fracellpi (r_ext^2 - r_in^2)\n\nwhere ell is the length of the conductor, r_in and r_ext are the inner and outer radii, respectively. The length is assumed to be infinite in the direction of current flow, so the resistance is calculated per unit length.\n\nArguments\n\nradius_in: Internal radius of the tubular conductor [m].\nradius_ext: External radius of the tubular conductor [m].\nrho: Electrical resistivity of the conductor material [Î©Â·m].\nalpha: Temperature coefficient of resistivity [1/Â°C].\nT0: Reference temperature for the material properties [Â°C].\nTop: Operating temperature of the conductor [Â°C].\n\nReturns\n\nDC resistance of the tubular conductor [Î©].\n\nExamples\n\nradius_in = 0.01\nradius_ext = 0.02\nrho = 1.7241e-8\nalpha = 0.00393\nT0 = 20\nT = 25\nresistance = calc_tubular_resistance(radius_in, radius_ext, rho, alpha, T0, T)\n# Output: ~9.10e-8 Î©\n\nSee also\n\ncalc_temperature_correction\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps","page":"API reference","title":"LineCableModels.EarthProps","text":"LineCableModels.EarthProps\n\nThe EarthProps module provides functionality for modeling and computing earth properties within the LineCableModels.jl package. This module includes definitions for homogeneous and layered earth models, and formulations for frequency-dependent earth properties, to be used in impedance/admittance calculations.\n\nOverview\n\nDefines the EarthModel object for representing horizontally or vertically multi-layered earth models with frequency-dependent properties (Ï, Îµ, Î¼).\nProvides the EarthLayer type for representing individual soil layers with electromagnetic properties.\nImplements a multi-dispatch framework to allow different formulations of frequency-dependent earth models with AbstractFDEMFormulation.\nContains utility functions for building complex multi-layered earth models and generating data summaries.\n\nDependencies\n\nBase\nLineCableModels.Commons\nMeasurements\n\nExports\n\nCPEarth\nEarthLayer\nEarthModel\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.EarthProps.CPEarth","page":"API reference","title":"LineCableModels.EarthProps.CPEarth","text":"struct CPEarth <: LineCableModels.EarthProps.AbstractFDEMFormulation\n\nRepresents an earth model with constant properties (CP), i.e. frequency-invariant electromagnetic properties.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.EarthProps.CPEarth-Union{Tuple{T}, Tuple{Vector{T}, T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.CPEarth","text":"Functor implementation for CPEarth.\n\nComputes frequency-dependent earth properties using the CPEarth formulation, which assumes frequency-invariant values for resistivity, permittivity, and permeability.\n\nArguments\n\nfrequencies: Vector of frequency values [Hz].\nbase_rho_g: Base (DC) electrical resistivity of the soil [Î©Â·m].\nbase_epsr_g: Base (DC) relative permittivity of the soil [dimensionless].\nbase_mur_g: Base (DC) relative permeability of the soil [dimensionless].\nformulation: Instance of a subtype of AbstractFDEMFormulation defining the computation method.\n\nReturns\n\nrho: Vector of resistivity values [Î©Â·m] at the given frequencies.\nepsilon: Vector of permittivity values [F/m] at the given frequencies.\nmu: Vector of permeability values [H/m] at the given frequencies.\n\nExamples\n\nfrequencies = [1e3, 1e4, 1e5]\n\n# Using the CP model\nrho, epsilon, mu = CPEarth(frequencies, 100, 10, 1, CPEarth())\nprintln(rho)     # Output: [100, 100, 100]\nprintln(epsilon) # Output: [8.854e-11, 8.854e-11, 8.854e-11]\nprintln(mu)      # Output: [1.2566e-6, 1.2566e-6, 1.2566e-6]\n\nSee also\n\nEarthLayer\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.EarthLayer","page":"API reference","title":"LineCableModels.EarthProps.EarthLayer","text":"struct EarthLayer{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents one single earth layer in an EarthModel object, with base and frequency-dependent properties, and attributes:\n\nbase_rho_g::Union{Float64, Measurements.Measurement{Float64}}: Base (DC) electrical resistivity [Î©Â·m].\nbase_epsr_g::Union{Float64, Measurements.Measurement{Float64}}: Base (DC) relative permittivity [dimensionless].\nbase_mur_g::Union{Float64, Measurements.Measurement{Float64}}: Base (DC)  relative permeability [dimensionless].\nt::Union{Float64, Measurements.Measurement{Float64}}: Thickness of the layer [m].\nrho_g::Vector{T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Computed resistivity values [Î©Â·m] at given frequencies.\neps_g::Vector{T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Computed permittivity values [F/m] at given frequencies.\nmu_g::Vector{T} where T<:Union{Float64, Measurements.Measurement{Float64}}: Computed permeability values [H/m] at given frequencies.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.EarthProps.EarthLayer-Union{Tuple{T}, Tuple{T, T, T, T, Vector{T}, Vector{T}, Vector{T}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.EarthLayer","text":"Constructs an EarthLayer instance with specified base and frequency-dependent properties.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.EarthLayer-Union{Tuple{T}, Tuple{Vector{T}, T, T, T, T, LineCableModels.EarthProps.AbstractFDEMFormulation}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.EarthLayer","text":"EarthLayer(\n    frequencies::Array{T<:Union{Float64, Measurements.Measurement{Float64}}, 1},\n    base_rho_g::Union{Float64, Measurements.Measurement{Float64}},\n    base_epsr_g::Union{Float64, Measurements.Measurement{Float64}},\n    base_mur_g::Union{Float64, Measurements.Measurement{Float64}},\n    t::Union{Float64, Measurements.Measurement{Float64}},\n    freq_dependence::LineCableModels.EarthProps.AbstractFDEMFormulation\n) -> LineCableModels.EarthProps.EarthLayer\n\n\nConstructs an EarthLayer instance with specified base properties and computes its frequency-dependent values.\n\nArguments\n\nfrequencies: Vector of frequency values [Hz].\nbase_rho_g: Base (DC) electrical resistivity of the layer [Î©Â·m].\nbase_epsr_g: Base (DC) relative permittivity of the layer [dimensionless].\nbase_mur_g: Base (DC) relative permeability of the layer [dimensionless].\nt: Thickness of the layer [m].\nfreq_dependence: Instance of a subtype of AbstractFDEMFormulation defining the computation method for frequency-dependent properties.\n\nReturns\n\nAn EarthLayer instance with computed frequency-dependent properties.\n\nExamples\n\nfrequencies = [1e3, 1e4, 1e5]\nlayer = EarthLayer(frequencies, 100, 10, 1, 5, CPEarth())\nprintln(layer.rho_g) # Output: [100, 100, 100]\nprintln(layer.eps_g) # Output: [8.854e-11, 8.854e-11, 8.854e-11]\nprintln(layer.mu_g)  # Output: [1.2566e-6, 1.2566e-6, 1.2566e-6]\n\nSee also\n\nCPEarth\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.EarthModel","page":"API reference","title":"LineCableModels.EarthProps.EarthModel","text":"struct EarthModel{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nRepresents a multi-layered earth model with frequency-dependent properties, and attributes:\n\nfreq_dependence::LineCableModels.EarthProps.AbstractFDEMFormulation: Selected frequency-dependent formulation for earth properties.\nvertical_layers::Bool: Boolean flag indicating whether the model is treated as vertically layered.\nlayers::Array{LineCableModels.EarthProps.EarthLayer{T}, 1} where T<:Union{Float64, Measurements.Measurement{Float64}}: Vector of EarthLayer objects, starting with an air layer and the specified first earth layer.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.EarthProps.EarthModel-Union{Tuple{T}, Tuple{LineCableModels.EarthProps.AbstractFDEMFormulation, Bool, Array{LineCableModels.EarthProps.EarthLayer{T}, 1}}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.EarthModel","text":"Constructs an EarthModel instance with specified attributes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.EarthModel-Union{Tuple{T}, Tuple{Vector{T}, T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.EarthProps.EarthModel","text":"EarthModel(\n    frequencies::Array{T<:Union{Float64, Measurements.Measurement{Float64}}, 1},\n    rho_g::Union{Float64, Measurements.Measurement{Float64}},\n    epsr_g::Union{Float64, Measurements.Measurement{Float64}},\n    mur_g::Union{Float64, Measurements.Measurement{Float64}};\n    t,\n    freq_dependence,\n    vertical_layers,\n    air_layer\n) -> EarthModel\n\n\nConstructs an EarthModel instance with a specified first earth layer. A semi-infinite air layer is always added before the first earth layer.\n\nArguments\n\nfrequencies: Vector of frequency values [Hz].\nrho_g: Base (DC) electrical resistivity of the first earth layer [Î©Â·m].\nepsr_g: Base (DC) relative permittivity of the first earth layer [dimensionless].\nmur_g: Base (DC) relative permeability of the first earth layer [dimensionless].\nt: Thickness of the first earth layer [m]. For homogeneous earth models (or the bottommost layer), set t = Inf.\nfreq_dependence: Instance of a subtype of AbstractFDEMFormulation defining the computation method for frequency-dependent properties (default: CPEarth).\nvertical_layers: Boolean flag indicating whether the model should be treated as vertically-layered (default: false).\nair_layer: optional EarthLayer object representing the semi-infinite air layer (default: EarthLayer(frequencies, Inf, 1.0, 1.0, Inf, freq_dependence)).\n\nReturns\n\nAn EarthModel instance with the specified attributes and computed frequency-dependent properties.\n\nExamples\n\nfrequencies = [1e3, 1e4, 1e5]\nearth_model = EarthModel(frequencies, 100, 10, 1, t=Inf)\nprintln(length(earth_model.layers)) # Output: 2 (air + top layer)\nprintln(earth_model.rho_eff) # Output: missing\n\nSee also\n\nEarthLayer\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.ImportExport","page":"API reference","title":"LineCableModels.ImportExport","text":"LineCableModels.ImportExport\n\nThe ImportExport module provides methods for serializing and deserializing data structures in LineCableModels.jl, and data exchange with external programs.\n\nOverview\n\nThis module provides functionality for:\n\nSaving and loading cable designs and material libraries to/from JSON and other formats.\nExporting cable system models to PSCAD and ATP formats.\nSerializing custom types with special handling for measurements and complex numbers.\n\nThe module implements a generic serialization framework with automatic type reconstruction and proper handling of Julia-specific types like Measurement objects and Inf/NaN values.\n\nDependencies\n\nBase\nDataFrames\nDates\nEzXML\nJSON3\nLineCableModels.Commons\nLinearAlgebra\nMeasurements\nPrintf\nSerialization\nTables\nXLSX\n\nExports\n\nexport_data\nload!\nread_data\nsave\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.ImportExport.export_data-Tuple{Val{:atp}, LineCableSystem, EarthModel}","page":"API reference","title":"LineCableModels.ImportExport.export_data","text":"export_data(\n    ::Val{:atp},\n    cable_system::LineCableSystem,\n    earth_props::EarthModel;\n    base_freq,\n    file_name\n) -> Union{Nothing, String}\n\n\nExport a LineCableSystem to an ATPDrawâ€‘compatible XML file (LCC component with input data).\n\nThis routine serializes the cable system geometry (positions and outer radii) and the alreadyâ€‘computed, frequencyâ€‘specific equivalent parameters of each cable component to the ATPDraw XML schema. The result is written to disk and the absolute file path is returned on success.\n\nArguments\n\n::Val{:atp}: Backend selector for the ATP/ATPDraw exporter.\ncable_system::LineCableSystem: The system to export. Each entry in cable_system.cables provides one phase position and its associated CableDesign. The number of phases exported equals length(cable_system.cables).\nearth_props::EarthModel: Ground model used to populate ATP soil parameters. The exporter\n\nuses the last layerâ€™s base resistivity as Grnd resis.\n\nbase_freq::Number = fâ‚€ [Hz]: System frequency written to ATP (SysFreq) and stored in component metadata. *This exporter does not recompute R/L/C/G; it writes the values as\n\npresent in the groups/components at the time of export.*\n\nfile_name::String = \"*_export.xml\": Output file name or path. If a relative path is given, it is resolved against the exporterâ€™s source directory. The absolute path of the saved file is returned.\n\nBehavior\n\nCreate the ATPDraw <project> root and header and insert a single LCC component with NumPhases = length(cable_system.cables).\nFor each CablePosition in cable_system.cables:\nWrite a <cable> element with:\n\n * `NumCond` = number of [`CableComponent`](@ref)s in the design,\n * `Rout` = outermost radius of the design (m),\n * `PosX`, `PosY` = cable coordinates (m).\n\nFor each CableComponent inside a cable:\nWrite one <conductor> element with fields (all per unit length):\n\n * `Rin`, `Rout` â€” from the componentâ€™s conductor group,\n * `rho` â€” conductor equivalence via [`calc_equivalent_rho`](@ref),\n * `muC` â€” conductor relative permeability via [`calc_equivalent_mu`](@ref),\n * `muI` â€” insulator relative permeability (taken from the first insulating layerâ€™s material),\n * `epsI` â€” insulation relative permittivity via [`calc_equivalent_eps`](@ref),\n * `Cext`, `Gext` â€” shunt capacitance and conductance from the componentâ€™s insulator group.\n\nSoil resistivity is written as Grnd resis using earth_props.layers[end].base_rho_g.\nThe XML is prettyâ€‘printed and written to file_name. On I/O error, the function logs an error and returns nothing.\n\nUnits\n\nUnits are printed in the XML file according to the ATPDraw specifications:\n\nRadii (Rin, Rout, Rout of cable): [m]\nCoordinates (PosX, PosY): [m]\nLength (Length tag): [m]\nFrequency (SysFreq/Freq): [Hz]\nResistivity (rho, Grnd resis): [Î©Â·m]\nRelative permittivity (epsI) / permeability (muC, muI): [dimensionless]\nShunt capacitance (Cext): [F/m]\nShunt conductance (Gext): [S/m]\n\nNotes\n\nThe exporter assumes each componentâ€™s equivalent parameters (R/G/C and derived Ï/Îµ/Î¼) were already computed by the design/group constructors at the operating conditions of interest.\nMixed numeric types are supported; values are stringified for XML output. When using uncertainty types (e.g., Measurements.Measurement), the uncertainty is removed.\nOverlap checks between cables are enforced when building the system, not during export.\n\nExamples\n\n# Build or load a system `sys` and an earth model `earth`\nfile = export_data(Val(:atp), sys, earth; base_freq = 50.0,\n\t\t\t\t\t   file_name = \"system_id_export.xml\")\nprintln(\"Exported to: \", file)\n\nSee also\n\nLineCableSystem, CablePosition, CableComponent\nEarthModel\ncalc_equivalent_rho, calc_equivalent_mu, calc_equivalent_eps\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.ImportExport.export_data-Tuple{Val{:atp}, LineParameters}","page":"API reference","title":"LineCableModels.ImportExport.export_data","text":"export_data(\n    ::Val{:atp},\n    line_params::LineParameters;\n    file_name,\n    cable_system\n) -> Union{Nothing, String}\n\n\nExport calculated LineParameters (series impedance Z and shunt admittance Y) to an compliant ZY XML file.\n\nThis routine writes the complex Z and Y matrices versus frequency into a compact XML structure understood by external tools. Rows are emitted as commaâ€‘separated complex entries (R+Xi / G+Bi) with one <Z>/<Y> block per frequency sample.\n\nArguments\n\n::Val{:atp}: Backend selector for the ATP/ATPDraw ZY exporter.\nline_params::LineParameters: Object holding the frequencyâ€‘dependent matrices Z[:,:,k], Y[:,:,k], and f[k] in line_params.f.\nfile_name::String = \"ZY_export.xml\": Output file name or path. If relative, it is resolved against the exporterâ€™s source directory. The absolute path of the saved file is returned.\ncable_system::Union{LineCableSystem,Nothing} = nothing: Optional system used only to derive a default name. When provided and file_name is not overridden, the exporter uses \"$(cable_system.system_id)_ZY_export.xml\".\n\nBehavior\n\nThe root tag <ZY> includes NumPhases, Length (fixed to 1.0), and format attributes ZFmt=\"R+Xi\", YFmt=\"G+Bi\".\nFor each frequency fáµ = line_params.f[k]:\nEmit a <Z Freq=...> block with num_phases lines, each line the kâ€‘th slice of row i formatted as real(Z[i,j,k]) + imag(Z[i,j,k])i.\nEmit a <Y Freq=...> block in the same fashion (default G+Bi).\nClose the </ZY> element and write to disk. On I/O error the function logs and returns nothing.\n\nUnits\n\nUnits are printed in the XML file according to the ATPDraw specifications:\n\nfreq (XML Freq attribute): [Hz]\nZ entries: [Î©/km] (per unit length)\nY entries: [S/km] (per unit length) when YFmt = \"G+Bi\"\nXML Length attribute: [m]\n\nNotes\n\nThe exporter assumes size(line_params.Z, 1) == size(line_params.Z, 2) == size(line_params.Y, 1) == size(line_params.Y, 2) and length(line_params.f) == size(Z,3) == size(Y,3).\nNumeric types are stringified; mixed numeric backends (e.g., with uncertainties) are acceptable as long as they can be printed via @sprintf.\nThis exporter does not modify or recompute matrices; it serializes exactly what is in line_params.\n\nExamples\n\n# Z, Y, f have already been computed into `lp::LineParameters`\nfile = export_data(:atp, lp; file_name = \"ZY_export.xml\")\nprintln(\"Exported ZY to: \", file)\n\n# Naming based on a cable system\nfile2 = export_data(:atp, lp; cable_system = sys)\nprintln(\"Exported ZY to: \", file2)  # => \"$(sys.system_id)_ZY_export.xml\"\n\nSee also\n\nLineParameters\nLineCableSystem\nexport_data(::Val{:atp}, cable_system, ...) â€” exporter that writes full LCC input data\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.ImportExport.export_data-Tuple{Val{:pscad}, LineCableSystem, EarthModel}","page":"API reference","title":"LineCableModels.ImportExport.export_data","text":"export_data(\n    ::Val{:pscad},\n    cable_system::LineCableSystem,\n    earth_props::EarthModel;\n    base_freq,\n    file_name\n) -> Union{Nothing, String}\n\n\nExports a LineCableSystem to a PSCAD-compatible file format.\n\nArguments\n\ncable_system: A LineCableSystem object representing the cable system to be exported.\nearth_props: An EarthModel object containing the earth properties.\nbase_freq: The base frequency [Hz] used for the PSCAD export.\nfile_name: The path to the output file (default: \"*_export.pscx\")\n\nReturns\n\nThe absolute path of the saved file, or nothing on failure.\n\nExamples\n\ncable_system = LineCableSystem(...)\nearth_model = EarthModel(...)\nexport_data(cable_system, earth_model, base_freq=50)\n\nSee also\n\nLineCableSystem\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.ImportExport.load!-Tuple{CablesLibrary}","page":"API reference","title":"LineCableModels.ImportExport.load!","text":"load!(library::CablesLibrary; file_name) -> CablesLibrary\n\n\nLoads cable designs from a file into an existing CablesLibrary object. Modifies the library in-place. The format is determined by the file extension:\n\n.json: Loads using the custom JSON deserialization and reconstruction.\n.jls: Loads using Julia's native binary deserialization.\n\nArguments\n\nlibrary: The CablesLibrary instance to populate (modified in-place).\nfile_name: Path to the file to load (default: \"cables_library.json\").\n\nReturns\n\nThe modified CablesLibrary instance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.ImportExport.load!-Tuple{MaterialsLibrary}","page":"API reference","title":"LineCableModels.ImportExport.load!","text":"load!(\n    library::MaterialsLibrary;\n    file_name\n) -> MaterialsLibrary\n\n\nLoads materials from a JSON file into an existing MaterialsLibrary object. Modifies the library in-place.\n\nArguments\n\nlibrary: The MaterialsLibrary instance to populate (modified in-place).\nfile_name: Path to the JSON file to load (default: \"materials_library.json\").\n\nReturns\n\nThe modified MaterialsLibrary instance.\n\nSee also\n\nMaterialsLibrary\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.ImportExport.save-Tuple{CablesLibrary}","page":"API reference","title":"LineCableModels.ImportExport.save","text":"save(\n    library::CablesLibrary;\n    file_name\n) -> Union{Nothing, String}\n\n\nSaves a CablesLibrary to a file. The format is determined by the file extension:\n\n.json: Saves using the custom JSON serialization.\n.jls: Saves using Julia native binary serialization.\n\nArguments\n\nlibrary: The CablesLibrary instance to save.\nfile_name: The path to the output file (default: \"cables_library.json\").\n\nReturns\n\nThe absolute path of the saved file, or nothing on failure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.ImportExport.save-Tuple{MaterialsLibrary}","page":"API reference","title":"LineCableModels.ImportExport.save","text":"save(\n    library::MaterialsLibrary;\n    file_name\n) -> Union{Nothing, String}\n\n\nSaves a MaterialsLibrary to a JSON file.\n\nArguments\n\nlibrary: The MaterialsLibrary instance to save.\nfile_name: The path to the output JSON file (default: \"materials_library.json\").\n\nReturns\n\nThe absolute path of the saved file, or nothing on failure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Materials","page":"API reference","title":"LineCableModels.Materials","text":"LineCableModels.Materials\n\nThe Materials module provides functionality for managing and utilizing material properties within the LineCableModels.jl package. This module includes definitions for material properties, a library for storing and retrieving materials, and functions for manipulating material data.\n\nOverview\n\nDefines the Material struct representing fundamental physical properties of materials.\nProvides the MaterialsLibrary mutable struct for storing a collection of materials.\nIncludes functions for adding, removing, and retrieving materials from the library.\nSupports loading and saving material data from/to JSON files.\nContains utility functions for displaying material data.\n\nDependencies\n\nBase\nLineCableModels.Commons\nMeasurements\n\nExports\n\nMaterial\nMaterialsLibrary\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.Materials.Material","page":"API reference","title":"LineCableModels.Materials.Material","text":"struct Material{T<:Union{Float64, Measurements.Measurement{Float64}}}\n\nDefines electromagnetic and thermal properties of a material used in cable modeling:\n\nrho::Union{Float64, Measurements.Measurement{Float64}}: Electrical resistivity of the material [Î©Â·m].\neps_r::Union{Float64, Measurements.Measurement{Float64}}: Relative permittivity [dimensionless].\nmu_r::Union{Float64, Measurements.Measurement{Float64}}: Relative permeability [dimensionless].\nT0::Union{Float64, Measurements.Measurement{Float64}}: Reference temperature for property evaluations [Â°C].\nalpha::Union{Float64, Measurements.Measurement{Float64}}: Temperature coefficient of resistivity [1/Â°C].\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.Materials.Material-NTuple{5, Any}","page":"API reference","title":"LineCableModels.Materials.Material","text":"Material(rho, eps_r, mu_r, T0, alpha) -> Material\n\n\nWeakly-typed constructor that infers the target scalar type T from the arguments, coerces values to T, and calls the strict numeric kernel.\n\nArguments\n\nrho: Resistivity [Î©Â·m].\neps_r: Relative permittivity [1].\nmu_r: Relative permeability [1].\nT0: Reference temperature [Â°C].\nalpha: Temperature coefficient of resistivity [1/Â°C].\n\nReturns\n\nMaterial{T} where T = resolve_T(rho, eps_r, mu_r, T0, alpha).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Materials.MaterialsLibrary","page":"API reference","title":"LineCableModels.Materials.MaterialsLibrary","text":"mutable struct MaterialsLibrary <: AbstractDict{String, Material}\n\nStores a collection of predefined materials for cable modeling, indexed by material name:\n\ndata::Dict{String, Material}: Dictionary mapping material names to Material objects.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.Materials.MaterialsLibrary-Tuple{}","page":"API reference","title":"LineCableModels.Materials.MaterialsLibrary","text":"MaterialsLibrary(; add_defaults) -> MaterialsLibrary\n\n\nConstructs an empty MaterialsLibrary instance and initializes with default materials.\n\nArguments\n\nNone.\n\nReturns\n\nA MaterialsLibrary object populated with default materials.\n\nExamples\n\n# Create a new, empty library\nlibrary = MaterialsLibrary()\n\nSee also\n\nMaterial\n_add_default_materials!\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils","page":"API reference","title":"LineCableModels.Utils","text":"LineCableModels.Utils\n\nThe Utils module provides utility functions for the  LineCableModels.jl package. This module includes functions for handling measurements, numerical comparisons, and other common tasks.\n\nOverview\n\nProvides general constants used throughout the package.\nIncludes utility functions for numerical comparisons and handling measurements.\nContains functions to compute uncertainties and bounds for measurements.\n\nDependencies\n\nBase\nDates\nLineCableModels.Commons\nLinearAlgebra\nLogging\nMacroTools\nPlots\nPrintf\nStatistics\n\nExports\n\n_bessel_diff\n_to_Ïƒ\nbias_to_uncertain\ncoerce_to_T\ndisplay_path\nis_headless\nis_in_testset\nline_transpose!\n@measurify\n@parameterize\npercent_error\npercent_to_uncertain\nresolve_T\nset_verbosity!\nsymtrans!\nto_certain\nto_lower\nto_nominal\nto_upper\n\n\n\n\n\n","category":"module"},{"location":"reference/#LineCableModels.Utils.bias_to_uncertain-Tuple{Float64, Vector{<:Measurements.Measurement}}","page":"API reference","title":"LineCableModels.Utils.bias_to_uncertain","text":"bias_to_uncertain(\n    nominal::Float64,\n    measurements::Vector{<:Measurements.Measurement}\n) -> Any\n\n\nComputes the uncertainty of a measurement by incorporating systematic bias.\n\nArguments\n\nnominal: The deterministic nominal value (Float64).\nmeasurements: A vector of Measurement values from the Measurements.jl package.\n\nReturns\n\nA new Measurement object representing the mean measurement value with an uncertainty that accounts for both statistical variation and systematic bias.\n\nNotes\n\nComputes the mean value and its associated uncertainty from the given measurements.\nDetermines the bias as the absolute difference between the deterministic nominal value and the mean measurement.\nThe final uncertainty is the sum of the standard uncertainty (sigma_mean) and the systematic bias.\n\nExamples\n\nusing Measurements\n\nnominal = 10.0\nmeasurements = [10.2 Â± 0.1, 9.8 Â± 0.2, 10.1 Â± 0.15]\nresult = bias_to_uncertain(nominal, measurements)\nprintln(result)  # Output: Measurement with adjusted uncertainty\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.coerce_to_T","page":"API reference","title":"LineCableModels.Utils.coerce_to_T","text":"Public coercion API. Converts scalars and containers to a target type T, applying elementâ€‘wise coercion recursively. Complex numbers are handled by splitting into real and imaginary parts and coercing each side independently.\n\nArguments\n\nx: Input value (scalar or container) [dimensionless].\n::Type{T}: Target type [dimensionless].\n\nReturns\n\nValue coerced to the target type:\nFor Real â†’ Complex{P}: constructs Complex{P}(coerce_to_T(re, P), coerce_to_T(im, P)) (imaginary part from 0).\nFor Complex â†’ Real: discards the imaginary part and coerces the real part.\nFor AbstractArray, Tuple, NamedTuple: coerces each element recursively.\nFor other types: defers to _coerce_elt_to_T.\n\nExamples\n\nusing Measurements\n\n# Scalar\ncoerce_to_T(1.2, Float32)                         # 1.2f0\ncoerce_to_T(1.2, Measurement{Float64})            # 1.2 Â± 0.0\ncoerce_to_T(1 + 2im, Complex{Float32})            # 1.0f0 + 2.0f0im\ncoerce_to_T(1 + 2im, Float64)                     # 1.0\n\n# Containers\ncoerce_to_T([1.0, 2.0], Measurement{Float64})     # measurement array\ncoerce_to_T((1.0, 2.0), Float32)                  # (1.0f0, 2.0f0)\ncoerce_to_T((; a=1.0, b=2.0), Float32)            # (a = 1.0f0, b = 2.0f0)\n\nMethods\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:262.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:266.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:269.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:272.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:276.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:279.\n\ncoerce_to_T(A, _)\n\ndefined at typecoercion.jl:283.\n\ncoerce_to_T(A, _)\n\ndefined at typecoercion.jl:284.\n\ncoerce_to_T(t, _)\n\ndefined at typecoercion.jl:287.\n\ncoerce_to_T(t, _)\n\ndefined at typecoercion.jl:288.\n\ncoerce_to_T(nt, _)\n\ndefined at typecoercion.jl:292.\n\ncoerce_to_T(nt, _)\n\ndefined at typecoercion.jl:294.\n\ncoerce_to_T(x, _)\n\ndefined at typecoercion.jl:298.\n\nSee also\n\n_coerce_elt_to_T\nresolve_T\n\n\n\n\n\n","category":"function"},{"location":"reference/#LineCableModels.Utils.is_headless-Tuple{}","page":"API reference","title":"LineCableModels.Utils.is_headless","text":"is_headless() -> Bool\n\n\nDetermines if the current execution environment is headless (without display capability).\n\nReturns\n\ntrue if running in a continuous integration environment or without display access.\nfalse otherwise when a display is available.\n\nExamples\n\nif is_headless()\n\t# Use non-graphical backend\n\tgr()\nelse\n\t# Use interactive backend\n\tplotlyjs()\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.is_in_testset-Tuple{}","page":"API reference","title":"LineCableModels.Utils.is_in_testset","text":"is_in_testset() -> Any\n\n\nChecks if the code is running inside a @testset by checking if Test is loaded in the current session and then calling get_testset_depth().\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.percent_error-Tuple{Number}","page":"API reference","title":"LineCableModels.Utils.percent_error","text":"percent_error(m::Number) -> Any\n\n\nComputes the percentage uncertainty of a measurement.\n\nArguments\n\nm: A numerical value, expected to be of type Measurement from the Measurements.jl package.\n\nReturns\n\nThe percentage uncertainty, computed as 100 * uncertainty(m) / value(m), if m is a Measurement.\nNaN if m is not a Measurement.\n\nExamples\n\nusing Measurements\n\nm = 10.0 Â± 2.0\npercent_err = percent_error(m)  # Output: 20.0\n\nnot_a_measurement = 5.0\npercent_err_invalid = percent_error(not_a_measurement)  # Output: NaN\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.percent_to_uncertain-Tuple{Any, Any}","page":"API reference","title":"LineCableModels.Utils.percent_to_uncertain","text":"percent_to_uncertain(val, perc) -> Any\n\n\nConverts a value to a measurement with uncertainty based on percentage.\n\nArguments\n\nval: The nominal value.\nperc: The percentage uncertainty (0 to 100).\n\nReturns\n\nA Measurement type with the given value and calculated uncertainty.\n\nExamples\n\nusing Measurements\n\npercent_to_uncertain(100.0, 5)  # Output: 100.0 Â± 5.0\npercent_to_uncertain(10.0, 10)  # Output: 10.0 Â± 1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.resolve_T-Tuple","page":"API reference","title":"LineCableModels.Utils.resolve_T","text":"resolve_T(args...) -> Type\n\n\nResolves the promotion target type to be used by constructors and coercion utilities based on the runtime arguments. The decision uses structureâ€‘aware predicates for Measurement and Complex:\n\nIf any argument contains Measurement and any contains Complex, returns Complex{Measurement{BASE_FLOAT}}.\nElse if any contains Measurement, returns Measurement{BASE_FLOAT}.\nElse if any contains Complex, returns Complex{BASE_FLOAT}.\nOtherwise returns BASE_FLOAT.\n\nArguments\n\nargs...: Values whose types will drive the promotion decision [dimensionless].\n\nReturns\n\nA Type suitable for numeric promotion in subsequent coercion.\n\nExamples\n\nusing Measurements\n\nT = resolve_T(1.0, 2.0)                       # BASE_FLOAT\nT = resolve_T(1 + 0im, 2.0)                    # Complex{BASE_FLOAT}\nT = resolve_T(measurement(1.0, 0.1), 2.0)      # Measurement{BASE_FLOAT}\nT = resolve_T(measurement(1.0, 0.1), 2 + 0im)  # Complex{Measurement{BASE_FLOAT}}\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.to_certain-Tuple{Any}","page":"API reference","title":"LineCableModels.Utils.to_certain","text":"to_certain(value) -> Any\n\n\nConverts a measurement to a value with zero uncertainty, retaining the numeric type Measurement.\n\nArguments\n\nvalue: Input value that may be a Measurement type or another type.\n\nReturns\n\nIf input is a Measurement, returns the same value with zero uncertainty; otherwise returns the original value unchanged.\n\nExamples\n\nx = 5.0 Â± 0.1\nresult = to_certain(x)  # Output: 5.0 Â± 0.0\n\ny = 10.0\nresult = to_certain(y)  # Output: 10.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.to_lower-Tuple{Number}","page":"API reference","title":"LineCableModels.Utils.to_lower","text":"to_lower(m::Number) -> Any\n\n\nComputes the lower bound of a measurement value.\n\nArguments\n\nm: A numerical value, expected to be of type Measurement from the Measurements.jl package.\n\nReturns\n\nThe lower bound, computed as value(m) - uncertainty(m) if m is a Measurement.\nNaN if m is not a Measurement.\n\nExamples\n\nusing Measurements\n\nm = 10.0 Â± 2.0\nlower = to_lower(m)  # Output: 8.0\n\nnot_a_measurement = 5.0\nlower_invalid = to_lower(not_a_measurement)  # Output: NaN\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.to_nominal-Tuple{Measurements.Measurement}","page":"API reference","title":"LineCableModels.Utils.to_nominal","text":"to_nominal(x::Measurements.Measurement) -> AbstractFloat\n\n\nReturns the nominal (deterministic) value of inputs that may contain Measurements.Measurement numbers, recursively handling Complex and arrays.\n\nArguments\n\nx: Input value which can be a Measurement type or any other type.\n\nReturns\n\nMeasurement â†’ its value\nComplex â†’ complex(to_nominal(real(z)), to_nominal(imag(z)))\nAbstractArray â†’ broadcasts to_nominal elementwise\nAnything else â†’ returned unchanged\n\nExamples\n\nusing Measurements\n\nto_nominal(1.0)  # Output: 1.0\nto_nominal(5.2 Â± 0.3)  # Output: 5.2\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.to_upper-Tuple{Number}","page":"API reference","title":"LineCableModels.Utils.to_upper","text":"to_upper(m::Number) -> Any\n\n\nComputes the upper bound of a measurement value.\n\nArguments\n\nm: A numerical value, expected to be of type Measurement from the Measurements.jl package.\n\nReturns\n\nThe upper bound of m, computed as value(m) + uncertainty(m) if m is a Measurement.\nNaN if m is not a Measurement.\n\nExamples\n\nusing Measurements\n\nm = 10.0 Â± 2.0\nupper = to_upper(m)  # Output: 12.0\n\nnot_a_measurement = 5.0\nupper_invalid = to_upper(not_a_measurement)  # Output: NaN\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.@measurify-Tuple{Any}","page":"API reference","title":"LineCableModels.Utils.@measurify","text":"@measurify(function_definition)\n\nWraps a function definition. If any argument tied to a parametric type T is a Measurement, this macro automatically promotes any other arguments of the same parametric type T to Measurement with zero uncertainty. Other arguments (e.g., i::Int) are forwarded without changes.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#LineCableModels.UncertainBessels","page":"API reference","title":"LineCableModels.UncertainBessels","text":"LineCableModels.UncertainBessels\n\nUncertainty-aware wrappers for Bessel functions.\n\nUncertainBessels lifts selected functions from SpecialFunctions so they accept Measurement and Complex{Measurement} inputs. The wrapper evaluates the underlying function at the nominal complex argument and propagates uncertainty via first-order finite differences using the four partial derivatives fracpartial mathrmRe  fpartial x fracpartial mathrmRe  fpartial y fracpartial mathrmIm  fpartial x fracpartial mathrmIm  fpartial y with x = mathrmRe(z) and y = mathrmIm(z). No new Bessel algorithms are implemented: for plain numeric inputs, results and numerical behaviour are those of SpecialFunctions.\n\nNumerical scaling (as defined by SpecialFunctions) is supported for the â€œxâ€ variants (e.g. besselix, besselkx, besseljx, â€¦) to improve stability for large or complex arguments. In particular, the modified functions use exponential factors to temper growth along mathrmRe(z) (e.g. I_nu and K_nu); other scaled variants follow conventions in SpecialFunctions and DLMF guidance for complex arguments. See [19] and [20].\n\nOverview\n\nThin, uncertainty-aware wrappers around SpecialFunctions (besselj, bessely, besseli, besselk, besselh) and their scaled counterparts (â€¦x).\nFor Complex{Measurement} inputs, uncertainty is propagated using the 4-component gradient with respect to mathrmRe(z) and mathrmIm(z).\nFor Measurement (real) inputs, a 1-D finite-difference derivative is used.\nNo change in semantics for Real/Complex inputs: calls delegate to SpecialFunctions.\n\nDependencies\n\nBase\nLineCableModels.Commons\n\nExports\n\nbesselh\nbesselhx\nbesseli\nbesselix\nbesselj\nbesseljx\nbesselk\nbesselkx\nbessely\nbesselyx\n\nUsage\n\n# do not import SpecialFunctions directly\nusing LineCableModels.UncertainBessels \nz = complex(1.0, 1.0 Â± 0.5)\nJ0_cpl = besselj(0, z) \t\t\t# Complex{Measurement}\nJ0_nom = besselj(0, value(z)) \t# nominal comparison\nI1 = besselix(1, z) \t\t\t# scaled I1 with uncertainty\n\nNumerical notes\n\nScaled modified Bessels remove large exponential factors along mathrmRe(z) (e.g., I_nu and K_nu are scaled by opposite signs of mathrmRe(z)), improving conditioning. Scaled forms for the other families follow the definitions in SpecialFunctions and DLMF.\nUncertainty propagation is first order (linearization at the nominal point). Large uncertainties or strong nonlinearity may reduce accuracy.\n\nSee also\n\nLineCableModels.Engine.InternalImpedance\nLineCableModels.Engine.EarthImpedance\n\n\n\n\n\n","category":"module"},{"location":"reference/#DataFrames.DataFrame","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(design::CableDesign; ...) -> DataFrames.DataFrame\nDataFrame(\n    design::CableDesign,\n    format::Symbol;\n    S,\n    rho_e\n) -> DataFrames.DataFrame\n\n\nExtracts and displays data from a CableDesign.\n\nArguments\n\ndesign: A CableDesign object to extract data from.\nformat: Symbol indicating the level of detail:\n:baseparams: Basic RLC parameters with nominal value comparison (default).\n:components: Component-level equivalent properties.\n:detailed: Individual cable part properties with layer-by-layer breakdown.\nS: Separation distance between cables [m] (only used for :baseparams format). Default: outermost cable diameter.\nrho_e: Resistivity of the earth [Î©Â·m] (only used for :baseparams format). Default: 100.\n\nReturns\n\nA DataFrame containing the requested cable data in the specified format.\n\nExamples\n\n# Get basic RLC parameters\ndata = DataFrame(design)  # Default is :baseparams format\n\n# Get component-level data\ncomp_data = DataFrame(design, :components)\n\n# Get detailed part-by-part breakdown\ndetailed_data = DataFrame(design, :detailed)\n\n# Specify earth parameters for core calculations\ncore_data = DataFrame(design, :baseparams, S=0.5, rho_e=150)\n\nSee also\n\nCableDesign\ncalc_tubular_resistance\ncalc_inductance_trifoil\ncalc_shunt_capacitance\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataFrames.DataFrame-Tuple{CablesLibrary}","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(library::CablesLibrary) -> DataFrames.DataFrame\n\n\nLists the cable designs in a CablesLibrary object as a DataFrame.\n\nArguments\n\nlibrary: An instance of CablesLibrary whose cable designs are to be displayed.\n\nReturns\n\nA DataFrame object with the following columns:\ncable_id: The unique identifier for each cable design.\nnominal_data: A string representation of the nominal data for each cable design.\ncomponents: A comma-separated string listing the components of each cable design.\n\nExamples\n\nlibrary = CablesLibrary()\ndesign1 = CableDesign(\"example1\", nominal_data=NominalData(...), components=Dict(\"A\"=>...))\ndesign2 = CableDesign(\"example2\", nominal_data=NominalData(...), components=Dict(\"C\"=>...))\nadd!(library, design1)\nadd!(library, design2)\n\n# Display the library as a DataFrame\ndf = DataFrame(library)\nfirst(df, 5)  # Show the first 5 rows of the DataFrame\n\nSee also\n\nCablesLibrary\nCableDesign\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataFrames.DataFrame-Tuple{LineCableSystem}","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(system::LineCableSystem) -> DataFrames.DataFrame\n\n\nGenerates a summary DataFrame for cable positions and phase mappings within a LineCableSystem.\n\nArguments\n\nsystem: A LineCableSystem object containing the cable definitions and their configurations.\n\nReturns\n\nA DataFrame containing:\ncable_id: Identifier of each cable design.\nhorz: Horizontal coordinate of each cable [m].\nvert: Vertical coordinate of each cable [m].\nphase_mapping: Human-readable string representation mapping each cable component to its assigned phase.\n\nExamples\n\ndf = DataFrame(cable_system)\nprintln(df)\n# Output:\n# â”‚ cable_id   â”‚ horz â”‚ vert  â”‚ phase_mapping           â”‚\n# â”‚------------â”‚------â”‚-------â”‚-------------------------â”‚\n# â”‚ \"Cable1\"   â”‚ 0.0  â”‚ -0.5  â”‚ core: 1, sheath: 0      â”‚\n# â”‚ \"Cable2\"   â”‚ 0.35 â”‚ -1.25 â”‚ core: 2, sheath: 0      â”‚\n\nSee also\n\nLineCableSystem\nCablePosition\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.AbstractCablePart","page":"API reference","title":"LineCableModels.DataModel.AbstractCablePart","text":"abstract type AbstractCablePart{T}\n\nAbstract type representing a generic cable part.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.AbstractConductorPart","page":"API reference","title":"LineCableModels.DataModel.AbstractConductorPart","text":"abstract type AbstractConductorPart{T} <: LineCableModels.DataModel.AbstractCablePart{T}\n\nAbstract type representing a conductive part of a cable.\n\nSubtypes implement specific configurations:\n\nTubular\nStrip\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.AbstractInsulatorPart","page":"API reference","title":"LineCableModels.DataModel.AbstractInsulatorPart","text":"abstract type AbstractInsulatorPart{T} <: LineCableModels.DataModel.AbstractCablePart{T}\n\nAbstract type representing an insulating part of a cable.\n\nSubtypes implement specific configurations:\n\nInsulator\nSemicon\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.AbstractStrandsLayer","page":"API reference","title":"LineCableModels.DataModel.AbstractStrandsLayer","text":"abstract type AbstractStrandsLayer{T} <: LineCableModels.DataModel.AbstractConductorPart{T}\n\nAbstract type representing all stranded configurations composed of grouped discrete geometric shapes.\n\nSubtypes implement specific configurations:\n\nCircStrands\nRectStrands\n\n\n\n\n\n","category":"type"},{"location":"reference/#LineCableModels.DataModel.RectStrandsShape","page":"API reference","title":"LineCableModels.DataModel.RectStrandsShape","text":"struct RectStrandsShape{T<:Union{Float64, Measurements.Measurement{Float64}}, U<:Int64} <: LineCableModels.DataModel.AbstractShapeGeometry\n\nHolds the pure geometric layout for a concentric layer of rectangular/flat strands.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.delete!-Tuple{CablesLibrary, String}","page":"API reference","title":"Base.delete!","text":"delete!(library::CablesLibrary, cable_id::String)\n\n\nRemoves a cable design from a CablesLibrary object by its ID.\n\nArguments\n\nlibrary: An instance of CablesLibrary from which the cable design will be removed.\ncable_id: The ID of the cable design to remove.\n\nReturns\n\nNothing. Modifies the data field of the CablesLibrary object in-place by removing the specified cable design if it exists.\n\nExamples\n\nlibrary = CablesLibrary()\ndesign = CableDesign(\"example\", ...) # Initialize a CableDesign\nadd!(library, design)\n\n# Remove the cable design\ndelete!(library, \"example\")\nhaskey(library, \"example\")  # Returns false\n\nSee also\n\nCablesLibrary\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.get","page":"API reference","title":"Base.get","text":"get(\n    library::CablesLibrary,\n    cable_id::String\n) -> Union{Nothing, CableDesign}\nget(\n    library::CablesLibrary,\n    cable_id::String,\n    default\n) -> Any\n\n\nRetrieves a cable design from a CablesLibrary object by its ID.\n\nArguments\n\nlibrary: An instance of CablesLibrary from which the cable design will be retrieved.\ncable_id: The ID of the cable design to retrieve.\n\nReturns\n\nA CableDesign object corresponding to the given cable_id if found, otherwise nothing.\n\nExamples\n\nlibrary = CablesLibrary()\ndesign = CableDesign(\"example\", ...) # Initialize a CableDesign\nadd!(library, design)\n\n# Retrieve the cable design\nretrieved_design = get(library, \"cable1\")\nprintln(retrieved_design.id)  # Prints \"example\"\n\n# Attempt to retrieve a non-existent design\nmissing_design = get(library, \"nonexistent_id\")\nprintln(missing_design === nothing)  # Prints true\n\nSee also\n\nCablesLibrary\nCableDesign\nadd!\ndelete!\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CableComponent}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    component::CableComponent\n)\n\n\nDefines the display representation of a CableComponent object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\ncomponent: The CableComponent object to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CableDesign}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    design::CableDesign\n)\n\n\nDefines the display representation of a CableDesign object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\ndesign: The CableDesign object to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Union{ConductorGroup, InsulatorGroup}}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    group::Union{ConductorGroup, InsulatorGroup}\n)\n\n\nDefines the display representation of a ConductorGroup or InsulatorGroupobjects for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\ngroup: The ConductorGroup or InsulatorGroup instance to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, T}} where T<:LineCableModels.DataModel.AbstractCablePart","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    part::LineCableModels.DataModel.AbstractCablePart\n)\n\n\nDefines the display representation of an AbstractCablePart object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\npart: The AbstractCablePart instance to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Commons.add!-Tuple{CablesLibrary, CableDesign}","page":"API reference","title":"LineCableModels.Commons.add!","text":"Stores a cable design in a CablesLibrary object.\n\nArguments\n\nlibrary: An instance of CablesLibrary to which the cable design will be added.\ndesign: A CableDesign object representing the cable design to be added. This object must have a cable_id field to uniquely identify it.\n\nReturns\n\nNone. Modifies the data field of the CablesLibrary object in-place by adding the new cable design.\n\nExamples\n\nlibrary = CablesLibrary()\ndesign = CableDesign(\"example\", ...) # Initialize CableDesign with required fields\nadd!(library, design)\nprintln(library) # Prints the updated dictionary containing the new cable design\n\nSee also\n\nCablesLibrary\nCableDesign\ndelete!\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Commons.add!-Union{Tuple{C}, Tuple{T}, Tuple{ConductorGroup{T}, Type{C}, Vararg{Any}}} where {T, C<:LineCableModels.DataModel.AbstractConductorPart}","page":"API reference","title":"LineCableModels.Commons.add!","text":"add!(\n    group::ConductorGroup{T},\n    part_type::Type{C<:LineCableModels.DataModel.AbstractConductorPart},\n    args...;\n    kwargs...\n) -> ConductorGroup{Tg} where Tg\n\n\nAdd a new conductor part to a ConductorGroup, validating raw inputs, normalizing proxies, and promoting the groupâ€™s numeric type if required.\n\nBehavior:\n\nApply part-level keyword defaults.\nDefault radius_in to group.radius_ext if absent.\nCompute Tnew = resolve_T(group, radius_in, args..., values(kwargs)...).\nIf Tnew === T, mutate in place; else coerce_to_T(group, Tnew) then mutate and return the promoted group.\n\nArguments\n\ngroup: ConductorGroup object to which the new part will be added.\npart_type: Type of conductor part to add (AbstractConductorPart).\nargs...: Positional arguments specific to the constructor of the part_type (AbstractConductorPart) [various].\nkwargs...: Named arguments for the constructor including optional values specific to the constructor of the part_type (AbstractConductorPart) [various].\n\nReturns\n\nThe function modifies the ConductorGroup instance in place and does not return a value.\n\nNotes\n\nUpdates gmr, resistance, alpha, radius_ext, cross_section, and num_wires to account for the new part.\nThe temperature of the new part defaults to the temperature of the first layer if not specified.\nThe radius_in of the new part defaults to the external radius of the existing conductor if not specified.\n\nwarning: Note\nWhen an AbstractCablePart is provided as radius_in, the constructor retrieves its radius_ext value, allowing the new cable part to be placed directly over the existing part in a layered cable design.\nIn case of uncertain measurements, if the added cable part is of a different type than the existing one, the uncertainty is removed from the radius value before being passed to the new component. This ensures that measurement uncertainties do not inappropriately cascade across different cable parts.\n\nExamples\n\nmaterial_props = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nconductor = ConductorGroup(Strip(0.01, 0.002, 0.05, 10, material_props))\nadd!(conductor, CircStrands, 0.02, 0.002, 7, 15, material_props, temperature = 25)\n\nSee also\n\nConductorGroup\nCircStrands\nStrip\nTubular\ncalc_equivalent_gmr\ncalc_parallel_equivalent\ncalc_equivalent_alpha\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Commons.add!-Union{Tuple{C}, Tuple{T}, Tuple{InsulatorGroup{T}, Type{C}, Vararg{Any}}} where {T, C<:LineCableModels.DataModel.AbstractInsulatorPart}","page":"API reference","title":"LineCableModels.Commons.add!","text":"add!(\n    group::InsulatorGroup{T},\n    part_type::Type{C<:LineCableModels.DataModel.AbstractInsulatorPart},\n    args...;\n    f,\n    kwargs...\n) -> InsulatorGroup{Tg} where Tg\n\n\nAdds a new part to an existing InsulatorGroup object and updates its equivalent electrical parameters.\n\nBehavior:\n\nApply part-level keyword defaults (from Validation.keyword_defaults).\nDefault radius_in to group.radius_ext if absent.\nCompute Tnew = resolve_T(group, radius_in, args..., values(kwargs)..., f).\nIf Tnew === T, mutate in place; else coerce_to_T(group, Tnew) then mutate and return the promoted group.\n\nArguments\n\ngroup: InsulatorGroup object to which the new part will be added.\npart_type: Type of insulator part to add (AbstractInsulatorPart).\nargs...: Positional arguments specific to the constructor of the part_type (AbstractInsulatorPart) [various].\nkwargs...: Named arguments for the constructor including optional values specific to the constructor of the part_type (AbstractInsulatorPart) [various].\n\nReturns\n\nThe function modifies the InsulatorGroup instance in place and does not return a value.\n\nNotes\n\nUpdates shunt_capacitance, shunt_conductance, radius_ext, and cross_section to account for the new part.\nThe radius_in of the new part defaults to the external radius of the existing insulator group if not specified.\n\nwarning: Note\nWhen an AbstractCablePart is provided as radius_in, the constructor retrieves its radius_ext value, allowing the new cable part to be placed directly over the existing part in a layered cable design.\nIn case of uncertain measurements, if the added cable part is of a different type than the existing one, the uncertainty is removed from the radius value before being passed to the new component. This ensures that measurement uncertainties do not inappropriately cascade across different cable parts.\n\nExamples\n\nmaterial_props = Material(1e10, 3.0, 1.0, 20.0, 0.0)\ninsulator_group = InsulatorGroup(Insulator(0.01, 0.015, material_props))\nadd!(insulator_group, Semicon, 0.015, 0.018, material_props)\n\nSee also\n\nInsulatorGroup\nInsulator\nSemicon\ncalc_parallel_equivalent\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Commons.add!-Union{Tuple{T}, Tuple{LineCableSystem{T}, CableDesign, Number, Number}, Tuple{LineCableSystem{T}, CableDesign, Number, Number, Union{Nothing, Dict{String, Int64}}}} where T","page":"API reference","title":"LineCableModels.Commons.add!","text":"add!(\n    system::LineCableSystem{T},\n    cable::CableDesign,\n    horz::Number,\n    vert::Number\n) -> LineCableSystem{T} where T\nadd!(\n    system::LineCableSystem{T},\n    cable::CableDesign,\n    horz::Number,\n    vert::Number,\n    conn::Union{Nothing, Dict{String, Int64}}\n) -> LineCableSystem{T} where T\n\n\nConvenience add! that accepts a cable design and coordinates (and optional mapping). Builds a CablePosition and forwards to add!(system, pos).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Commons.add!-Union{Tuple{T}, Tuple{LineCableSystem{T}, CablePosition}} where T","page":"API reference","title":"LineCableModels.Commons.add!","text":"add!(\n    system::LineCableSystem{T},\n    pos::CablePosition\n) -> LineCableSystem{T} where T\n\n\nAdds a new cable position to an existing LineCableSystem, updating its phase mapping and cable count. If adding the position introduces a different numeric scalar type, the system is promoted and the promoted system is returned. Otherwise, mutation happens in place.\n\nArguments\n\nsystem: Instance of LineCableSystem to which the cable will be added.\ncable: A CableDesign object defining the cable structure.\nhorz: Horizontal coordinate [m].\nvert: Vertical coordinate [m].\nconn: Dictionary mapping component names to phase indices, or nothing for automatic assignment.\n\nReturns\n\nThe modified LineCableSystem object with the new cable added.\n\nExamples\n\ncable_design = CableDesign(\"example\", nominal_data, components_dict)\n\n# Define coordinates for two cables\nxa, ya = 0.0, -1.0\nxb, yb = 1.0, -2.0\n\n# Create initial system with one cable\ncablepos1 = CablePosition(cable_design, xa, ya, Dict(\"core\" => 1))\ncable_system = LineCableSystem(\"test_case_1\", 1000.0, cablepos1)\n\n# Add second cable to system\nadd!(cable_system, cable_design, xb, yb, Dict(\"core\" => 2))\n\nprintln(cable_system.num_cables)  # Prints: 2\n\nSee also\n\nLineCableSystem\nCablePosition\nCableDesign\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._coerced_args-Union{Tuple{C}, Tuple{Type{C}, Any, Any, Tuple}} where C","page":"API reference","title":"LineCableModels.DataModel._coerced_args","text":"_coerced_args(_::Type{C}, ntv, Tp, order::Tuple) -> Tuple\n\n\nBuilds the positional argument tuple to feed the typed core constructor, coercing only the fields returned by coercive_fields(C) to type Tp. Nonâ€‘coercive fields (e.g., integer flags) are passed through unchanged. Field order is controlled by order (a tuple of symbols), typically (required_fields(C)..., keyword_fields(C)...).\n\nArguments\n\n::Type{C}: Component type [dimensionless].\nntv: Normalized NamedTuple returned by validate! [dimensionless].\nTp: Target element type for numeric coercion [dimensionless].\norder::Tuple: Field order used to assemble the positional tuple [dimensionless].\n\nReturns\n\nA Tuple of arguments in the requested order, with coercions applied where configured.\n\nExamples\n\nargs = _coerced_args(Tubular, ntv, Float64, (:radius_in, :radius_ext, :material_props, :temperature))\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._ctor_materialize-Tuple{Any, Any}","page":"API reference","title":"LineCableModels.DataModel._ctor_materialize","text":"_ctor_materialize(mod, x) -> Any\n\n\nUtility for the constructor macro to materialize input tuples from either:\n\nA tuple literal expression (e.g., (:a, :b, :c)), or\nA bound constant tuple name (e.g., _REQ_TUBULAR).\n\nUsed to keep macro call sites short while allowing both styles.\n\nArguments\n\nmod: Module where constants are resolved [dimensionless].\nx: Expression or symbol representing a tuple [dimensionless].\n\nReturns\n\nA standard Julia Tuple (of symbols or defaults).\n\nErrors\n\nErrorException if x is neither a tuple literal nor a bound constant name.\n\nExamples\n\nsyms = _ctor_materialize(@__MODULE__, :( :a, :b ))\nsyms = _ctor_materialize(@__MODULE__, :_REQ_TUBULAR)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._do_add!-Union{Tuple{Tg}, Tuple{ConductorGroup{Tg}, Type{<:LineCableModels.DataModel.AbstractConductorPart}, Vararg{Any}}} where Tg","page":"API reference","title":"LineCableModels.DataModel._do_add!","text":"_do_add!(\n    group::ConductorGroup{Tg},\n    C::Type{<:LineCableModels.DataModel.AbstractConductorPart},\n    args...;\n    kwargs...\n)\n\n\nInternal, in-place insertion (no promotion logic). Assumes :radius_in was materialized. Runs Validation â†’ parsing, then coerces fields to the groupâ€™s T and updates equivalent properties and book-keeping.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._do_add!-Union{Tuple{Tg}, Tuple{InsulatorGroup{Tg}, Type{<:LineCableModels.DataModel.AbstractInsulatorPart}, Vararg{Any}}} where Tg","page":"API reference","title":"LineCableModels.DataModel._do_add!","text":"_do_add!(\n    group::InsulatorGroup{Tg},\n    C::Type{<:LineCableModels.DataModel.AbstractInsulatorPart},\n    args...;\n    f,\n    kwargs...\n)\n\n\nDo the actual insertion for InsulatorGroup with the group already at the correct scalar type. Validates/parses the part, coerces to the groupâ€™s T, constructs the strict numeric core, and updates geometry and admittances at the provided frequency.\n\nReturns the mutated group (same object).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._extract_part_properties-Tuple{Any, Any}","page":"API reference","title":"LineCableModels.DataModel._extract_part_properties","text":"_extract_part_properties(part, properties) -> Any\n\n\nHelper function to extract properties from a part for detailed format.\n\nArguments\n\npart: An instance of AbstractCablePart from which to extract properties.\nproperties: A vector of symbols indicating which properties to extract (not used in the current implementation).\n\nReturns\n\nA vector containing the extracted properties in the following order:\ntype: The lowercase string representation of the part's type.\nradius_in: The inner radius of the part, if it exists, otherwise missing.\nradius_ext: The outer radius of the part, if it exists, otherwise missing.\ndiameter_in: The inner diameter of the part (2 * radiusin), if `radiusinexists, otherwisemissing`.\ndiameter_ext: The outer diameter of the part (2 * radiusext), if `radiusextexists, otherwisemissing`.\nthickness: The difference between radius_ext and radius_in, if both exist, otherwise missing.\ncross_section: The cross-sectional area of the part, if it exists, otherwise missing.\nnum_wires: The number of wires in the part, if it exists, otherwise missing.\nresistance: The resistance of the part, if it exists, otherwise missing.\nalpha: The temperature coefficient of resistivity of the part or its material, if it exists, otherwise missing.\ngmr: The geometric mean radius of the part, if it exists, otherwise missing.\ngmr_ratio: The ratio of gmr to radius_ext, if both exist, otherwise missing.\nshunt_capacitance: The shunt capacitance of the part, if it exists, otherwise missing.\nshunt_conductance: The shunt conductance of the part, if it exists, otherwise missing.\n\nNotes\n\nThis function is used to create a standardized format for displaying detailed information about cable parts.\n\nExamples\n\npart = Conductor(...)\nproperties = [:radius_in, :radius_ext, :resistance]  # Example of properties to extract\nextracted_properties = _extract_part_properties(part, properties)\nprintln(extracted_properties)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._normalize_radii-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T","page":"API reference","title":"LineCableModels.DataModel._normalize_radii","text":"_normalize_radii(_::Type{T}, rin, rex) -> Any\n\n\nResolves radius parameters for cable components, converting from various input formats to standardized inner radius, outer radius, and thickness values.\n\nThis function serves as a high-level interface to the radius resolution system. It processes inputs through a two-stage pipeline:\n\nFirst normalizes input parameters to consistent forms using _parse_radius_operand.\nThen delegates to specialized implementations via _do_resolve_radius based on the component type.\n\nArguments\n\nparam_in: Inner boundary parameter (defaults to radius) [m]. Can be a number, a Diameter , a Thickness, or an AbstractCablePart.\nparam_ext: Outer boundary parameter (defaults to radius) [m]. Can be a number, a Diameter , a Thickness, or an AbstractCablePart.\nobject_type: Type associated to the constructor of the new AbstractCablePart.\n\nReturns\n\nradius_in: Normalized inner radius [m].\nradius_ext: Normalized outer radius [m].\nthickness: Computed thickness or specialized dimension depending on the method [m]. For CircStrands components, this value represents the wire radius instead of thickness.\n\nSee also\n\nDiameter\nThickness\nAbstractCablePart\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._parse_radius_operand","page":"API reference","title":"LineCableModels.DataModel._parse_radius_operand","text":"Parses input values into radius representation based on object type and input type.\n\nArguments\n\nx: Input value that can be a raw number, a Diameter, a Thickness, or other convertible type [m].\nobject_type: Type parameter used for dispatch.\n\nReturns\n\nParsed radius value in appropriate units [m].\n\nExamples\n\nradius = _parse_radius_operand(10.0, ...)   # Direct radius value\nradius = _parse_radius_operand(Diameter(20.0), ...)  # From diameter object\nradius = _parse_radius_operand(Thickness(5.0), ...)  # From thickness object\n\nMethods\n\n_parse_radius_operand(x, _)\n\ndefined at radii.jl:68.\n\n_parse_radius_operand(d, _)\n\ndefined at radii.jl:69.\n\n_parse_radius_operand(p, _)\n\ndefined at radii.jl:70.\n\n_parse_radius_operand(p, _)\n\ndefined at radii.jl:71.\n\n_parse_radius_operand(x, _)\n\ndefined at radii.jl:75.\n\n_parse_radius_operand(x, _)\n\ndefined at radii.jl:81.\n\nSee also\n\nDiameter\nThickness\n\n\n\n\n\n","category":"function"},{"location":"reference/#LineCableModels.DataModel._print_fields-Tuple{IO, Any, Vector{Symbol}}","page":"API reference","title":"LineCableModels.DataModel._print_fields","text":"_print_fields(\n    io::IO,\n    obj,\n    fields_to_show::Vector{Symbol};\n    sigdigits\n) -> Int64\n\n\nPrint the specified fields of an object in a compact format.\n\nArguments\n\nio: The output stream.\nobj: The object whose fields will be displayed.\nfields_to_show: Vector of field names (as Symbols) to display.\nsigdigits: Number of significant digits for rounding numeric values.\n\nReturns\n\nNumber of fields that were actually displayed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._promotion_T-Union{Tuple{C}, Tuple{Type{C}, Any, Tuple}} where C","page":"API reference","title":"LineCableModels.DataModel._promotion_T","text":"_promotion_T(_::Type{C}, ntv, _order::Tuple) -> Type\n\n\nDetermines the promoted numeric element type for convenience constructors of component C. The promotion is computed across the values of coercive_fields(C), extracted from the normalized NamedTuple ntv produced by validate!. This ensures all numeric fields that participate in calculations share a common element type (e.g., Float64, Measurement{Float64}).\n\nArguments\n\n::Type{C}: Component type [dimensionless].\nntv: Normalized NamedTuple returned by validate! [dimensionless].\n_order::Tuple: Ignored by this method; present for arity symmetry with _coerced_args [dimensionless].\n\nReturns\n\nThe promoted numeric element type [dimensionless].\n\nExamples\n\nTp = _promotion_T(Tubular, (radius_in=0.01, radius_ext=0.02, material_props=mat, temperature=20.0), ())\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel._with_kwdefaults-Union{Tuple{C}, Tuple{Type{C}, NamedTuple}} where C","page":"API reference","title":"LineCableModels.DataModel._with_kwdefaults","text":"_with_kwdefaults(\n    _::Type{C},\n    kwargs::NamedTuple\n) -> NamedTuple\n\n\nMerge per-part keyword defaults declared via Validation.keyword_defaults with user-provided kwargs and return a NamedTuple suitable for forwarding.\n\nDefaults may be a NamedTuple or a Tuple zipped against Validation.keyword_fields(::Type{C}). User keys always win.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.get_material_color_makie-Tuple{Any}","page":"API reference","title":"LineCableModels.DataModel.get_material_color_makie","text":"get_material_color_makie(material_props; mu_scale=1.0, eps_scale=1.0)\n\nPiecewise Ïâ†’base color (metalsâ†’silver, semiconductorsâ†’amber, etc.) with blue/purple magnetic overlay (Î¼r) and teal/cyan permittivity overlay (Îµr). mu_scale and eps_scale scale overlay strength (1.0 = default).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.nonsensify-Tuple{CableDesign}","page":"API reference","title":"LineCableModels.DataModel.nonsensify","text":"nonsensify(originaldesign::CableDesign; newid::String=\"\")::CableDesign\n\nRecreates a cable design by bulldozing reality into a \"simplified\" shape  with only the so-called \"main\" material properties. \n\nTranslation: if you wanted physics, you came to the wrong neighborhood.  \n\nFor each component, this abomination does:\n\nConductorGroup(Tubular(...)) with radii stolen from the first and last  conductor layers, and material blindly copied from the first conductor layer.  Because high-fidelity is for losers.  \nInsulatorGroup(Insulator(...)) spanning from the new conductor outer radius  to the original insulator group's outer radius; material is taken from the  first Insulator layer available (or whatever warm body it can find).  \n\nâš  WARNING: This is deliberately nonsensical. It laughs in the face of proper  equivalent property corrections and just slaps the \"main\" props on like duct tape.  Use only when you donâ€™t give a damn about accuracy and just want something  that looks cable-ish, e.g., never.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.vdeparse-Tuple{AbstractString}","page":"API reference","title":"LineCableModels.DataModel.vdeparse","text":"vdeparse(code::AbstractString) -> Dict{Symbol,String}\n\nParses VDE/DIN 0271/0276 cable codes:\n\nstub (first non-space token): designation â†’ conductormaterial (default copper) â†’ insulation (default paper) â†’ screen â†’ waterblocking â†’ innersheath â†’ armouring â†’ sheath â†’ grounding\ntail: cores Ã— cross-section (optional screen csa), voltage, conductor type (R/S/O + E/M/H, optional /V â‡’ compact)\n\nOnly parsed keys are returned; defaults are materialized when omitted.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.coerce_to_T-Union{Tuple{T}, Tuple{NominalData{T}, Type{T}}} where T","page":"API reference","title":"LineCableModels.Utils.coerce_to_T","text":"Identity: no allocation when already at T.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, LineCableModels.DataModel.AbstractCablePart}} where T","page":"API reference","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_ext},\n    _::LineCableModels.DataModel.AbstractCablePart\n) -> Bool\n\n\nDefault policy for outer radius raw inputs (annular shells): reject AbstractCablePart proxies. Outer radius must be numeric or a Thickness wrapper to avoid creating zeroâ€‘thickness layers.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_ext}: Field tag for the outer radius [dimensionless].\n::AbstractCablePart: Proxy object [dimensionless].\n\nReturns\n\nfalse always.\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_ext), prev_layer)  # false\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, Thickness}} where T","page":"API reference","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_ext},\n    _::Thickness\n) -> Bool\n\n\nDefault policy for outer radius raw inputs (annular shells): accept Thickness as a convenience wrapper. The thickness is expanded to an outer radius during parsing.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_ext}: Field tag for the outer radius [dimensionless].\n::Thickness: Thickness wrapper [dimensionless].\n\nReturns\n\nBool indicating acceptance (true).\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_ext), Thickness(1e-3))  # true\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_in}, LineCableModels.DataModel.AbstractCablePart}} where T","page":"API reference","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_in},\n    p::LineCableModels.DataModel.AbstractCablePart\n) -> Bool\n\n\nDefault policy for inner radius raw inputs: accept proxies that expose an outer radius. This permits stacking by hijacking p.radius_ext during parsing.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_in}: Field tag for the inner radius [dimensionless].\np::AbstractCablePart: Proxy object [dimensionless].\n\nReturns\n\nBool indicating acceptance (true if hasproperty(p, :radius_ext)).\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_in), prev_layer)  # true if prev_layer has :radius_ext\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Validation.maxfill-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T","page":"API reference","title":"LineCableModels.Validation.maxfill","text":"maxfill(_::Type{T}, args...) -> Any\n\n\nFallback method for the maxfill interface. Throws an explicit error indicating that the component type T has not implemented its physical capacity limit.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\nargs...: Geometric parameters required for the calculation [dimensionless].\n\nReturns\n\nNothing. Always throws an ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.DataModel.@construct","page":"API reference","title":"LineCableModels.DataModel.@construct","text":"Generates a weaklyâ€‘typed convenience constructor for a component T. The generated method:\n\nAccepts exactly the positional fields listed in REQ.\nAccepts keyword arguments listed in OPT with defaults DEFS.\nCalls validate!(T, ...) forwarding variables (not defaults),\nComputes the promotion type via _promotion_T(T, ntv, order),\nCoerces only coercive_fields(T) via _coerced_args(T, ntv, Tp, order),\nDelegates to the numeric core T(...) with the coerced positional tuple.\n\nREQ, OPT, and DEFS can be provided as tuple literals or as names of bound constant tuples. order is implicitly (REQ..., OPT...).\n\nArguments\n\nT: Component type (bare name) [dimensionless].\nREQ: Tuple of required positional field names [dimensionless].\nOPT: Tuple of optional keyword field names [dimensionless]. Defaults to ().\nDEFS: Tuple of default values matching OPT [dimensionless]. Defaults to ().\n\nReturns\n\nA method definition for the weaklyâ€‘typed constructor.\n\nExamples\n\nconst _REQ_TUBULAR = (:radius_in, :radius_ext, :material_props)\nconst _OPT_TUBULAR = (:temperature,)\nconst _DEFS_TUBULAR = (Tâ‚€,)\n\n@construct Tubular _REQ_TUBULAR _OPT_TUBULAR _DEFS_TUBULAR\n\n# Expands roughly to:\n# function Tubular(radius_in, radius_ext, material_props; temperature=Tâ‚€)\n#   ntv = validate!(Tubular, radius_in, radius_ext, material_props; temperature=temperature)\n#   Tp  = _promotion_T(Tubular, ntv, (:radius_in, :radius_ext, :material_props, :temperature))\n#   args = _coerced_args(Tubular, ntv, Tp, (:radius_in, :radius_ext, :material_props, :temperature))\n#   return Tubular(args...)\n# end\n\nNotes\n\nDefaults supplied in DEFS are escaped into the method signature (evaluated at macro expansion time).\nForwarding into validate! always uses variables (e.g., temperature=temperature), never literal defaults.\nThe macro is hygieneâ€‘aware; identifiers validate!, _promotion_T, _coerced_args, and the type name are properly escaped.\n\nErrors\n\nErrorException if length(OPT) != length(DEFS).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#DataFrames.DataFrame-Tuple{EarthModel}","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(earth_model::EarthModel) -> DataFrames.DataFrame\n\n\nGenerates a DataFrame summarizing basic properties of earth layers from an EarthModel.\n\nArguments\n\nearth_model: Instance of EarthModel containing earth layers.\n\nReturns\n\nA DataFrame with columns:\nrho_g: Base (DC) resistivity of each layer [Î©Â·m].\nepsr_g: Base (DC) relative permittivity of each layer [dimensionless].\nmur_g: Base (DC) relative permeability of each layer [dimensionless].\nthickness: Thickness of each layer [m].\n\nExamples\n\ndf = DataFrame(earth_model)\nprintln(df)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.EarthProps.AbstractFDEMFormulation","page":"API reference","title":"LineCableModels.EarthProps.AbstractFDEMFormulation","text":"abstract type AbstractFDEMFormulation\n\nAbstract type representing different frequency-dependent earth models (FDEM). Used in the multi-dispatch implementations in modules LineCableModels.EarthProps and LineCableModels.Engine.\n\nCurrently available formulations\n\nCPEarth: Constant properties (CP) model.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, EarthModel}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    model::EarthModel\n)\n\n\nDefines the display representation of a EarthModel object for REPL or text output.\n\nArguments\n\nio: The output stream to write the representation to [IO].\nmime: The MIME type for plain text output [MIME\"text/plain\"].\nmodel: The EarthModel instance to be displayed.\n\nReturns\n\nNothing. Modifies io to format the output.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Commons.add!-Union{Tuple{T}, Tuple{EarthModel{T}, Vector{T}, T, T, T}} where T<:Union{Float64, Measurements.Measurement{Float64}}","page":"API reference","title":"LineCableModels.Commons.add!","text":"add!(\n    model::EarthModel{T<:Union{Float64, Measurements.Measurement{Float64}}},\n    frequencies::Array{T<:Union{Float64, Measurements.Measurement{Float64}}, 1},\n    base_rho_g::Union{Float64, Measurements.Measurement{Float64}},\n    base_epsr_g::Union{Float64, Measurements.Measurement{Float64}},\n    base_mur_g::Union{Float64, Measurements.Measurement{Float64}};\n    t\n) -> EarthModel\n\n\nAdds a new earth layer to an existing EarthModel.\n\nArguments\n\nmodel: Instance of EarthModel to which the new layer will be added.\nfrequencies: Vector of frequency values [Hz].\nbase_rho_g: Base electrical resistivity of the new earth layer [Î©Â·m].\nbase_epsr_g: Base relative permittivity of the new earth layer [dimensionless].\nbase_mur_g: Base relative permeability of the new earth layer [dimensionless].\nt: Thickness of the new earth layer [m] (default: Inf).\n\nReturns\n\nModifies model in place by appending a new EarthLayer.\n\nNotes\n\nFor horizontal layering (vertical_layers = false):\n\nLayer 1 (air) is always infinite (t = Inf).\nLayer 2 (first earth layer) can be infinite if modeling a homogeneous half-space.\nIf adding a third layer (length(EarthModel.layers) == 3), it can be infinite only if the previous layer is finite.\nNo two successive earth layers (length(EarthModel.layers) > 2) can have infinite thickness.\n\nFor vertical layering (vertical_layers = true):\n\nLayer 1 (air) is always horizontal and infinite at z > 0.\nLayer 2 (first vertical layer) is always infinite in z < 0 and y < 0. The first vertical layer is assumed to always end at y = 0.\nLayer 3 (second vertical layer) can be infinite (establishing a vertical interface at y = 0).\nSubsequent layers can be infinite only if the previous is finite.\nNo two successive vertical layers (length(EarthModel.layers) > 3) can both be infinite.\n\nExamples\n\nfrequencies = [1e3, 1e4, 1e5]\n\n# Define a horizontal model with finite thickness for the first earth layer\nhorz_earth_model = EarthModel(frequencies, 100, 10, 1, t=5)\n\n# Add a second horizontal earth layer\nadd!(horz_earth_model, frequencies, 200, 15, 1, t=10)\nprintln(length(horz_earth_model.layers)) # Output: 3\n\n# The bottom layer should be set to infinite thickness\nadd!(horz_earth_model, frequencies, 300, 15, 1, t=Inf)\nprintln(length(horz_earth_model.layers)) # Output: 4\n\n# Initialize a vertical-layered model with first interface at y = 0.\nvert_earth_model = EarthModel(frequencies, 100, 10, 1, t=Inf, vertical_layers=true)\n\n# Add a second vertical layer at y = 0 (this can also be infinite)\nadd!(vert_earth_model, frequencies, 150, 12, 1, t=Inf)\nprintln(length(vert_earth_model.layers)) # Output: 3\n\n# Attempt to add a third infinite layer (invalid case)\ntry\n\tadd!(vert_earth_model, frequencies, 120, 12, 1, t=Inf)\ncatch e\n\tprintln(e) # Error: Cannot add consecutive vertical layers with infinite thickness.\nend\n\n# Fix: Set a finite thickness to the currently rightmost layer\nvert_earth_model.layers[end].t = 3\n\n# Add the third layer with infinite thickness now\nadd!(vert_earth_model, frequencies, 120, 12, 1, t=Inf)\nprintln(length(vert_earth_model.layers)) # Output: 4\n\nSee also\n\nEarthLayer\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.coerce_to_T-Union{Tuple{T}, Tuple{EarthModel, Type{T}}} where T","page":"API reference","title":"LineCableModels.Utils.coerce_to_T","text":"coerce_to_T(model::EarthModel, _::Type{T}) -> EarthModel\n\n\nConverts an EarthModel{S} to EarthModel{T} by reconstructing the model with all layers coerced to the new scalar type T. Layer conversion is delegated to coerce_to_T(::EarthLayer, ::Type), and non-numeric metadata are forwarded unchanged.\n\nArguments\n\nmodel: Source Earth model [dimensionless].\n::Type{T}: Target element type for numeric fields [dimensionless].\n\nReturns\n\nEarthModel{T} rebuilt with each layer and numeric payload converted to T.\n\nExamples\n\nm64 = coerce_to_T(model, Float64)\nmM  = coerce_to_T(model, Measurement{Float64})\n\nSee also\n\ncoerce_to_T\nresolve_T\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.coerce_to_T-Union{Tuple{T}, Tuple{LineCableModels.EarthProps.EarthLayer, Type{T}}} where T","page":"API reference","title":"LineCableModels.Utils.coerce_to_T","text":"coerce_to_T(\n    layer::LineCableModels.EarthProps.EarthLayer,\n    _::Type{T}\n) -> LineCableModels.EarthProps.EarthLayer\n\n\nConverts an EarthLayer{S} to EarthLayer{T} by coercing each stored field to the target element type T and rebuilding the layer via its inner constructor. Scalar and array fields are converted using the generic coerce_to_T machinery.\n\nArguments\n\nlayer: Source Earth layer [dimensionless].\n::Type{T}: Target element type for numeric fields [dimensionless].\n\nReturns\n\nEarthLayer{T} with all numeric state converted to T.\n\nExamples\n\nâ„“64 = coerce_to_T(layer, Float64)\nâ„“M  = coerce_to_T(layer, Measurement{Float64})\n\nSee also\n\ncoerce_to_T\nresolve_T\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataFrames.DataFrame-Tuple{MaterialsLibrary}","page":"API reference","title":"DataFrames.DataFrame","text":"DataFrame(library::MaterialsLibrary) -> DataFrames.DataFrame\n\n\nLists the contents of a MaterialsLibrary as a DataFrame.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary to be displayed.\n\nReturns\n\nA DataFrame containing the material properties.\n\nExamples\n\nlibrary = MaterialsLibrary()\ndf = DataFrame(library)\n\nSee also\n\nLineCableModels.ImportExport.save\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.delete!-Tuple{MaterialsLibrary, String}","page":"API reference","title":"Base.delete!","text":"delete!(library::MaterialsLibrary, name::String)\n\n\nRemoves a material from a MaterialsLibrary.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary from which the material will be removed.\nname: Name of the material to be removed.\n\nReturns\n\nThe modified instance of MaterialsLibrary without the specified material.\n\nErrors\n\nThrows an error if the material does not exist in the library.\n\nExamples\n\nlibrary = MaterialsLibrary()\ndelete!(library, \"copper\")\n\nSee also\n\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.get-2","page":"API reference","title":"Base.get","text":"get(\n    library::MaterialsLibrary,\n    name::String\n) -> Union{Nothing, Material}\nget(library::MaterialsLibrary, name::String, default) -> Any\n\n\nRetrieves a material from a MaterialsLibrary by name.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary containing the materials.\nname: Name of the material to retrieve.\n\nReturns\n\nThe requested Material if found, otherwise nothing.\n\nExamples\n\nlibrary = MaterialsLibrary()\nmaterial = get(library, \"copper\")\n\nSee also\n\nadd!\ndelete!\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Dict{String, Material}}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    dict::Dict{String, Material}\n)\n\n\nDefines the display representation of a MaterialsLibrary object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\ndict: The MaterialsLibrary contents to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the library.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, MaterialsLibrary}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    library::MaterialsLibrary\n)\n\n\nDefines the display representation of a MaterialsLibrary object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\nlibrary: The MaterialsLibrary instance to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the library.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Material}","page":"API reference","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    material::Material\n)\n\n\nDefines the display representation of a Material object for REPL or text output.\n\nArguments\n\nio: Output stream.\n::MIME\"text/plain\": MIME type for plain text output.\nmaterial: The Material instance to be displayed.\n\nReturns\n\nNothing. Modifies io by writing text representation of the material.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Commons.add!-Tuple{MaterialsLibrary, AbstractString, Material}","page":"API reference","title":"LineCableModels.Commons.add!","text":"add!(\n    library::MaterialsLibrary,\n    name::AbstractString,\n    material::Material\n) -> MaterialsLibrary\n\n\nAdds a new material to a MaterialsLibrary.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary where the material will be added.\nname: Name of the material.\nmaterial: Instance of Material containing its properties.\n\nReturns\n\nThe modified instance of MaterialsLibrary with the new material added.\n\nErrors\n\nThrows an error if a material with the same name already exists in the library.\n\nExamples\n\nlibrary = MaterialsLibrary()\nmaterial = Material(1.7241e-8, 1.0, 0.999994, 20.0, 0.00393)\nadd!(library, \"copper\", material)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Materials._add_default_materials!-Tuple{MaterialsLibrary}","page":"API reference","title":"LineCableModels.Materials._add_default_materials!","text":"_add_default_materials!(\n    library::MaterialsLibrary\n) -> MaterialsLibrary\n\n\nPopulates a MaterialsLibrary with commonly used materials, assigning predefined electrical and thermal properties.\n\nArguments\n\nlibrary: Instance of MaterialsLibrary to be populated.\n\nReturns\n\nThe modified instance of MaterialsLibrary containing the predefined materials.\n\nExamples\n\nlibrary = MaterialsLibrary()\n_add_default_materials!(library)\n\nSee also\n\nadd!\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils._coerce_elt_to_T","page":"API reference","title":"LineCableModels.Utils._coerce_elt_to_T","text":"Elementâ€‘wise coercion kernel. Converts a single leaf value to the target type T while preserving semantics for Measurement, numeric types, and sentinels.\n\nArguments\n\nx: Input leaf value [dimensionless].\n::Type{T}: Target type [dimensionless].\n\nReturns\n\nValue coerced to the target, according to the rules below.\n\nNotes\n\nNumber â†’ R<:AbstractFloat: uses convert(R, x).\nNumber â†’ M<:Measurement: embeds the number as a zeroâ€‘uncertainty measurement (i.e., zero(M) + x).\nMeasurement â†’ M<:Measurement: recreates with the target inner type (value and uncertainty cast to _meas_inner(M)).\nMeasurement â†’ R<:AbstractFloat: drops uncertainty and converts the nominal value.\nnothing and missing pass through unchanged.\nBool, Symbol, String, Function, DataType: passed through unchanged for measurement/real targets.\nFallback: returns x unchanged.\n\nExamples\n\nusing Measurements\n\n_coerce_elt_to_T(1.2, Float32)                         # 1.2f0\n_coerce_elt_to_T(1.2, Measurement{Float64})            # 1.2 Â± 0.0\n_coerce_elt_to_T(measurement(2.0, 0.1), Float32)       # 2.0f0\n_coerce_elt_to_T(measurement(2.0, 0.1), Measurement{Float32})  # 2.0 Â± 0.1 (Float32 inner)\n_coerce_elt_to_T(missing, Float64)                     # missing\n\nMethods\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:205.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:206.\n\n_coerce_elt_to_T(m, _)\n\ndefined at typecoercion.jl:207.\n\n_coerce_elt_to_T(m, _)\n\ndefined at typecoercion.jl:209.\n\n_coerce_elt_to_T(_, _)\n\ndefined at typecoercion.jl:210.\n\n_coerce_elt_to_T(_, _)\n\ndefined at typecoercion.jl:211.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:212.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:213.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:214.\n\n_coerce_elt_to_T(x, _)\n\ndefined at typecoercion.jl:215.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LineCableModels.Utils._hascomplex_type","page":"API reference","title":"LineCableModels.Utils._hascomplex_type","text":"Determines whether a Type contains or is a Complex number type somewhere in its structure. The check is recursive over arrays, tuples (including variadic tuples), named tuples, and union types. For concrete struct types, the predicate descends into field types. Guards are present to avoid infinite recursion through known selfâ€‘referential types (e.g., Measurements.Measurement).\n\nArguments\n\n::Type: Type to inspect [dimensionless].\n\nReturns\n\nBool indicating whether a Complex type occurs anywhere within the type structure.\n\nNotes\n\nFor AbstractArray{S}, only the element type S is inspected.\nFor Tuple and NamedTuple{N,T}, the parameters are traversed.\nFor Union, both branches are inspected.\nConcrete Measurement types are treated as terminal and are not descended.\n\nExamples\n\n_hascomplex_type(Float64)                  # false\n_hascomplex_type(Complex{Float64})         # true\n_hascomplex_type(Vector{ComplexF64})       # true\n_hascomplex_type(Tuple{Int, ComplexF64})   # true\n\nMethods\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:81.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:82.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:83.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:84.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:86.\n\n_hascomplex_type(T)\n\ndefined at typecoercion.jl:87.\n\n_hascomplex_type(T)\n\ndefined at typecoercion.jl:88.\n\n_hascomplex_type(_)\n\ndefined at typecoercion.jl:94.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LineCableModels.Utils._hasmeas_type-Tuple{Type{<:Measurements.Measurement}}","page":"API reference","title":"LineCableModels.Utils._hasmeas_type","text":"_hasmeas_type(_::Type{<:Measurements.Measurement}) -> Bool\n\n\nDetermines whether a Type contains or is a Measurements.Measurement somewhere in its structure. The check is recursive over arrays, tuples (including variadic tuples), named tuples, and union types. For concrete struct types, the predicate descends into field types. Guards are present to avoid infinite recursion through known selfâ€‘contained types (e.g., Complex).\n\nArguments\n\n::Type: Type to inspect [dimensionless].\n\nReturns\n\nBool indicating whether a Measurement occurs anywhere within the type structure.\n\nNotes\n\nFor AbstractArray{S}, only the element type S is inspected.\nFor Tuple and NamedTuple{N,T}, the parameters are traversed.\nFor Union, both branches are inspected.\nConcrete Complex types are treated as terminal and are not descended.\n\nExamples\n\nusing Measurements\n\n_hasmeas_type(Float64)                    # false\n_hasmeas_type(Measurement{Float64})       # true\n_hasmeas_type(Vector{Measurement{Float64}}) # true\n_hasmeas_type(Tuple{Int, Float64})        # false\n_hasmeas_type(Union{Int, Measurement{Float64}}) # true\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils._meas_inner-Union{Tuple{Type{Measurements.Measurement{S}}}, Tuple{S}} where S","page":"API reference","title":"LineCableModels.Utils._meas_inner","text":"_meas_inner(_::Type{Measurements.Measurement{S}}) -> Any\n\n\nExtracts the real inner type S from Measurement{S}.\n\nArguments\n\n::Type{Measurement{S}}: Measurement type wrapper [dimensionless].\n\nReturns\n\nThe inner floatingâ€point type S [dimensionless].\n\nExamples\n\nusing Measurements\n\nS = _meas_inner(Measurement{Float64})  # Float64\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.block_transform!-Union{Tuple{F}, Tuple{Any, AbstractVector{<:Integer}, F, Vararg{Any}}} where F","page":"API reference","title":"LineCableModels.Utils.block_transform!","text":"Apply f to every square block of M defined by map, in-place.\n\nM: nÃ—n or nÃ—nÃ—nf (any eltype).\nmap: length-n; equal ids => same block (non-contiguous ok).\nf: function like f(B::AbstractMatrix, args...) -> kÃ—k Matrix.\nargs...: extra positional args passed to f.\nslice_positions: positions in args that should be indexed as args[i][idx]  per block (useful for phase_map).\n\nReturns M.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LineCableModels.Utils.@autoexport-Tuple{}","page":"API reference","title":"LineCableModels.Utils.@autoexport","text":"Automatically exports public functions, types, and modules from a module. This is meant for temporary development chores and should never be used in production code.\n\nArguments\n\nNone.\n\nReturns\n\nAn export expression containing all public symbols that should be exported.\n\nNotes\n\nThis macro scans the current module for all defined symbols and automatically generates an export statement for public functions, types, and submodules, excluding built-in and private names. Private names are considered those starting with an underscore ('_'), as per standard Julia conventions.\n\nExamples\n\n@autoexport\n\n\n\n\n\n","category":"macro"},{"location":"tutorials/tutorial2/#Tutorial-2-Building-a-cable-design","page":"Tutorial 2 - Building a cable design","title":"Tutorial 2 - Building a cable design","text":"This tutorial demonstrates how to model a typical medium-voltage single-core power cable using the LineCableModels.jl package. The objective is to build a complete representation of a single-core 18/30 kV cable with a 1000 mmÂ² aluminum conductor and 35 mmÂ² copper screen.\n\nTutorial outline\n\nPages = [\n\t\"tutorial2.md\",\n]\nDepth = 2:3","category":"section"},{"location":"tutorials/tutorial2/#Introduction","page":"Tutorial 2 - Building a cable design","title":"Introduction","text":"Single-core power cables have a complex structure consisting of multiple concentric layers, each with specific geometric and material properties â€“ for example, a cable of type NA2XS(FL)2Y 18/30 is shown here. Prior to building actual transmission line models that incorporate cables as part of the transmission system, e.g. for EMT simulations, power flow, harmonics, protection studies etc., it is necessary to determine the base (or DC) electrical parameters of the cable itself.\n\nThis tutorial covers:\n\nCreating a detailed CableDesign with all its components.\nExamining the main electrical parameters (R, L, C) of the cable core ConductorGroup and main InsulatorGroup.\nExamining the equivalent electromagnetic properties of every CableComponent (core, sheath, jacket).\nSaving the cable design to a CablesLibrary for future use.\nAssigning CableDesign objects to a LineCableSystem and exporting the model to PSCAD for EMT analysis.","category":"section"},{"location":"tutorials/tutorial2/#Getting-started","page":"Tutorial 2 - Building a cable design","title":"Getting started","text":"Load the package and set up the environment:\n\nusing LineCableModels\nusing DataFrames\nimport LineCableModels.PlotBuilder.BackendHandler: renderfig #hide\nfullfile(filename) = joinpath(@__DIR__, filename); #hide\nset_verbosity!(0); #hide\nset_backend!(:gl); #hide\nnothing #hide\n\nInitialize materials library with default values:\n\nmaterials = MaterialsLibrary(add_defaults = true)\nmaterials_df = DataFrame(materials)\n\n# Alternatively, it can be loaded from the example file built in the previous tutorial:\nload!(materials, file_name = \"materials_library.json\")","category":"section"},{"location":"tutorials/tutorial2/#Cable-dimensions","page":"Tutorial 2 - Building a cable design","title":"Cable dimensions","text":"The cable under consideration is a medium-voltage, stranded aluminum conductor cable with XLPE insulation, copper wire concentric screens, water-blocking tape, and PE jacket that is rated for 18/30 kV systems. This information is typically found in the cable datasheet and is fully described in the code type under standards HD 620 10C [10] or DIN VDE 0276-620 [11]:\n\nNA2XS(FL)2Y\n-----------\nâ”‚ â”‚   â”‚  â”‚\nâ”‚ â”‚   â”‚  â””â”€â”€ 2Y: Outer sheath of polyethylene (PE)\nâ”‚ â”‚   â””â”€â”€ (FL): Longitudinal watertight protection\nâ”‚ â”‚\nâ”‚ â””â”€â”€ 2XS: XLPE insulation with screen of copper wires\nâ””â”€â”€ NA: Aluminum conductor\n\nAfter some research, it is found that a typical cable of this type has the following configuration:\n\nnum_co_wires = 61  # number of core wires\nnum_sc_wires = 49  # number of screen wires\nd_core = 38.1e-3   # nominal core overall diameter\nd_w = 4.7e-3       # nominal strand diameter of the core\nt_sc_in = 0.6e-3   # nominal internal semicon thickness\nt_ins = 8e-3       # nominal main insulation thickness\nt_sc_out = 0.3e-3  # nominal external semicon thickness\nd_ws = .95e-3      # nominal wire screen diameter\nt_cut = 0.1e-3     # nominal thickness of the copper tape (around wire screens)\nw_cut = 10e-3      # nominal width of copper tape\nt_wbt = .3e-3      # nominal thickness of the water blocking tape\nt_sct = .3e-3      # nominal thickness of the semiconductive tape\nt_alt = .15e-3     # nominal thickness of the aluminum tape\nt_pet = .05e-3     # nominal thickness of the pe face in the aluminum tape\nt_jac = 2.4e-3     # nominal PE jacket thickness\n\nd_overall = d_core #hide\nlayers = [] #hide\npush!(layers, (\"Conductor\", missing, d_overall * 1000)) #hide\nd_overall += 2 * t_sct #hide\npush!(layers, (\"Inner semiconductive tape\", t_sct * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sc_in #hide\npush!(layers, (\"Inner semiconductor\", t_sc_in * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_ins #hide\npush!(layers, (\"Main insulation\", t_ins * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sc_out #hide\npush!(layers, (\"Outer semiconductor\", t_sc_out * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_sct #hide\npush!(layers, (\"Outer semiconductive tape\", t_sct * 1000, d_overall * 1000)) #hide\nd_overall += 2 * d_ws #hide\npush!(layers, (\"Wire screen\", d_ws * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_cut #hide\npush!(layers, (\"Copper tape\", t_cut * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_wbt #hide\npush!(layers, (\"Water-blocking tape\", t_wbt * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_alt #hide\npush!(layers, (\"Aluminum tape\", t_alt * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_pet #hide\npush!(layers, (\"PE with aluminum face\", t_pet * 1000, d_overall * 1000)) #hide\nd_overall += 2 * t_jac #hide\npush!(layers, (\"PE jacket\", t_jac * 1000, d_overall * 1000)); #hide\nnothing #hide\n\nThe cable structure is summarized in a table for better visualization, with dimensions in milimiters:\n\ndf = DataFrame( #hide\n\tlayer = first.(layers), #hide\n\tthickness = [ #hide\n\t\tismissing(t) ? \"-\" : round(t, sigdigits = 2) for t in getindex.(layers, 2) #hide\n\t], #hide\n\tdiameter = [round(d, digits = 2) for d in getindex.(layers, 3)], #hide\n) #hide","category":"section"},{"location":"tutorials/tutorial2/#Using-the-cable-constructors","page":"Tutorial 2 - Building a cable design","title":"Using the cable constructors","text":"note: Object hierarchy\nThe LineCableModels.DataModel module implements a carefully designed component hierarchy that mirrors the physical construction of power cables while maintaining the mathematical relationships required for accurate electrical modeling.\n\nCableDesign\nâ”œâ”€â”€ CableComponent\nâ”‚   â”œâ”€â”€ conductor_group::ConductorGroup <: AbstractConductorPart\nâ”‚   â”‚   â”œâ”€â”€ conductor_props::Material\nâ”‚   â”‚   â””â”€â”€ layers::Vector{AbstractConductorPart}\nâ”‚   â”‚       â”œâ”€â”€ CircStrands\nâ”‚   â”‚       â”œâ”€â”€ Tubular\nâ”‚   â”‚       â”œâ”€â”€ Strip\nâ”‚   â”‚       â””â”€â”€ â€¦\nâ”‚   â””â”€â”€ insulator_group::InsulatorGroup <: AbstractInsulatorPart\nâ”‚       â”œâ”€â”€ insulator_props::Material\nâ”‚       â””â”€â”€ layers::Vector{AbstractInsulatorPart}\nâ”‚           â”œâ”€â”€ Insulator\nâ”‚           â”œâ”€â”€ Semicon\nâ”‚           â””â”€â”€ â€¦\nâ‹®\nâ”œâ”€â”€ CableComponent\nâ”‚   â”œâ”€â”€ â€¦\nâ‹®   â‹®","category":"section"},{"location":"tutorials/tutorial2/#Cable-designs","page":"Tutorial 2 - Building a cable design","title":"Cable designs","text":"The CableDesign object is the main container for all cable components. It encapsulates the entire cable structure and provides methods for calculating global cable properties.","category":"section"},{"location":"tutorials/tutorial2/#Cable-components","page":"Tutorial 2 - Building a cable design","title":"Cable components","text":"Each CableComponent represents a functional group of the cable (core, sheath, armor, outer), organized into a conductor group and an insulator group with their respective effective material properties. This structure is designed to provide precise calculation of electromagnetic parameters.","category":"section"},{"location":"tutorials/tutorial2/#Conductor-groups","page":"Tutorial 2 - Building a cable design","title":"Conductor groups","text":"The ConductorGroup object serves as a specialized container for organizing AbstractConductorPart elements in layers. It calculates equivalent resistance (R) and inductance (L) values for all contained conductive elements, handling the complexity of different geometrical arrangements.","category":"section"},{"location":"tutorials/tutorial2/#AbstractConductorPart-implementations","page":"Tutorial 2 - Building a cable design","title":"AbstractConductorPart implementations","text":"The CircStrands object models stranded cores and screens with helical patterns and circular cross-sections.\nThe Tubular object represents simple tubular conductors with straightforward parameter calculations.\nThe Strip object models conductor tapes following helical patterns with rectangular cross-sections.","category":"section"},{"location":"tutorials/tutorial2/#Insulator-groups","page":"Tutorial 2 - Building a cable design","title":"Insulator groups","text":"The InsulatorGroup object organizes AbstractInsulatorPart elements in concentric layers, calculating the equivalent capacitance (C) and conductance (G) parameters.","category":"section"},{"location":"tutorials/tutorial2/#AbstractInsulatorPart-implementations","page":"Tutorial 2 - Building a cable design","title":"AbstractInsulatorPart implementations","text":"The Insulator object represents dielectric layers with very high resistivity.\nThe Semicon object models semiconducting layers with intermediate resistivity and high permittivity.\n\nnote: Equivalent circuit parameters\nThe  hierarchical structure enables accurate calculation of equivalent circuit parameters by:Computing geometry-specific parameters at the AbstractConductorPart and AbstractInsulatorPart levels.\nAggregating these into equivalent parameters within ConductorGroup and InsulatorGroup.\nConverting the composite structure into an equivalent coaxial model by matching lumped circuit quantities (R, L, C, G) to effective electromagnetic properties (Ï, Îµ, Âµ) at the CableComponent level. The effective properties are stored in dedicated Material objects.","category":"section"},{"location":"tutorials/tutorial2/#Core-and-main-insulation","page":"Tutorial 2 - Building a cable design","title":"Core and main insulation","text":"The core consists of a 4-layer AAAC stranded conductor with 61 wires arranged in (1/6/12/18/24) pattern, with respective lay ratios of (15/13.5/12.5/11) [12]. Stranded conductors are modeled using the CircStrands object, which handles the helical pattern and twisting effects via the calc_helical_params method.\n\nInitialize the conductor object and assign the central wire:\n\nmaterial = get(materials, \"aluminum\")\ncore = ConductorGroup(CircStrands(0.0, Diameter(d_w), 1, 0.0, material))\n\ntip: Convenience methods\nThe add! method internally passes the radius_ext of the existing object to the radius_in argument of the new conductor. This enables easy stacking of multiple layers without redundancy. Moreover, the Diameter method is a convenience function that converts the diameter to radius at the constructor level. This maintains alignment with manufacturer specifications while enabling internal calculations to use radius values directly. This approach eliminates repetitive unit conversions and potential sources of implementation error.\n\nAdd the subsequent layers of wires and inspect the object:\n\nadd!(core, CircStrands, Diameter(d_w), 6, 15.0, material)\nadd!(core, CircStrands, Diameter(d_w), 12, 13.5, material)\nadd!(core, CircStrands, Diameter(d_w), 18, 12.5, material)\nadd!(core, CircStrands, Diameter(d_w), 24, 11.0, material)","category":"section"},{"location":"tutorials/tutorial2/#Inner-semiconductor","page":"Tutorial 2 - Building a cable design","title":"Inner semiconductor","text":"The inner semiconductor layer ensures uniform electric field distribution between the conductor and insulation, eliminating air gaps and reducing field concentrations. An optional semiconductive tape is often used to ensure core uniformity and enhanced adherence.\n\ntip: Convenience methods\nThe Thickness type is a convenience wrapper that simplifies layer construction. When used in a constructor, it automatically calculates the outer radius by adding the thickness to the inner radius (which is inherited from the previous layer's outer radius).\n\nInner semiconductive tape:\n\nmaterial = get(materials, \"polyacrylate\")\nmain_insu = InsulatorGroup(Semicon(core, Thickness(t_sct), material))\n\nInner semiconductor (1000 Î©.m as per IEC 840):\n\nmaterial = get(materials, \"semicon1\")\nadd!(main_insu, Semicon, Thickness(t_sc_in), material)","category":"section"},{"location":"tutorials/tutorial2/#Main-insulation","page":"Tutorial 2 - Building a cable design","title":"Main insulation","text":"XLPE (cross-linked polyethylene) is the standard insulation material for modern medium and high voltage cables due to its excellent dielectric properties.\n\nAdd the insulation layer:\n\nmaterial = get(materials, \"pe\")\nadd!(main_insu, Insulator, Thickness(t_ins), material)","category":"section"},{"location":"tutorials/tutorial2/#Outer-semiconductor","page":"Tutorial 2 - Building a cable design","title":"Outer semiconductor","text":"Similar to the inner semiconductor, the outer semiconductor provides a uniform transition from insulation to the metallic screen.\n\nOuter semiconductor (500 Î©.m as per IEC 840):\n\nmaterial = get(materials, \"semicon2\")\nadd!(main_insu, Semicon, Thickness(t_sc_out), material)\n\nOuter semiconductive tape:\n\nmaterial = get(materials, \"polyacrylate\")\nadd!(main_insu, Semicon, Thickness(t_sct), material)\n\nGroup core-related components:\n\ncore_cc = CableComponent(\"core\", core, main_insu)\n\nWith the core parts properly defined, the CableDesign object is initialized with nominal data from the datasheet. This includes voltage ratings and reference electrical parameters that will be used to benchmark the design.\n\nDefine the nominal values and instantiate the CableDesign with the core_cc component:\n\ncable_id = \"18kV_1000mm2\"\ndatasheet_info = NominalData(\n\tdesignation_code = \"NA2XS(FL)2Y\",\n\tU0 = 18.0,                        # Phase-to-ground voltage [kV]\n\tU = 30.0,                         # Phase-to-phase voltage [kV]\n\tconductor_cross_section = 1000.0, # [mmÂ²]\n\tscreen_cross_section = 35.0,      # [mmÂ²]\n\tresistance = 0.0291,              # DC resistance [Î©/km]\n\tcapacitance = 0.39,               # Capacitance [Î¼F/km]\n\tinductance = 0.3,                 # Inductance in trifoil [mH/km]\n)\ncable_design = CableDesign(cable_id, core_cc, nominal_data = datasheet_info)\n\nAt this point, it becomes possible to preview the cable design:\n\nplt1, _ = preview(cable_design)\nplt1 #hide","category":"section"},{"location":"tutorials/tutorial2/#Wire-screens","page":"Tutorial 2 - Building a cable design","title":"Wire screens","text":"The metallic screen (typically copper) serves multiple purposes:\n\nProvides a return path for fault currents.\nEnsures radial symmetry of the electric field.\nActs as electrical shielding.\nProvides mechanical protection.\n\nBuild the wire screens on top of the previous layer:\n\nlay_ratio = 10.0 # typical value for wire screens\nmaterial = get(materials, \"copper\")\nscreen_con =\n\tConductorGroup(\n\t\tCircStrands(main_insu, Diameter(d_ws), num_sc_wires, lay_ratio, material),\n\t)\n\nAdd the equalizing copper tape wrapping the wire screen:\n\nadd!(screen_con, Strip, Thickness(t_cut), w_cut, lay_ratio, material)\n\nWater blocking tape over screen:\n\nmaterial = get(materials, \"polyacrylate\")\nscreen_insu = InsulatorGroup(Semicon(screen_con, Thickness(t_wbt), material))\n\nGroup sheath components and assign to design:\n\nsheath_cc = CableComponent(\"sheath\", screen_con, screen_insu)\nadd!(cable_design, sheath_cc)\n\nExamine the newly added components:\n\nplt2, _ = preview(cable_design)\nplt2 #hide","category":"section"},{"location":"tutorials/tutorial2/#Outer-jacket-components","page":"Tutorial 2 - Building a cable design","title":"Outer jacket components","text":"Modern cables often include an aluminum tape as moisture barrier and PE (polyethylene) outer jacket for mechanical protection.\n\nAdd the aluminum foil (moisture barrier):\n\nmaterial = get(materials, \"aluminum\")\njacket_con = ConductorGroup(Tubular(screen_insu, Thickness(t_alt), material))\n\nPE layer after aluminum foil:\n\nmaterial = get(materials, \"pe\")\njacket_insu = InsulatorGroup(Insulator(jacket_con, Thickness(t_pet), material))\n\nPE jacket (outer mechanical protection):\n\nmaterial = get(materials, \"pe\")\nadd!(jacket_insu, Insulator, Thickness(t_jac), material)\n\ntip: Convenience methods\nTo facilitate data entry, it is possible to call the add! method directly on the ConductorGroup and InsulatorGroup constituents of the component to include, without instantiating the CableComponent first.\n\nAssign the jacket parts directly to the design:\n\nadd!(cable_design, \"jacket\", jacket_con, jacket_insu)\n\nInspect the finished cable design:\n\nplt3, _ = preview(cable_design)\nplt3 #hide","category":"section"},{"location":"tutorials/tutorial2/#Examining-the-cable-parameters-(RLC)","page":"Tutorial 2 - Building a cable design","title":"Examining the cable parameters (RLC)","text":"In this section, the cable design is examined and the calculated parameters are compared with datasheet values. LineCableModels.jl provides methods to analyze the design in different levels of detail.\n\nCompare with datasheet information (R, L, C values):\n\ncore_df = DataFrame(cable_design, :baseparams)\n\nObtain the equivalent electromagnetic properties of the cable:\n\ncomponents_df = DataFrame(cable_design, :components)\n\nGet detailed description of all cable parts:\n\ndetailed_df = DataFrame(cable_design, :detailed)","category":"section"},{"location":"tutorials/tutorial2/#Saving-the-cable-design","page":"Tutorial 2 - Building a cable design","title":"Saving the cable design","text":"note: Cables library\nDesigns can be saved to a library for future use. The CablesLibrary is a container for storing multiple cable designs, allowing for easy access and reuse in different projects.  Library management is performed using the DataFrame, add!, and save functions.\n\nStore the cable design and inspect the library contents:\n\nlibrary = CablesLibrary()\nadd!(library, cable_design)\nlibrary_df = DataFrame(library)\n\nSave to file for later use:\n\noutput_file = fullfile(\"cables_library.json\")\nsave(library, file_name = output_file);\nnothing #hide","category":"section"},{"location":"tutorials/tutorial2/#Defining-a-cable-system","page":"Tutorial 2 - Building a cable design","title":"Defining a cable system","text":"note: Cable systems\nA cable system is a collection of cables with defined positions, length and environmental characteristics. The LineCableSystem object is the main container for all cable systems, and it allows the definition of multiple cables in different configurations (e.g., trifoil, flat etc.). This object is the entry point for all system-related calculations and analyses.","category":"section"},{"location":"tutorials/tutorial2/#Earth-model","page":"Tutorial 2 - Building a cable design","title":"Earth model","text":"The earth return path significantly affects cable impedance calculations and needs to be properly modeled. In this tutorial, only a basic model with typical soil properties is defined. This will be further elaborated in the subsequent tutorials.\n\nDefine a frequency-dependent earth model (1 Hz to 1 MHz):\n\nf = 10.0 .^ range(0, stop = 6, length = 10)  # Frequency range\nearth_params = EarthModel(f, 100.0, 10.0, 1.0)  # 100 Î©Â·m resistivity, Îµr=10, Î¼r=1\n\nEarth model base (DC) properties:\n\nearthmodel_df = DataFrame(earth_params)","category":"section"},{"location":"tutorials/tutorial2/#Three-phase-system-in-trifoil-configuration","page":"Tutorial 2 - Building a cable design","title":"Three-phase system in trifoil configuration","text":"This section ilustrates the construction of a cable system with three identical cables arranged in a trifoil formation.\n\nDefine system center point (underground at 1 m depth) and the trifoil positions\n\nx0, y0 = 0.0, -1.0\nxa, ya, xb, yb, xc, yc = trifoil_formation(x0, y0, 0.035);\nnothing #hide\n\nInitialize the LineCableSystem with the first cable (phase A):\n\ncablepos = CablePosition(cable_design, xa, ya,\n\tDict(\"core\" => 1, \"sheath\" => 0, \"jacket\" => 0))\ncable_system = LineCableSystem(\"18kV_1000mm2_trifoil\", 1000.0, cablepos)\n\nAdd remaining cables (phases B and C):\n\nadd!(cable_system, cable_design, xb, yb,\n\tDict(\"core\" => 2, \"sheath\" => 0, \"jacket\" => 0))\nadd!(cable_system, cable_design, xc, yc,\n\tDict(\"core\" => 3, \"sheath\" => 0, \"jacket\" => 0))\n\nnote: Phase mapping\nThe add! function allows the specification of phase mapping for each cable. The Dict argument maps the cable components to their respective phases, where core is the conductor, sheath is the screen, and jacket is the outer jacket. The values (1, 2, 3) represent the phase numbers (A, B, C) in this case. Components mapped to phase 0 will be Kron-eliminated (grounded). Components set to the same phase will be bundled into an equivalent phase.","category":"section"},{"location":"tutorials/tutorial2/#Cable-system-preview","page":"Tutorial 2 - Building a cable design","title":"Cable system preview","text":"In this section the complete three-phase cable system is examined.\n\nDisplay system details:\n\nsystem_df = DataFrame(cable_system)\n\nVisualize the cross-section of the three-phase system:\n\nplt4, _ = preview(cable_system, earth_model = earth_params, zoom_factor = 2.0)\nplt4 #hide","category":"section"},{"location":"tutorials/tutorial2/#PSCAD-and-ATPDraw-export","page":"Tutorial 2 - Building a cable design","title":"PSCAD & ATPDraw export","text":"The final step showcases how to export the model for electromagnetic transient simulations in EMT-type software.\n\nExport to PSCAD input file:\n\noutput_file = fullfile(\"pscad_export.pscx\")\nexport_file = export_data(:pscad, cable_system, earth_params, file_name = output_file);\nnothing #hide\n\nExport to ATPDraw project file (XML):\n\noutput_file = fullfile(\"atp_export.xml\")\nexport_file = export_data(:atp, cable_system, earth_params, file_name = output_file);\nnothing #hide","category":"section"},{"location":"tutorials/tutorial2/#Conclusion","page":"Tutorial 2 - Building a cable design","title":"Conclusion","text":"This tutorial has demonstrated how to:\n\nCreate a detailed model of a complex power cable with multiple concentric layers.\nCalculate and analyze the cable base parameters (R, L, C).\nDesign a three-phase cable system in trifoil arrangement.\nExport the model for further analysis in specialized software.\n\nLineCableModels.jl provides a powerful framework for accurate power cable modeling with a physically meaningful representation of all cable components. This approach ensures that electromagnetic parameters are calculated with high precision. Now you can go ahead and run these cable simulations like a boss!\n\n\n\nğŸ  Back to Tutorials","category":"section"},{"location":"validation/#Validation-module","page":"Validation module","title":"Validation module","text":"","category":"section"},{"location":"validation/#Contents","page":"Validation module","title":"Contents","text":"Pages = [\"validation.md\"]\nDepth = 3\n\n\n\nThis section documents the validation framework used by component constructors. The design is deterministic, nonâ€‘magical, and traitâ€‘driven. The flow is:\n\nsanitize(Type, args, kwargs)  â†’  parse(Type, nt)  â†’  apply rules  â†’  construct\n\nThe typed cores accept numbers only. All proxy handling happens in the convenience constructors via validate!.\n\n","category":"section"},{"location":"validation/#Architecture","page":"Validation module","title":"Architecture","text":"","category":"section"},{"location":"validation/#Pipeline","page":"Validation module","title":"Pipeline","text":"sanitize(::Type{T}, args::Tuple, kwargs::NamedTuple)\nRejects wrong arities: exactly length(required_fields(T)) positionals are expected; optionals must be passed as keywords listed in keyword_fields(T).\nMaps positionals to names using required_fields(T); merges keyword arguments; rejects unknown keywords.\nIf has_radii(T) == true, checks admissibility of raw radius inputs with is_radius_input(T, Val(:radius_in), x) and is_radius_input(T, Val(:radius_ext), x). The default accepts only real, nonâ€‘complex numbers; types may extend to allow proxies.\nReturns a raw NamedTuple.\nparse(::Type{T}, nt)\nNormalizes raw inputs to canonical representation (e.g., radius proxies â†’ numeric radii) while preserving domain semantics (e.g., uncertainty reset rules).\nReturns a normalized NamedTuple.\nRule application\n_rules(T) is generated from traits; evaluates over the normalized NamedTuple.\nStandard bundles are injected when traits are true (e.g., for radii: Normalized, Finite, Nonneg, Less).\nPerâ€‘type extras come from extra_rules(T).\nvalidate!(::Type{T}, args...; kwargs...)\nOrchestrates the pipeline. Use this in all convenience constructors.","category":"section"},{"location":"validation/#Traits-(configuration-surface)","page":"Validation module","title":"Traits (configuration surface)","text":"has_radii(::Type{T})::Bool â€” enables the radii rule bundle and raw acceptance checks.\nhas_temperature(::Type{T})::Bool â€” enables finiteness check on :temperature.\nrequired_fields(::Type{T})::NTuple â€” positional keys.\nkeyword_fields(::Type{T})::NTuple â€” keyword argument keys.\ncoercive_fields(::Type{T})::NTuple â€” values that participate in type promotion and will be coerced (default: required_fields âˆª keyword_fields).\nis_radius_input(::Type{T}, Val(:field), x)::Bool â€” raw admissibility predicate for radii inputs; extend to allow proxies by field.\nextra_rules(::Type{T})::NTuple{K,Rule} â€” additional constraints appended to the generated bundle.\n\nImport before extending:\n\nimport ..Validation: has_radii, has_temperature, required_fields, keyword_fields,\n                     coercive_fields, is_radius_input, parse, extra_rules\n\nFailing to import will create shadow functions in your module; the engine will not see your methods.\n\n","category":"section"},{"location":"validation/#Rules","page":"Validation module","title":"Rules","text":"Rules are small value types struct <: Rule with an _apply(::Rule, nt, ::Type{T}) method. All rule methods must:\n\nRead data from the normalized NamedTuple nt.\nThrow ArgumentError for logical violations; DomainError for numerical domain violations (nonâ€‘finite).\nAvoid allocations; use @inline where appropriate.","category":"section"},{"location":"validation/#Standard-rules","page":"Validation module","title":"Standard rules","text":"Normalized(:field) â€” field must be numeric postâ€‘parse.\nFinite(:field) â€” isfinite must hold.\nNonneg(:field) â€” value â‰¥ 0.\nPositive(:field) â€” value > 0.\nIntegerField(:field) â€” value isa Integer.\nLess(:a,:b) â€” strict ordering a < b.\nLessEq(:a,:b) â€” nonâ€‘strict ordering a â‰¤ b.\nIsA{M}(:field) â€” type membership check.\nOneOf(:field, set) â€” membership in a finite set.","category":"section"},{"location":"validation/#Custom-rule-pattern","page":"Validation module","title":"Custom rule pattern","text":"struct InRange{T} <: Validation.Rule\n    name::Symbol; lo::T; hi::T\nend\n\n@inline function Validation._apply(r::InRange, nt, ::Type{T}) where {T}\n    x = getfield(nt, r.name)\n    (x isa Number && !(x isa Complex)) || throw(ArgumentError(\"[$(String(nameof(T)))] $(r.name) must be real\"))\n    (r.lo â‰¤ x â‰¤ r.hi) || throw(ArgumentError(\"[$(String(nameof(T)))] $(r.name) out of range $(r.lo):$(r.hi), got $(x)\"))\nend\n\nAttach via extra_rules(::Type{X}) = (InRange(:alpha, 0.0, 1.0), ...).\n\n","category":"section"},{"location":"validation/#Example-implementation-â€”-DataModel.Tubular","page":"Validation module","title":"Example implementation â€” DataModel.Tubular","text":"Typed core (numbers only):\n\nfunction Tubular(radius_in::T, radius_ext::T, material_props::Material{T}, temperature::T) where {T<:REALSCALAR}\n\nRationale: all proxy resolution must happen before reaching the typed core to avoid duplicate parsing and to keep type promotion deterministic.\n\nTrait configuration:\n\nconst _REQ_TUBULAR = (:radius_in, :radius_ext, :material_props,)\nconst _OPT_TUBULAR = (:temperature,)\nconst _DEFS_TUBULAR = (Tâ‚€,)\n\nValidation.has_radii(::Type{Tubular}) = true\nValidation.has_temperature(::Type{Tubular}) = true\nValidation.required_fields(::Type{Tubular}) = _REQ_TUBULAR\nValidation.keyword_fields(::Type{Tubular}) = _OPT_TUBULAR\n\nhas_radii = true enables the radii bundle: Normalized(:radius_in), Normalized(:radius_ext), Finite, Nonneg, Less(:radius_in,:radius_ext).\nhas_temperature = true adds Finite(:temperature).\nrequired_fields defines the mandatory positional fields.\nkeyword_fields defines the optional fields that will receive default values.\n\nRaw proxy acceptance:\n\nValidation.is_radius_input(::Type{Tubular}, ::Val{:radius_in}, x::AbstractCablePart) = true\nValidation.is_radius_input(::Type{Tubular}, ::Val{:radius_ext}, x::Thickness) = true\nValidation.is_radius_input(::Type{Tubular}, ::Val{:radius_ext}, x::Diameter) = true\n\nThe inner radius may take an existing cable part (its radius_ext); the outer radius may take a Thickness or Diameter wrapper.\n\nExtra rules:\n\nValidation.extra_rules(::Type{Tubular}) = (IsA{Material}(:material_props),)\n\nParsing:\n\nValidation.parse(::Type{Tubular}, nt) = begin\n    rin, rex = _normalize_radii(Tubular, nt.radius_in, nt.radius_ext)\n    (; nt..., radius_in=rin, radius_ext=rex)\nend\n\nConvenience constructor:\n\n@construct Tubular _REQ_TUBULAR _OPT_TUBULAR _DEFS_TUBULAR\n\nThis expands to a weaklyâ€‘typed method that calls validate!, promotes using _promotion_T, coerces via _coerced_args, and delegates to the numeric core.\n\nFailure modes intentionally trapped:\n\nWrong arity, missing keys â†’ sanitize via required_fields.\nString/complex radii â†’ sanitize via default is_radius_input (unless explicitly allowed).\nForgotten parsing after allowing proxies â†’ caught by Normalized rules.\nGeometry violations (radius_in â‰¥ radius_ext) â†’ Less(:radius_in,:radius_ext).\n\n","category":"section"},{"location":"validation/#Template-for-a-new-component","page":"Validation module","title":"Template for a new component","text":"# 1) Numeric core (numbers only)\nfunction NewPart(a::T, b::T, material::Material{T}, temperature::T) where {T<:REALSCALAR}\n    # compute derived, then construct\nend\n\n# 2) Trait config\nValidation.has_radii(::Type{NewPart}) = true\nValidation.has_temperature(::Type{NewPart}) = true\nValidation.required_fields(::Type{NewPart}) = (:a, :b, :material)\nValidation.keyword_fields(::Type{NewPart})  = (:temperature,)\n\n# 3) Raw acceptance (extend only what you intend to parse)\nValidation.is_radius_input(::Type{NewPart}, ::Val{:radius_in},  x::AbstractCablePart) = true\nValidation.is_radius_input(::Type{NewPart}, ::Val{:radius_ext}, x::Thickness)        = true\n\n# 4) Extra rules\nValidation.extra_rules(::Type{NewPart}) = (\n    IsA{Material}(:material),\n)\n\n# 5) Parsing (proxy â†’ numeric)\nValidation.parse(::Type{NewPart}, nt) = begin\n    aâ€², bâ€² = _normalize_radii(NewPart, nt.a, nt.b)\n    (; nt..., a=aâ€², b=bâ€²)\nend\n\n# 6) Convenience constructor â€” generated\n@construct NewPart (:a, :b, :material) (:temperature,) (Tâ‚€,)\n\n","category":"section"},{"location":"validation/#Extending-traits","page":"Validation module","title":"Extending traits","text":"Traits are just methods. Add traits only when behavior toggles; avoid proliferation.","category":"section"},{"location":"validation/#New-feature-flags","page":"Validation module","title":"New feature flags","text":"Example: a shielding flag with its own bundle.\n\nValidation.has_shield(::Type) = false\nValidation.has_shield(::Type{SomeType}) = true\n\nExtend _rules inside Validation to splice the corresponding checks when has_shield(T) is true.","category":"section"},{"location":"validation/#Fieldâ€‘specific-admissibility","page":"Validation module","title":"Fieldâ€‘specific admissibility","text":"If only :radius_in should accept proxies, extend the fieldâ€‘tagged predicate:\n\nValidation.is_radius_input(::Type{X}, ::Val{:radius_in},  p::AbstractCablePart) = true\nValidation.is_radius_input(::Type{X}, ::Val{:radius_ext}, ::AbstractCablePart)  = false\n\n","category":"section"},{"location":"validation/#Testing-guidelines","page":"Validation module","title":"Testing guidelines","text":"Test arity: (), (1), (1,2) â†’ ArgumentError.\nTest raw type rejections: strings, complex numbers.\nTest proxy acceptance: prior layer objects, Thickness, Diameter when allowed.\nTest parse correctness: outputs numeric and respect uncertainty rules.\nTest rule violations: negative radii, inverted radii, nonâ€‘finite values, invalid sets.\nTest constructor roundâ€‘trip: convenience path and numeric core produce equivalent instances after coercion.","category":"section"},{"location":"validation/#Usage-notes","page":"Validation module","title":"Usage notes","text":"Keep all proxy handling in parse. Do not call normalizers in constructors.\nError messages must be terse and contextualized with the component type name.\nPrefer tuple returns and NamedTuple updates to avoid allocations.\nWhen adding rules, benchmark _apply implementations.\n\n","category":"section"},{"location":"validation/#API-reference","page":"Validation module","title":"API reference","text":"","category":"section"},{"location":"validation/#Index","page":"Validation module","title":"Index","text":"Pages   = [\"validation.md\"]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"validation/#LineCableModels.Validation","page":"Validation module","title":"LineCableModels.Validation","text":"LineCableModels.Validation\n\nThe Validation module implements a trait-driven, three-phase input checking pipeline for component constructors in LineCableModels. Inputs are first sanitized (arity and shape checks on raw arguments), then parsed (proxy values normalized to numeric radii), and finally validated by a generated set of rules.\n\nOverview\n\nCentralized constructor input handling: sanitize â†’ parse â†’ rule application.\nTrait hooks configure perâ€‘type behavior (has_radii, has_temperature, required_fields, keyword_fields, coercive_fields, etc.).\nRules are small value objects (Rule subtypes) applied to a normalized NamedTuple.\n\nDependencies\n\nBase\nLineCableModels.Commons\n\nExports\n\nFinite\nGreater\nGreaterEq\nIntegerField\nIsA\nLess\nLessEq\nNonneg\nNormalized\nOneOf\nPhysicalFillLimit\nPositive\nSatisfies\ncoercive_fields\nextra_rules\nhas_radii\nhas_temperature\nis_radius_input\nkeyword_defaults\nkeyword_fields\nparse\nrequired_fields\nsanitize\nvalidate!\n\n\n\n\n\n","category":"module"},{"location":"validation/#LineCableModels.Validation.Finite","page":"Validation module","title":"LineCableModels.Validation.Finite","text":"struct Finite <: LineCableModels.Validation.Rule\n\nRule that enforces finiteness of a numeric field.\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Greater","page":"Validation module","title":"LineCableModels.Validation.Greater","text":"struct Greater <: LineCableModels.Validation.Rule\n\nRule that enforces a strict ordering constraint a > b between two fields.\n\na::Symbol: Leftâ€‘hand field name.\nb::Symbol: Rightâ€‘hand field name.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.GreaterEq","page":"Validation module","title":"LineCableModels.Validation.GreaterEq","text":"struct GreaterEq <: LineCableModels.Validation.Rule\n\nRule that enforces a nonâ€‘strict ordering constraint a â‰¥ b between two fields.\n\na::Symbol: Leftâ€‘hand field name.\nb::Symbol: Rightâ€‘hand field name.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.IntegerField","page":"Validation module","title":"LineCableModels.Validation.IntegerField","text":"struct IntegerField <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be of an integer type.\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.IsA","page":"Validation module","title":"LineCableModels.Validation.IsA","text":"struct IsA{M} <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be isa M for a specified type parameter M.\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Less","page":"Validation module","title":"LineCableModels.Validation.Less","text":"struct Less <: LineCableModels.Validation.Rule\n\nRule that enforces a strict ordering constraint a < b between two fields.\n\na::Symbol: Leftâ€‘hand field name.\nb::Symbol: Rightâ€‘hand field name.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.LessEq","page":"Validation module","title":"LineCableModels.Validation.LessEq","text":"struct LessEq <: LineCableModels.Validation.Rule\n\nRule that enforces a nonâ€‘strict ordering constraint a â‰¤ b between two fields.\n\na::Symbol: Leftâ€‘hand field name.\nb::Symbol: Rightâ€‘hand field name.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Nonneg","page":"Validation module","title":"LineCableModels.Validation.Nonneg","text":"struct Nonneg <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be nonâ€‘negative (â‰¥ 0).\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Normalized","page":"Validation module","title":"LineCableModels.Validation.Normalized","text":"struct Normalized <: LineCableModels.Validation.Rule\n\nRule that enforces that a field has already been normalized to a numeric value during parsing. Intended to guard that parse has executed and removed proxies.\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.OneOf","page":"Validation module","title":"LineCableModels.Validation.OneOf","text":"struct OneOf{S} <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be in the set S.\n\nname::Symbol\nset::Any\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.PhysicalFillLimit","page":"Validation module","title":"LineCableModels.Validation.PhysicalFillLimit","text":"struct PhysicalFillLimit <: LineCableModels.Validation.Rule\n\nRule that enforces that the number of discrete elements (e.g., wires or strands) does not exceed the theoretical physical maximum for a given geometry.\n\nn_field::Symbol: Symbol representing the field containing the element count (e.g., :num_wires).\ngeometry_fields::Tuple{Vararg{Symbol}}: Tuple of symbols representing the geometric fields required to compute the limit.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Positive","page":"Validation module","title":"LineCableModels.Validation.Positive","text":"struct Positive <: LineCableModels.Validation.Rule\n\nRule that enforces a field to be strictly positive (> 0).\n\nname::Symbol: Name of the field to check.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Rule","page":"Validation module","title":"LineCableModels.Validation.Rule","text":"abstract type Rule\n\nBase abstract type for validation rules. All concrete rule types must subtype Rule and provide an _apply(::Rule, nt, ::Type{T}) method that checks a field in the normalized NamedTuple nt for the component type T.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation.Satisfies","page":"Validation module","title":"LineCableModels.Validation.Satisfies","text":"struct Satisfies <: LineCableModels.Validation.Rule\n\nA highly flexible rule that enforces an arbitrary user-defined predicate across one or more fields. Useful for complex, cross-field physics or one-off geometrical constraints without polluting the ruleset with bespoke types.\n\nfields::Tuple{Vararg{Symbol}}: Tuple of symbols representing the fields to be evaluated.\npredicate::Function: A function (often anonymous) that accepts the extracted fields as arguments and returns a boolean.\nerror_msg::String: The diagnostic message appended to the error if the predicate returns false.\n\n\n\n\n\n","category":"type"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{M}, Tuple{T}, Tuple{LineCableModels.Validation.IsA{M}, Any, Type{T}}} where {T, M}","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.IsA{M},\n    nt,\n    _::Type{T}\n) -> Bool\n\n\nApplies IsA{M} to ensure a field is of type M.\n\nArguments\n\nr: Rule instance parameterized by M [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Finite, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Finite,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies Finite to ensure the target field is a finite real number.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Greater, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Greater,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies Greater to ensure nt[a] > nt[b].\n\nArguments\n\nr: Rule instance with fields a and b [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.GreaterEq, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.GreaterEq,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies GreaterEq to ensure nt[a] â‰¥ nt[b].\n\nArguments\n\nr: Rule instance with fields a and b [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.IntegerField, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.IntegerField,\n    nt,\n    _::Type{T}\n) -> Bool\n\n\nApplies IntegerField to ensure the target field is an Integer.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Less, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Less,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies Less to ensure nt[a] < nt[b].\n\nArguments\n\nr: Rule instance with fields a and b [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.LessEq, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.LessEq,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies LessEq to ensure nt[a] â‰¤ nt[b].\n\nArguments\n\nr: Rule instance with fields a and b [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Nonneg, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Nonneg,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies Nonneg to ensure the target field is â‰¥ 0.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Normalized, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Normalized,\n    nt,\n    _::Type{T}\n) -> Bool\n\n\nApplies Normalized to ensure the field has been converted to a numeric value during parsing.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.PhysicalFillLimit, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    rule::LineCableModels.Validation.PhysicalFillLimit,\n    nt,\n    _::Type{T}\n)\n\n\nApplies PhysicalFillLimit to ensure the element count does not exceed the capacity computed by the extensible maxfill interface.\n\nArguments\n\nrule: Rule instance with fields n_field and geometry_fields [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws an ArgumentError on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Positive, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.Positive,\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies Positive to ensure the target field is > 0.\n\nArguments\n\nr: Rule instance [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{LineCableModels.Validation.Satisfies, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    rule::LineCableModels.Validation.Satisfies,\n    nt,\n    _::Type{T}\n)\n\n\nApplies Satisfies to evaluate an arbitrary predicate function against the specified fields.\n\nArguments\n\nrule: Rule instance with fields, predicate, and error_msg [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws an ArgumentError on failure.\n\nExamples\n\nValidation.extra_rules(::Type{SomeWeirdType}) = (\n\t# ... basic type rules ...\n\t\n\tSatisfies(\n\t\t(:width, :lay_angle, :overlap_pct),\n\t\t(w, a, pct) -> pct < 1.0 && pct >= 0.0 && w * cos(a) > 0,\n\t\t\"Overlap percentage must be between 0 and 1, and effective width must be positive. Because I said so.\"\n\t)\n)\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._apply-Union{Tuple{T}, Tuple{S}, Tuple{LineCableModels.Validation.OneOf{S}, Any, Type{T}}} where {S, T}","page":"Validation module","title":"LineCableModels.Validation._apply","text":"_apply(\n    r::LineCableModels.Validation.OneOf{S},\n    nt,\n    _::Type{T}\n) -> Any\n\n\nApplies OneOf to ensure the target field is contained in a specified set.\n\nArguments\n\nr: Rule instance with fields name and set [dimensionless].\nnt: Normalized NamedTuple of inputs [dimensionless].\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._ensure_real-Union{Tuple{T}, Tuple{Symbol, Any, Type{T}}} where T","page":"Validation module","title":"LineCableModels.Validation._ensure_real","text":"_ensure_real(field::Symbol, x, _::Type{T})\n\n\nAsserts that x is a real (nonâ€‘complex) number. Used by rule implementations before performing numeric comparisons.\n\nArguments\n\nfield: Field name used in diagnostics [dimensionless].\nx: Value to check [dimensionless].\n::Type{T}: Component type for contextualized messages [dimensionless].\n\nReturns\n\nNothing. Throws on failure.\n\nErrors\n\nArgumentError if x is not isa Number or is a Complex value.\n\nExamples\n\n_ensure_real(:radius_in, 0.01, SomeType)  # ok\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._kwdefaults_nt-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Validation module","title":"LineCableModels.Validation._kwdefaults_nt","text":"_kwdefaults_nt(_::Type{T}) -> NamedTuple\n\n\nInternal helper that canonicalizes keyword_defaults(T) into a NamedTuple keyed by keyword_fields(T). Accepts:\n\n() â†’ returns an empty NamedTuple().\nNamedTuple â†’ returned unchanged.\nTuple â†’ zipped by position with keyword_fields(T); lengths must match.\n\nThis function does not merge user-provided keywords; callers should perform merge(_kwdefaults_nt(T), kwargs) so that user values take precedence.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNamedTuple mapping optional keyword field names to their default values.\n\nErrors\n\nIf keyword_defaults(T) returns a Tuple whose length differs from length(keyword_fields(T)).\nIf keyword_defaults(T) returns a value that is neither () nor a NamedTuple nor a Tuple.\n\nExamples\n\n```julia\n\nSuppose:\n\nkeywordfields(::Type{X})   = (:temperature, :laydirection)\n\nkeyword_defaults(::Type{X}) = (Tâ‚€, 1)\n\nkwdefaultsnt(X)  # => (temperature = Tâ‚€, lay_direction = 1)\n\nIf defaults are already a NamedTuple:\n\nkeyword_defaults(::Type{Y}) = (temperature = 25.0,)\n\nkwdefaultsnt(Y)  # => (temperature = 25.0,) ````\n\nSee also\n\nkeyword_fields\nkeyword_defaults\nsanitize\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._repr-Tuple{Any}","page":"Validation module","title":"LineCableModels.Validation._repr","text":"_repr(x) -> String\n\n\nReturns a compact textual representation of x for error messages.\n\nArguments\n\nx: Value to represent [dimensionless].\n\nReturns\n\nString with a compact repr [dimensionless].\n\nExamples\n\ns = _repr(:field)  # \":field\"\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._rules-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Validation module","title":"LineCableModels.Validation._rules","text":"_rules(_::Type{T}) -> Tuple\n\n\nGenerates (at compile time, via a @generated function) the tuple of rules to apply for component type T. The result concatenates standard bundles driven by traits and any rules returned by extra_rules(T).\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of Rule instances to apply in order.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation._typename-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Validation module","title":"LineCableModels.Validation._typename","text":"_typename(_::Type{T}) -> String\n\n\nReturns the simple (unqualified) name of type T as a String. Utility for constructing diagnostic messages.\n\nArguments\n\n::Type{T}: Type whose name is requested [dimensionless].\n\nReturns\n\nString with the type name [dimensionless].\n\nExamples\n\nname = _typename(Float64)  # \"Float64\"\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.coercive_fields-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Validation module","title":"LineCableModels.Validation.coercive_fields","text":"coercive_fields(_::Type{T}) -> NTuple{5, Symbol}\n\n\nTrait hook listing coercive fields: values that participate in numeric promotion and will be converted to the promoted type by the convenience constructor. Defaults to all fields (required_fields âˆª keyword_fields). Types may override to exclude integers or categorical fields.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of field names that are coerced.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.extra_rules-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.extra_rules","text":"extra_rules(\n    _::Type\n) -> Tuple{LineCableModels.Validation.Normalized, LineCableModels.Validation.Finite, LineCableModels.Validation.Nonneg, LineCableModels.Validation.Normalized, LineCableModels.Validation.Finite, LineCableModels.Validation.Positive, LineCableModels.Validation.IntegerField, LineCableModels.Validation.Positive, LineCableModels.Validation.Finite, LineCableModels.Validation.Nonneg, LineCableModels.Validation.IsA{Material}, LineCableModels.Validation.OneOf{Tuple{Int64, Int64}}}\n\n\nTrait hook providing additional rule instances for a component type. Used to append perâ€‘type constraints after the standard bundles.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of Rule instances.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.has_radii-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.has_radii","text":"has_radii(_::Type) -> Bool\n\n\nTrait hook enabling the annular radii rule bundle on fields :radius_in and :radius_ext (normalized numbers required, finiteness, nonâ€‘negativity, and the ordering constraint :radius_in < :radius_ext). It does not indicate the mere existence of radii; it opts in to the annular/coaxial shell geometry checks.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nBool flag.\n\nExamples\n\nValidation.has_radii(Tubular)  # true\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.has_temperature-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.has_temperature","text":"has_temperature(_::Type) -> Bool\n\n\nTrait hook indicating whether a component type uses a :temperature field subject to finiteness checks.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nBool flag.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.is_radius_input-Union{Tuple{F}, Tuple{T}, Tuple{Type{T}, Val{F}, Any}} where {T, F}","page":"Validation module","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(_::Type{T}, _::Val{F}, x) -> Bool\n\n\nFieldâ€‘aware acceptance predicate used by sanitize to distinguish inner vs. outer radius policies. The default forwards to is_radius_input(::Type{T}, x) when no fieldâ€‘specific method is defined.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{F}: Field tag; typically Val(:radius_in) or Val(:radius_ext) [dimensionless].\nx: Candidate value [dimensionless].\n\nReturns\n\nBool indicating acceptance.\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_in), 0.01)   # true\nValidation.is_radius_input(Tubular, Val(:radius_ext), 0.01)  # true\n\nSee also\n\nsanitize\nis_radius_input(::Type{T}, x)\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Validation module","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(_::Type{T}, x) -> Bool\n\n\nTrait predicate that defines admissible raw radius inputs for a component type during sanitize. The default accepts real, nonâ€‘complex numbers only. Component code may extend this to allow proxies (e.g., AbstractCablePart, Thickness, Diameter).\n\nArguments\n\n::Type{T}: Component type [dimensionless].\nx: Candidate value [dimensionless].\n\nReturns\n\nBool indicating acceptance.\n\nExamples\n\nValidation.is_radius_input(Tubular, 0.01)  # true by default\nValidation.is_radius_input(Tubular, 1 + 0im)  # false (complex)\n\nSee also\n\nsanitize\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_ext}, Number}} where T","page":"Validation module","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_ext},\n    x::Number\n) -> Bool\n\n\nDefault policy for outer radius raw inputs (annular shells): accept real numbers. Proxies are rejected at this stage to prevent zeroâ€‘thickness stacking.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_ext}: Field tag for the outer radius [dimensionless].\nx::Number: Candidate value [dimensionless].\n\nReturns\n\nBool indicating acceptance (true for real, nonâ€‘complex numbers).\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_ext), 0.02)  # true\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.is_radius_input-Union{Tuple{T}, Tuple{Type{T}, Val{:radius_in}, Number}} where T","page":"Validation module","title":"LineCableModels.Validation.is_radius_input","text":"is_radius_input(\n    _::Type{T},\n    _::Val{:radius_in},\n    x::Number\n) -> Bool\n\n\nDefault policy for inner radius raw inputs: accept real numbers.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n::Val{:radius_in}: Field tag for the inner radius [dimensionless].\nx::Number: Candidate value [dimensionless].\n\nReturns\n\nBool indicating acceptance (true for real, nonâ€‘complex numbers).\n\nExamples\n\nValidation.is_radius_input(Tubular, Val(:radius_in), 0.0)   # true\nValidation.is_radius_input(Tubular, Val(:radius_in), 1+0im) # false\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.keyword_defaults-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.keyword_defaults","text":"keyword_defaults(_::Type) -> Tuple{Float64, Int64}\n\n\nTrait hook supplying default values for optional keyword fields.\n\nReturn either:\n\na NamedTuple mapping defaults by name (e.g., (temperature = Tâ‚€,)), or\na plain Tuple of defaults aligned with keyword_fields(T) (same order + length).\n\nDefaults are applied in sanitize after positionalâ†’named merge and before rule application. User-provided keywords always override these defaults.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nNamedTuple or Tuple with default keyword values.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.keyword_fields-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.keyword_fields","text":"keyword_fields(_::Type) -> Tuple{Symbol, Symbol}\n\n\nTrait hook listing optional keyword fields considered by sanitize.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of optional keyword field names.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.maxfill","page":"Validation module","title":"LineCableModels.Validation.maxfill","text":"maxfill(::Type{T}, args...)\n\nCalculates the maximum physical number of strands that can fit for component T. Custom shapes must overload this method.\n\n\n\n\n\n","category":"function"},{"location":"validation/#LineCableModels.Validation.parse-Tuple{Type, Any}","page":"Validation module","title":"LineCableModels.Validation.parse","text":"parse(\n    _::Type,\n    nt\n) -> Union{NamedTuple, DataStructures.SortedMultiDict}\n\n\nParses and normalizes raw inputs produced by sanitize into the canonical form expected by rules. Default is identity; component code overrides this to resolve proxy radii to numeric values while preserving uncertainty semantics.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\nnt::NamedTuple: Raw inputs from sanitize [dimensionless].\n\nReturns\n\nNamedTuple with normalized fields (e.g., numeric :radius_in, :radius_ext).\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.required_fields-Tuple{Type}","page":"Validation module","title":"LineCableModels.Validation.required_fields","text":"required_fields(_::Type) -> NTuple{5, Symbol}\n\n\nTrait hook listing required fields that must be present after positionalâ†’named merge in sanitize.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\n\nReturns\n\nTuple of required field names.\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.sanitize-Union{Tuple{T}, Tuple{Type{T}, Tuple, NamedTuple}} where T","page":"Validation module","title":"LineCableModels.Validation.sanitize","text":"sanitize(\n    _::Type{T},\n    args::Tuple,\n    kwargs::NamedTuple\n) -> NamedTuple\n\n\nPerforms raw input checks and shapes the input into a NamedTuple without parsing proxies. Responsibilities: arity validation, positionalâ†’named mapping, required field presence, and raw acceptance of radius inputs via is_radius_input when has_radii(T) is true.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\nargs::Tuple: Positional arguments as received by the convenience constructor [dimensionless].\nkwargs::NamedTuple: Keyword arguments [dimensionless].\n\nReturns\n\nNamedTuple with raw (unparsed) fields.\n\nErrors\n\nArgumentError on invalid arity, excess positional arguments, missing required fields, or rejected raw radius inputs.\n\nNotes\n\nRequired arguments must be positional; optional arguments must be passed as keywords. Positional arity must equal length(required_fields(T)).\n\nExamples\n\nnt = sanitize(Tubular, (0.01, 0.02, material), (; temperature = 20.0,))\n\n\n\n\n\n","category":"method"},{"location":"validation/#LineCableModels.Validation.validate!-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T","page":"Validation module","title":"LineCableModels.Validation.validate!","text":"validate!(::Type{T}, args...; kwargs...) -> Any\n\n\nRuns the full validation pipeline for a component type: sanitize (arity and raw checks), parse (proxy normalization), then application of the generated rule set. Intended to be called from convenience constructors.\n\nArguments\n\n::Type{T}: Component type [dimensionless].\nargs...: Positional arguments [dimensionless].\nkwargs...: Keyword arguments [dimensionless].\n\nReturns\n\nNamedTuple containing normalized fields ready for construction.\n\nErrors\n\nArgumentError from sanitize or rule checks; DomainError for finiteness violations.\n\nExamples\n\nnt = validate!(Tubular, 0.01, 0.02, material; temperature = 20.0)\n# use nt.radius_in, nt.radius_ext, nt.temperature thereafter\n\nSee also\n\nsanitize\nparse\ncoercive_fields\n\n\n\n\n\n","category":"method"},{"location":"#LineCableModels.jl","page":"Home","title":"LineCableModels.jl","text":"LineCableModels.jl is a specialized Julia package designed to compute the electrical parameters of coaxial arbitrarily-layered underground/overhead cables with uncertainty quantification. It focuses on calculating line and cable impedances and admittances in the frequency-domain, accounting for skin effect, insulation properties, and earth-return impedances with frequency-dependent soil models.","category":"section"},{"location":"#Documentation-outline","page":"Home","title":"Documentation outline","text":"Pages = [\n    \"index.md\",\n    \"tutorials.md\",\n    \"reference.md\",\n    \"bib.md\",\n]\nDepth = 1","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Calculates all base DC parameters of a given cable design (R, L, C and G), for solid, tubular or stranded cores, semiconductors, screens, armors, sheaths, tapes,  and water-blocking materials, with uncertainty propagation using the Measurements.jl package.\nCorrection factors to account for temperature, stranding and twisting effects on the DC resistance [1], GMR [2] and base inductance of stranded cores and wire screens [3].\nExplicit computation of dielectric losses and effective resistances for insulators and semiconductors [4]. Correction of the magnetic constant of insulation layers to account for the solenoid effect introduced by twisted strands [5].\nComputes phase-domain Z/Y matrices for poliphase systems with any number of conductors per phase, and sequence-domain components for three-phase systems, with uncertainty propagation.\nImproved equivalent tubular representation for EMT simulations and direct export to ATPDraw and PSCAD formats.\nComputes internal impedances of solid, tubular or coaxial multi-layered single-core (SC) cables, using rigorous [6] or equivalent approximate formulas available in industry-standard EMT software.\nComputes earth-return impedances and admittances of underground conductors in homogeneous soil, based on a rigorous solution of Helmholtz equation on the electric Hertzian vector, valid up to 10 MHz [7].","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Clone the package and add to the Julia environment:\n\npkg> add https://github.com/Electa-Git/LineCableModels.jl.git\n\nIf you are using the finite-element solver, it is recommended to run the build script to retrieve the binaries needed by the GetDP.jl front-end:\n\npkg> build LineCableModels\n\nThen, in your Julia code, import the package:\n\nusing LineCableModels","category":"section"},{"location":"#License","page":"Home","title":"License","text":"The source code is provided under the BSD 3-Clause License.\n\n\n\n<p align=\"left\">Documentation generated using <a target=\"_blank\" href=\"https://github.com/JuliaDocs/Documenter.jl\">Documenter.jl</a> and <a target=\"_blank\" href=\"https://github.com/fredrikekre/Literate.jl\">Literate.jl</a>.</p>","category":"section"}]
}
